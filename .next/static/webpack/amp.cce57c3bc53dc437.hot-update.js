"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/next/dist/client/dev/amp-dev.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/dev/amp-dev.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar _fouc = __webpack_require__(/*! ./fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nvar _onDemandEntriesClient = _interopRequireDefault1(__webpack_require__(/*! ./on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\nwindow.__NEXT_DATA__ = data;\nvar assetPrefix = data.assetPrefix, page = data.page;\nassetPrefix = assetPrefix || '';\nvar mostRecentHash = null;\n/* eslint-disable-next-line */ var curHash = __webpack_require__.h();\nvar hotUpdatePath = assetPrefix + (assetPrefix.endsWith('/') ? '' : '/') + '_next/static/webpack/';\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n    // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    /* eslint-disable-next-line */ return mostRecentHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === 'idle';\n}\nfunction tryApplyUpdates() {\n    return _tryApplyUpdates.apply(this, arguments);\n}\nfunction _tryApplyUpdates() {\n    _tryApplyUpdates = // reloads the page when it has changed.\n    _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n        var res, jsonData, curPage, pageUpdated;\n        return _runtimeJs.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (!(!isUpdateAvailable() || !canApplyUpdates())) {\n                        _ctx.next = 2;\n                        break;\n                    }\n                    return _ctx.abrupt(\"return\");\n                case 2:\n                    _ctx.prev = 2;\n                    _ctx.next = 5;\n                    return fetch(typeof __webpack_require__.j !== 'undefined' ? \"\".concat(hotUpdatePath).concat(curHash, \".\").concat(__webpack_require__.j, \".hot-update.json\") : \"\".concat(hotUpdatePath).concat(curHash, \".hot-update.json\"));\n                case 5:\n                    res = _ctx.sent;\n                    _ctx.next = 8;\n                    return res.json();\n                case 8:\n                    jsonData = _ctx.sent;\n                    curPage = page === '/' ? 'index' : page;\n                    pageUpdated = (Array.isArray(jsonData.c) ? jsonData.c : Object.keys(jsonData.c)).some(function(mod) {\n                        return mod.indexOf(\"pages\".concat(curPage.startsWith('/') ? curPage : \"/\".concat(curPage))) !== -1 || mod.indexOf(\"pages\".concat(curPage.startsWith('/') ? curPage : \"/\".concat(curPage)).replace(/\\//g, '\\\\')) !== -1;\n                    });\n                    if (pageUpdated) {\n                        document.location.reload(true);\n                    } else {\n                        curHash = mostRecentHash;\n                    }\n                    _ctx.next = 18;\n                    break;\n                case 14:\n                    _ctx.prev = 14;\n                    _ctx.t0 = _ctx[\"catch\"](2);\n                    console.error('Error occurred checking for update', _ctx.t0);\n                    document.location.reload(true);\n                case 18:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee, null, [\n            [\n                2,\n                14\n            ]\n        ]);\n    }));\n    return _tryApplyUpdates.apply(this, arguments);\n}\n(0, _websocket).addMessageListener(function(event) {\n    if (event.data === '\\ud83d\\udc93') {\n        return;\n    }\n    try {\n        var message = JSON.parse(event.data);\n        if (message.action === 'sync' || message.action === 'built') {\n            if (!message.hash) {\n                return;\n            }\n            mostRecentHash = message.hash;\n            tryApplyUpdates();\n        } else if (message.action === 'reloadPage') {\n            document.location.reload(true);\n        }\n    } catch (ex) {\n        console.warn('Invalid HMR message: ' + event.data + '\\n' + ex);\n    }\n});\n(0, _websocket).connectHMR({\n    assetPrefix: assetPrefix,\n    path: '/_next/webpack-hmr'\n});\n(0, _fouc).displayContent();\n(0, _onDemandEntriesClient).default(data.page); //# sourceMappingURL=amp-dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvYW1wLWRldi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7Ozs7OztBQUNaLEdBQUcsQ0FBQ0EsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLDJEQUFRO0FBQzVCLEdBQUcsQ0FBQ0Msc0JBQXNCLEdBQUdDLHVCQUFzQixDQUFDRixtQkFBTyxDQUFDLG1HQUE0QjtBQUN4RixHQUFHLENBQUNHLFVBQVUsR0FBR0gsbUJBQU8sQ0FBQyxpR0FBMkI7U0FDM0NJLGtCQUFrQixDQUFDQyxHQUFHLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUUsQ0FBQztJQUN4RSxHQUFHLENBQUMsQ0FBQztRQUNELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHUCxHQUFHLENBQUNLLEdBQUcsRUFBRUMsR0FBRztRQUN2QixHQUFHLENBQUNFLEtBQUssR0FBR0QsSUFBSSxDQUFDQyxLQUFLO0lBQzFCLENBQUMsQ0FBQyxLQUFLLEVBQUVDLEtBQUssRUFBRSxDQUFDO1FBQ2JQLE1BQU0sQ0FBQ08sS0FBSztRQUNaLE1BQU07SUFDVixDQUFDO0lBQ0QsRUFBRSxFQUFFRixJQUFJLENBQUNHLElBQUksRUFBRSxDQUFDO1FBQ1pULE9BQU8sQ0FBQ08sS0FBSztJQUNqQixDQUFDLE1BQU0sQ0FBQztRQUNKRyxPQUFPLENBQUNWLE9BQU8sQ0FBQ08sS0FBSyxFQUFFSSxJQUFJLENBQUNULEtBQUssRUFBRUMsTUFBTTtJQUM3QyxDQUFDO0FBQ0wsQ0FBQztTQUNRUyxpQkFBaUIsQ0FBQ0MsRUFBRSxFQUFFLENBQUM7SUFDNUIsTUFBTSxDQUFDLFFBQVEsR0FBRyxDQUFDO1FBQ2YsR0FBRyxDQUFDQyxJQUFJLEdBQUcsSUFBSSxFQUFFQyxJQUFJLEdBQUdDLFNBQVM7UUFDakMsTUFBTSxDQUFDLEdBQUcsQ0FBQ04sT0FBTyxDQUFDLFFBQVEsQ0FBQ1YsT0FBTyxFQUFFQyxN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Q0MsS0FBSyxDQUFDeUMsS0FBSyxDQUFDM0MsSUFBSTtRQUNyQyxFQUFFLEVBQUU0QyxPQUFPLENBQUNDLE1BQU0sS0FBSyxDQUFNLFNBQUlELE9BQU8sQ0FBQ0MsTUFBTSxLQUFLLENBQU8sUUFBRSxDQUFDO1lBQzFELEVBQUUsR0FBR0QsT0FBTyxDQUFDRSxJQUFJLEVBQUUsQ0FBQztnQkFDaEIsTUFBTTtZQUNWLENBQUM7WUFDRHBDLGNBQWMsR0FBR2tDLE9BQU8sQ0FBQ0UsSUFBSTtZQUM3QjFCLGVBQWU7UUFDbkIsQ0FBQyxNQUFNLEVBQUUsRUFBRXdCLE9BQU8sQ0FBQ0MsTUFBTSxLQUFLLENBQVksYUFBRSxDQUFDO1lBQ3pDMUMsUUFBUSxDQUFDb0MsUUFBUSxDQUFDQyxNQUFNLENBQUMsSUFBSTtRQUNqQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLEtBQUssRUFBRU8sRUFBRSxFQUFFLENBQUM7UUFDVk4sT0FBTyxDQUFDTyxJQUFJLENBQUMsQ0FBdUIseUJBQUdMLEtBQUssQ0FBQzNDLElBQUksR0FBRyxDQUFJLE1BQUcrQyxFQUFFO0lBQ2pFLENBQUM7QUFDTCxDQUFDO0NBQ0EsQ0FBQyxFQUFFekUsVUFBVSxFQUFFMkUsVUFBVSxDQUFDLENBQUM7SUFDeEJ6QyxXQUFXLEVBQVhBLFdBQVc7SUFDWDBDLElBQUksRUFBRSxDQUFvQjtBQUM5QixDQUFDO0NBQ0EsQ0FBQyxFQUFFaEYsS0FBSyxFQUFFaUYsY0FBYztDQUN4QixDQUFDLEVBQUUvRSxzQkFBc0IsRUFBRTJCLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDUyxJQUFJLEVBRTdDLENBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9hbXAtZGV2LmpzPzVjY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2ZvdWMgPSByZXF1aXJlKFwiLi9mb3VjXCIpO1xudmFyIF9vbkRlbWFuZEVudHJpZXNDbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudFwiKSk7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX05FWFRfREFUQV9fJykudGV4dENvbnRlbnQpO1xud2luZG93Ll9fTkVYVF9EQVRBX18gPSBkYXRhO1xubGV0IHsgYXNzZXRQcmVmaXggLCBwYWdlICB9ID0gZGF0YTtcbmFzc2V0UHJlZml4ID0gYXNzZXRQcmVmaXggfHwgJyc7XG5sZXQgbW9zdFJlY2VudEhhc2ggPSBudWxsO1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovIGxldCBjdXJIYXNoID0gX193ZWJwYWNrX2hhc2hfXztcbmNvbnN0IGhvdFVwZGF0ZVBhdGggPSBhc3NldFByZWZpeCArIChhc3NldFByZWZpeC5lbmRzV2l0aCgnLycpID8gJycgOiAnLycpICsgJ19uZXh0L3N0YXRpYy93ZWJwYWNrLyc7XG4vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCkge1xuICAgIC8vIF9fd2VicGFja19oYXNoX18gaXMgdGhlIGhhc2ggb2YgdGhlIGN1cnJlbnQgY29tcGlsYXRpb24uXG4gICAgLy8gSXQncyBhIGdsb2JhbCB2YXJpYWJsZSBpbmplY3RlZCBieSBXZWJwYWNrLlxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqLyByZXR1cm4gbW9zdFJlY2VudEhhc2ggIT09IF9fd2VicGFja19oYXNoX187XG59XG4vLyBXZWJwYWNrIGRpc2FsbG93cyB1cGRhdGVzIGluIG90aGVyIHN0YXRlcy5cbmZ1bmN0aW9uIGNhbkFwcGx5VXBkYXRlcygpIHtcbiAgICByZXR1cm4gbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gJ2lkbGUnO1xufVxuZnVuY3Rpb24gdHJ5QXBwbHlVcGRhdGVzKCkge1xuICAgIHJldHVybiBfdHJ5QXBwbHlVcGRhdGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfdHJ5QXBwbHlVcGRhdGVzKCkge1xuICAgIF90cnlBcHBseVVwZGF0ZXMgPSAvLyBUaGlzIGZ1bmN0aW9uIHJlYWRzIGNvZGUgdXBkYXRlcyBvbiB0aGUgZmx5IGFuZCBoYXJkXG4gICAgLy8gcmVsb2FkcyB0aGUgcGFnZSB3aGVuIGl0IGhhcyBjaGFuZ2VkLlxuICAgIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgaWYgKCFpc1VwZGF0ZUF2YWlsYWJsZSgpIHx8ICFjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCBmZXRjaCh0eXBlb2YgX193ZWJwYWNrX3J1bnRpbWVfaWRfXyAhPT0gJ3VuZGVmaW5lZCcgPyBgJHtob3RVcGRhdGVQYXRofSR7Y3VySGFzaH0uJHtfX3dlYnBhY2tfcnVudGltZV9pZF9ffS5ob3QtdXBkYXRlLmpzb25gIDogYCR7aG90VXBkYXRlUGF0aH0ke2N1ckhhc2h9LmhvdC11cGRhdGUuanNvbmApO1xuICAgICAgICAgICAgY29uc3QganNvbkRhdGEgPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgY3VyUGFnZSA9IHBhZ2UgPT09ICcvJyA/ICdpbmRleCcgOiBwYWdlO1xuICAgICAgICAgICAgLy8gd2VicGFjayA1IHVzZXMgYW4gYXJyYXkgaW5zdGVhZFxuICAgICAgICAgICAgY29uc3QgcGFnZVVwZGF0ZWQgPSAoQXJyYXkuaXNBcnJheShqc29uRGF0YS5jKSA/IGpzb25EYXRhLmMgOiBPYmplY3Qua2V5cyhqc29uRGF0YS5jKSkuc29tZSgobW9kKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2QuaW5kZXhPZihgcGFnZXMke2N1clBhZ2Uuc3RhcnRzV2l0aCgnLycpID8gY3VyUGFnZSA6IGAvJHtjdXJQYWdlfWB9YCkgIT09IC0xIHx8IG1vZC5pbmRleE9mKGBwYWdlcyR7Y3VyUGFnZS5zdGFydHNXaXRoKCcvJykgPyBjdXJQYWdlIDogYC8ke2N1clBhZ2V9YH1gLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpKSAhPT0gLTE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwYWdlVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VySGFzaCA9IG1vc3RSZWNlbnRIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9jY3VycmVkIGNoZWNraW5nIGZvciB1cGRhdGUnLCBlcnIpO1xuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90cnlBcHBseVVwZGF0ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbigwLCBfd2Vic29ja2V0KS5hZGRNZXNzYWdlTGlzdGVuZXIoKGV2ZW50KT0+e1xuICAgIGlmIChldmVudC5kYXRhID09PSAnXFx1RDgzRFxcdURDOTMnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ3N5bmMnIHx8IG1lc3NhZ2UuYWN0aW9uID09PSAnYnVpbHQnKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vc3RSZWNlbnRIYXNoID0gbWVzc2FnZS5oYXNoO1xuICAgICAgICAgICAgdHJ5QXBwbHlVcGRhdGVzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5hY3Rpb24gPT09ICdyZWxvYWRQYWdlJykge1xuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEhNUiBtZXNzYWdlOiAnICsgZXZlbnQuZGF0YSArICdcXG4nICsgZXgpO1xuICAgIH1cbn0pO1xuKDAsIF93ZWJzb2NrZXQpLmNvbm5lY3RITVIoe1xuICAgIGFzc2V0UHJlZml4LFxuICAgIHBhdGg6ICcvX25leHQvd2VicGFjay1obXInXG59KTtcbigwLCBfZm91YykuZGlzcGxheUNvbnRlbnQoKTtcbigwLCBfb25EZW1hbmRFbnRyaWVzQ2xpZW50KS5kZWZhdWx0KGRhdGEucGFnZSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcC1kZXYuanMubWFwIl0sIm5hbWVzIjpbIl9mb3VjIiwicmVxdWlyZSIsIl9vbkRlbWFuZEVudHJpZXNDbGllbnQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3dlYnNvY2tldCIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJ2YWx1ZSIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwidGV4dENvbnRlbnQiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwiYXNzZXRQcmVmaXgiLCJwYWdlIiwibW9zdFJlY2VudEhhc2giLCJjdXJIYXNoIiwiX193ZWJwYWNrX2hhc2hfXyIsImhvdFVwZGF0ZVBhdGgiLCJlbmRzV2l0aCIsImlzVXBkYXRlQXZhaWxhYmxlIiwiY2FuQXBwbHlVcGRhdGVzIiwibW9kdWxlIiwiaG90Iiwic3RhdHVzIiwidHJ5QXBwbHlVcGRhdGVzIiwiX3RyeUFwcGx5VXBkYXRlcyIsInJlcyIsImpzb25EYXRhIiwiY3VyUGFnZSIsInBhZ2VVcGRhdGVkIiwiZmV0Y2giLCJfX3dlYnBhY2tfcnVudGltZV9pZF9fIiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsImMiLCJPYmplY3QiLCJrZXlzIiwic29tZSIsIm1vZCIsImluZGV4T2YiLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsImxvY2F0aW9uIiwicmVsb2FkIiwiY29uc29sZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImV2ZW50IiwibWVzc2FnZSIsImFjdGlvbiIsImhhc2giLCJleCIsIndhcm4iLCJjb25uZWN0SE1SIiwicGF0aCIsImRpc3BsYXlDb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/amp-dev.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/websocket.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/websocket.js ***!
  \**********************************************************************/
/***/ (function(module, exports) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addMessageListener = addMessageListener;\nexports.sendMessage = sendMessage;\nexports.connectHMR = connectHMR;\nvar source;\nvar eventCallbacks = [];\nvar lastActivity = Date.now();\nfunction getSocketProtocol(assetPrefix) {\n    var protocol = location.protocol;\n    try {\n        // assetPrefix is a url\n        protocol = new URL(assetPrefix).protocol;\n    } catch (_) {}\n    return protocol === 'http:' ? 'ws' : 'wss';\n}\nfunction addMessageListener(cb) {\n    eventCallbacks.push(cb);\n}\nfunction sendMessage(data) {\n    if (!source || source.readyState !== source.OPEN) return;\n    return source.send(data);\n}\nfunction connectHMR(options) {\n    var init = function init() {\n        if (source) source.close();\n        var hostname = location.hostname, port = location.port;\n        var protocol = getSocketProtocol(options.assetPrefix || '');\n        var assetPrefix = options.assetPrefix.replace(/^\\/+/, '');\n        var url = \"\".concat(protocol, \"://\").concat(hostname, \":\").concat(port).concat(assetPrefix ? \"/\".concat(assetPrefix) : '');\n        if (assetPrefix.startsWith('http')) {\n            url = \"\".concat(protocol, \"://\").concat(assetPrefix.split('://')[1]);\n        }\n        source = new window.WebSocket(\"\".concat(url).concat(options.path));\n        source.onopen = handleOnline;\n        source.onerror = handleDisconnect;\n        source.onmessage = handleMessage;\n    };\n    var handleOnline = function handleOnline() {\n        if (options.log) console.log('[HMR] connected');\n        lastActivity = Date.now();\n    };\n    var handleMessage = function handleMessage(event) {\n        lastActivity = Date.now();\n        eventCallbacks.forEach(function(cb) {\n            cb(event);\n        });\n    };\n    var handleDisconnect = function handleDisconnect() {\n        clearInterval(timer);\n        source.close();\n        setTimeout(init, options.timeout);\n    };\n    if (!options.timeout) {\n        options.timeout = 5 * 1000;\n    }\n    init();\n    var timer = setInterval(function() {\n        if (Date.now() - lastActivity > options.timeout) {\n            handleDisconnect();\n        }\n    }, options.timeout / 2);\n} //# sourceMappingURL=websocket.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS93ZWJzb2NrZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHRSxrQkFBa0I7QUFDL0NGLG1CQUFtQixHQUFHRyxXQUFXO0FBQ2pDSCxrQkFBa0IsR0FBR0ksVUFBVTtBQUMvQixHQUFHLENBQUNDLE1BQU07QUFDVixHQUFLLENBQUNDLGNBQWMsR0FBRyxDQUFDLENBQUM7QUFDekIsR0FBRyxDQUFDQyxZQUFZLEdBQUdDLElBQUksQ0FBQ0MsR0FBRztTQUNsQkMsaUJBQWlCLENBQUNDLFdBQVcsRUFBRSxDQUFDO0lBQ3JDLEdBQUcsQ0FBQ0MsUUFBUSxHQUFHQyxRQUFRLENBQUNELFFBQVE7SUFDaEMsR0FBRyxDQUFDLENBQUM7UUFDRCxFQUF1QjtRQUN2QkEsUUFBUSxHQUFHLEdBQUcsQ0FBQ0UsR0FBRyxDQUFDSCxXQUFXLEVBQUVDLFFBQVE7SUFDNUMsQ0FBQyxDQUFDLEtBQUssRUFBRUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNkLE1BQU0sQ0FBQ0gsUUFBUSxLQUFLLENBQU8sU0FBRyxDQUFJLE1BQUcsQ0FBSztBQUM5QyxDQUFDO1NBQ1FWLGtCQUFrQixDQUFDYyxFQUFFLEVBQUUsQ0FBQztJQUM3QlYsY0FBYyxDQUFDVyxJQUFJLENBQUNELEVBQUU7QUFDMUIsQ0FBQztTQUNRYixXQUFXLENBQUNlLElBQUksRUFBRSxDQUFDO0lBQ3hCLEVBQUUsR0FBR2IsTUFBTSxJQUFJQSxNQUFNLENBQUNjLFVBQVUsS0FBS2QsTUFBTSxDQUFDZSxJQUFJLEVBQUUsTUFBTTtJQUN4RCxNQUFNLENBQUNmLE1BQU0sQ0FBQ2dCLElBQUksQ0FBQ0gsSUFBSTtBQUMzQixDQUFDO1NBQ1FkLFVBQVUsQ0FBQ2tCLE9BQU8sRUFBRSxDQUFDO1FBVWpCQyxJQUFJLEdBQWIsUUFBUSxDQUFDQSxJQUFJLEdBQUcsQ0FBQztRQUNiLEVBQUUsRUFBRWxCLE1BQU0sRUFBRUEsTUFBTSxDQUFDbUIsS0FBSztRQUN4QixHQUFLLENBQUdDLFFBQVEsR0FBYVosUUFBUSxDQUE3QlksUUFBUSxFQUFHQyxJQUFJLEdBQU1iLFFBQVEsQ0FBbEJhLElBQUk7UUFDdkIsR0FBSyxDQUFDZCxRQUFRLEdBQUdGLGlCQUFpQixDQUFDWSxPQUFPLENBQUNYLFdBQVcsSUFBSSxDQUFFO1FBQzVELEdBQUssQ0FBQ0EsV0FBVyxHQUFHVyxPQUFPLENBQUNYLFdBQVcsQ0FBQ2dCLE9BQU8sU0FBUyxDQUFFO1FBQzFELEdBQUcsQ0FBQ0MsR0FBRyxHQUFJLEdBQWdCSCxNQUFRLENBQXRCYixRQUFRLEVBQUMsQ0FBRyxNQUFjYyxNQUFJLENBQWhCRCxRQUFRLEVBQUMsQ0FBQyxJQUFTZCxNQUFvQyxDQUEzQ2UsSUFBSSxFQUF3QyxPQUFyQ2YsV0FBVyxHQUFJLENBQUMsR0FBYyxPQUFaQSxXQUFXLElBQUssQ0FBRTtRQUNsRixFQUFFLEVBQUVBLFdBQVcsQ0FBQ2tCLFVBQVUsQ0FBQyxDQUFNLFFBQUcsQ0FBQztZQUNqQ0QsR0FBRyxHQUFJLEdBQWdCakIsTUFBMkIsQ0FBekNDLFFBQVEsRUFBQyxDQUFHLE1BQThCLE9BQTVCRCxXQUFXLENBQUNtQixLQUFLLENBQUMsQ0FBSyxNQUFFLENBQUM7UUFDckQsQ0FBQztRQUNEekIsTUFBTSxHQUFHLEdBQUcsQ0FBQzBCLE1BQU0sQ0FBQ0MsU0FBUyxDQUFFLEdBQVFWLE1BQVksQ0FBbEJNLEdBQUcsRUFBZ0IsT0FBYk4sT0FBTyxDQUFDVyxJQUFJO1FBQ25ENUIsTUFBTSxDQUFDNkIsTUFBTSxHQUFHQyxZQUFZO1FBQzVCOUIsTUFBTSxDQUFDK0IsT0FBTyxHQUFHQyxnQkFBZ0I7UUFDakNoQyxNQUFNLENBQUNpQyxTQUFTLEdBQUdDLGFBQWE7SUFDcEMsQ0FBQztRQUNRSixZQUFZLEdBQXJCLFFBQVEsQ0FBQ0EsWUFBWSxHQUFHLENBQUM7UUFDckIsRUFBRSxFQUFFYixPQUFPLENBQUNrQixHQUFHLEVBQUVDLE9BQU8sQ0FBQ0QsR0FBRyxDQUFDLENBQWlCO1FBQzlDakMsWUFBWSxHQUFHQyxJQUFJLENBQUNDLEdBQUc7SUFDM0IsQ0FBQztRQUNROEIsYUFBYSxHQUF0QixRQUFRLENBQUNBLGFBQWEsQ0FBQ0csS0FBSyxFQUFFLENBQUM7UUFDM0JuQyxZQUFZLEdBQUdDLElBQUksQ0FBQ0MsR0FBRztRQUN2QkgsY0FBYyxDQUFDcUMsT0FBTyxDQUFDLFFBQy9CLENBRGdDM0IsRUFBRSxFQUFHLENBQUM7WUFDMUJBLEVBQUUsQ0FBQzBCLEtBQUs7UUFDWixDQUFDO0lBQ0wsQ0FBQztRQUNRTCxnQkFBZ0IsR0FBekIsUUFBUSxDQUFDQSxnQkFBZ0IsR0FBRyxDQUFDO1FBQ3pCTyxhQUFhLENBQUNDLEtBQUs7UUFDbkJ4QyxNQUFNLENBQUNtQixLQUFLO1FBQ1pzQixVQUFVLENBQUN2QixJQUFJLEVBQUVELE9BQU8sQ0FBQ3lCLE9BQU87SUFDcEMsQ0FBQztJQXJDRCxFQUFFLEdBQUd6QixPQUFPLENBQUN5QixPQUFPLEVBQUUsQ0FBQztRQUNuQnpCLE9BQU8sQ0FBQ3lCLE9BQU8sR0FBRyxDQUFDLEdBQUcsSUFBSTtJQUM5QixDQUFDO0lBQ0R4QixJQUFJO0lBQ0osR0FBRyxDQUFDc0IsS0FBSyxHQUFHRyxXQUFXLENBQUMsUUFBUSxHQUFHLENBQUM7UUFDaEMsRUFBRSxFQUFFeEMsSUFBSSxDQUFDQyxHQUFHLEtBQUtGLFlBQVksR0FBR2UsT0FBTyxDQUFDeUIsT0FBTyxFQUFFLENBQUM7WUFDOUNWLGdCQUFnQjtRQUNwQixDQUFDO0lBQ0wsQ0FBQyxFQUFFZixPQUFPLENBQUN5QixPQUFPLEdBQUcsQ0FBQztBQThCMUIsQ0FBQyxDQUVvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS93ZWJzb2NrZXQuanM/YTliZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkTWVzc2FnZUxpc3RlbmVyID0gYWRkTWVzc2FnZUxpc3RlbmVyO1xuZXhwb3J0cy5zZW5kTWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuZXhwb3J0cy5jb25uZWN0SE1SID0gY29ubmVjdEhNUjtcbmxldCBzb3VyY2U7XG5jb25zdCBldmVudENhbGxiYWNrcyA9IFtdO1xubGV0IGxhc3RBY3Rpdml0eSA9IERhdGUubm93KCk7XG5mdW5jdGlvbiBnZXRTb2NrZXRQcm90b2NvbChhc3NldFByZWZpeCkge1xuICAgIGxldCBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGFzc2V0UHJlZml4IGlzIGEgdXJsXG4gICAgICAgIHByb3RvY29sID0gbmV3IFVSTChhc3NldFByZWZpeCkucHJvdG9jb2w7XG4gICAgfSBjYXRjaCAoXykge31cbiAgICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG59XG5mdW5jdGlvbiBhZGRNZXNzYWdlTGlzdGVuZXIoY2IpIHtcbiAgICBldmVudENhbGxiYWNrcy5wdXNoKGNiKTtcbn1cbmZ1bmN0aW9uIHNlbmRNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UucmVhZHlTdGF0ZSAhPT0gc291cmNlLk9QRU4pIHJldHVybjtcbiAgICByZXR1cm4gc291cmNlLnNlbmQoZGF0YSk7XG59XG5mdW5jdGlvbiBjb25uZWN0SE1SKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMudGltZW91dCkge1xuICAgICAgICBvcHRpb25zLnRpbWVvdXQgPSA1ICogMTAwMDtcbiAgICB9XG4gICAgaW5pdCgpO1xuICAgIGxldCB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eSA+IG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgICAgaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfSwgb3B0aW9ucy50aW1lb3V0IC8gMik7XG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkgc291cmNlLmNsb3NlKCk7XG4gICAgICAgIGNvbnN0IHsgaG9zdG5hbWUgLCBwb3J0ICB9ID0gbG9jYXRpb247XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gZ2V0U29ja2V0UHJvdG9jb2wob3B0aW9ucy5hc3NldFByZWZpeCB8fCAnJyk7XG4gICAgICAgIGNvbnN0IGFzc2V0UHJlZml4ID0gb3B0aW9ucy5hc3NldFByZWZpeC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgbGV0IHVybCA9IGAke3Byb3RvY29sfTovLyR7aG9zdG5hbWV9OiR7cG9ydH0ke2Fzc2V0UHJlZml4ID8gYC8ke2Fzc2V0UHJlZml4fWAgOiAnJ31gO1xuICAgICAgICBpZiAoYXNzZXRQcmVmaXguc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHtwcm90b2NvbH06Ly8ke2Fzc2V0UHJlZml4LnNwbGl0KCc6Ly8nKVsxXX1gO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KGAke3VybH0ke29wdGlvbnMucGF0aH1gKTtcbiAgICAgICAgc291cmNlLm9ub3BlbiA9IGhhbmRsZU9ubGluZTtcbiAgICAgICAgc291cmNlLm9uZXJyb3IgPSBoYW5kbGVEaXNjb25uZWN0O1xuICAgICAgICBzb3VyY2Uub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlT25saW5lKCkge1xuICAgICAgICBpZiAob3B0aW9ucy5sb2cpIGNvbnNvbGUubG9nKCdbSE1SXSBjb25uZWN0ZWQnKTtcbiAgICAgICAgbGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgICAgICBsYXN0QWN0aXZpdHkgPSBEYXRlLm5vdygpO1xuICAgICAgICBldmVudENhbGxiYWNrcy5mb3JFYWNoKChjYik9PntcbiAgICAgICAgICAgIGNiKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICBzb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgc2V0VGltZW91dChpbml0LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Vic29ja2V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsInNlbmRNZXNzYWdlIiwiY29ubmVjdEhNUiIsInNvdXJjZSIsImV2ZW50Q2FsbGJhY2tzIiwibGFzdEFjdGl2aXR5IiwiRGF0ZSIsIm5vdyIsImdldFNvY2tldFByb3RvY29sIiwiYXNzZXRQcmVmaXgiLCJwcm90b2NvbCIsImxvY2F0aW9uIiwiVVJMIiwiXyIsImNiIiwicHVzaCIsImRhdGEiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInNlbmQiLCJvcHRpb25zIiwiaW5pdCIsImNsb3NlIiwiaG9zdG5hbWUiLCJwb3J0IiwicmVwbGFjZSIsInVybCIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsIndpbmRvdyIsIldlYlNvY2tldCIsInBhdGgiLCJvbm9wZW4iLCJoYW5kbGVPbmxpbmUiLCJvbmVycm9yIiwiaGFuZGxlRGlzY29ubmVjdCIsIm9ubWVzc2FnZSIsImhhbmRsZU1lc3NhZ2UiLCJsb2ciLCJjb25zb2xlIiwiZXZlbnQiLCJmb3JFYWNoIiwiY2xlYXJJbnRlcnZhbCIsInRpbWVyIiwic2V0VGltZW91dCIsInRpbWVvdXQiLCJzZXRJbnRlcnZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/websocket.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _router = _interopRequireDefault1(__webpack_require__(/*! next/router */ \"./node_modules/next/router.js\"));\nvar _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar _default = function() {\n    var _ref = _asyncToGenerator(_runtimeJs.default.mark(function _callee(page) {\n        return _runtimeJs.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (page) {\n                        // in AMP the router isn't initialized on the client and\n                        // client-transitions don't occur so ping initial page\n                        setInterval(function() {\n                            (0, _websocket).sendMessage(JSON.stringify({\n                                event: 'ping',\n                                page: page\n                            }));\n                        }, 2500);\n                    } else {\n                        _router.default.ready(function() {\n                            setInterval(function() {\n                                // when notFound: true is returned we should use the notFoundPage\n                                // as the Router.pathname will point to the 404 page but we want\n                                // to ping the source page that returned notFound: true instead\n                                var notFoundSrcPage = self.__NEXT_DATA__.notFoundSrcPage;\n                                var pathname = (_router.default.pathname === '/404' || _router.default.pathname === '/_error') && notFoundSrcPage ? notFoundSrcPage : _router.default.pathname;\n                                (0, _websocket).sendMessage(JSON.stringify({\n                                    event: 'ping',\n                                    page: pathname\n                                }));\n                            }, 2500);\n                        });\n                    }\n                    (0, _websocket).addMessageListener(function(event) {\n                        if (event.data.indexOf('{') === -1) return;\n                        try {\n                            var payload = JSON.parse(event.data);\n                            // don't attempt fetching the page if we're already showing\n                            // the dev overlay as this can cause the error to be triggered\n                            // repeatedly\n                            if (payload.event === 'pong' && payload.invalid && !self.__NEXT_DATA__.err) {\n                                // Payload can be invalid even if the page does exist.\n                                // So, we check if it can be created.\n                                fetch(location.href, {\n                                    credentials: 'same-origin'\n                                }).then(function(pageRes) {\n                                    if (pageRes.status === 200) {\n                                        // Page exists now, reload\n                                        location.reload();\n                                    } else {\n                                        // Page doesn't exist\n                                        if (self.__NEXT_DATA__.page === _router.default.pathname && _router.default.pathname !== '/_error') {\n                                            // We are still on the page,\n                                            // reload to show 404 error page\n                                            location.reload();\n                                        }\n                                    }\n                                });\n                            }\n                        } catch (err) {\n                            console.error('on-demand-entries failed to parse response', err);\n                        }\n                    });\n                case 2:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return function(page) {\n        return _ref.apply(this, arguments);\n    };\n}();\nexports[\"default\"] = _default; //# sourceMappingURL=on-demand-entries-client.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOzs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3hCLEdBQUcsQ0FBQ0csT0FBTyxHQUFHQyx1QkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxrREFBYTtBQUMxRCxHQUFHLENBQUNDLFVBQVUsR0FBR0QsbUJBQU8sQ0FBQyxpR0FBMkI7U0FDM0NFLGtCQUFrQixDQUFDQyxHQUFHLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUUsQ0FBQztJQUN4RSxHQUFHLENBQUMsQ0FBQztRQUNELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHUCxHQUFHLENBQUNLLEdBQUcsRUFBRUMsR0FBRztRQUN2QixHQUFHLENBQUNiLEtBQUssR0FBR2MsSUFBSSxDQUFDZCxLQUFLO0lBQzFCLENBQUMsQ0FBQyxLQUFLLEVBQUVlLEtBQUssRUFBRSxDQUFDO1FBQ2JOLE1BQU0sQ0FBQ00sS0FBSztRQUNaLE1BQU07SUFDVixDQUFDO0lBQ0QsRUFBRSxFQUFFRCxJQUFJLENBQUNFLElBQUksRUFBRSxDQUFDO1FBQ1pSLE9BQU8sQ0FBQ1IsS0FBSztJQUNqQixDQUFDLE1BQU0sQ0FBQztRQUNKaUIsT0FBTyxDQUFDVCxPQUFPLENBQUNSLEtBQUssRUFBRWtCLElBQUksQ0FBQ1IsS0FBSyxFQUFFQyxNQUFNO0lBQzdDLENBQUM7QUFDTCxDQUFDO1NBQ1FRLGlCQUFpQixDQUFDQyxFQUFFLEVBQUUsQ0FBQztJQUM1QixNQUFNLENBQUMsUUFBUSxHQUFHLENBQUM7UUFDZixHQUFHLENBQUNDLElBQUksR0FBRyxJQUFJLEVBQUVDLElBQUksR0FBR0MsU0FBUztR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Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcz84NDVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yb3V0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKSk7XG52YXIgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Vycm9yLW92ZXJsYXkvd2Vic29ja2V0XCIpO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qKHBhZ2UpIHtcbiAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgIC8vIGluIEFNUCB0aGUgcm91dGVyIGlzbid0IGluaXRpYWxpemVkIG9uIHRoZSBjbGllbnQgYW5kXG4gICAgICAgICAgICAvLyBjbGllbnQtdHJhbnNpdGlvbnMgZG9uJ3Qgb2NjdXIgc28gcGluZyBpbml0aWFsIHBhZ2VcbiAgICAgICAgICAgIHNldEludGVydmFsKCgpPT57XG4gICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdwaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sIDI1MDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3JvdXRlci5kZWZhdWx0LnJlYWR5KCgpPT57XG4gICAgICAgICAgICAgICAgc2V0SW50ZXJ2YWwoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBub3RGb3VuZDogdHJ1ZSBpcyByZXR1cm5lZCB3ZSBzaG91bGQgdXNlIHRoZSBub3RGb3VuZFBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIFJvdXRlci5wYXRobmFtZSB3aWxsIHBvaW50IHRvIHRoZSA0MDQgcGFnZSBidXQgd2Ugd2FudFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBwaW5nIHRoZSBzb3VyY2UgcGFnZSB0aGF0IHJldHVybmVkIG5vdEZvdW5kOiB0cnVlIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90Rm91bmRTcmNQYWdlID0gc2VsZi5fX05FWFRfREFUQV9fLm5vdEZvdW5kU3JjUGFnZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lID09PSAnLzQwNCcgfHwgX3JvdXRlci5kZWZhdWx0LnBhdGhuYW1lID09PSAnL19lcnJvcicpICYmIG5vdEZvdW5kU3JjUGFnZSA/IG5vdEZvdW5kU3JjUGFnZSA6IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQpLnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiAncGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYXRobmFtZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSwgMjUwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgX3dlYnNvY2tldCkuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCk9PntcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ3snKSA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCBmZXRjaGluZyB0aGUgcGFnZSBpZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGV2IG92ZXJsYXkgYXMgdGhpcyBjYW4gY2F1c2UgdGhlIGVycm9yIHRvIGJlIHRyaWdnZXJlZFxuICAgICAgICAgICAgICAgIC8vIHJlcGVhdGVkbHlcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5ldmVudCA9PT0gJ3BvbmcnICYmIHBheWxvYWQuaW52YWxpZCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXlsb2FkIGNhbiBiZSBpbnZhbGlkIGV2ZW4gaWYgdGhlIHBhZ2UgZG9lcyBleGlzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gU28sIHdlIGNoZWNrIGlmIGl0IGNhbiBiZSBjcmVhdGVkLlxuICAgICAgICAgICAgICAgICAgICBmZXRjaChsb2NhdGlvbi5ocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChwYWdlUmVzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VSZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYWdlIGV4aXN0cyBub3csIHJlbG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYWdlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfREFUQV9fLnBhZ2UgPT09IF9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSAmJiBfcm91dGVyLmRlZmF1bHQucGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3RpbGwgb24gdGhlIHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbG9hZCB0byBzaG93IDQwNCBlcnJvciBwYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignb24tZGVtYW5kLWVudHJpZXMgZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX3JvdXRlciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3dlYnNvY2tldCIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJlcnJvciIsImRvbmUiLCJQcm9taXNlIiwidGhlbiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiZm4iLCJzZWxmIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcGx5IiwiZXJyIiwidW5kZWZpbmVkIiwib2JqIiwiX19lc01vZHVsZSIsIl9kZWZhdWx0IiwiX3JlZiIsInBhZ2UiLCJzZXRJbnRlcnZhbCIsInNlbmRNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImV2ZW50IiwicmVhZHkiLCJub3RGb3VuZFNyY1BhZ2UiLCJfX05FWFRfREFUQV9fIiwicGF0aG5hbWUiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJkYXRhIiwiaW5kZXhPZiIsInBheWxvYWQiLCJwYXJzZSIsImludmFsaWQiLCJmZXRjaCIsImxvY2F0aW9uIiwiaHJlZiIsImNyZWRlbnRpYWxzIiwicGFnZVJlcyIsInN0YXR1cyIsInJlbG9hZCIsImNvbnNvbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/on-demand-entries-client.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nvar MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    var entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    var resolver;\n    var prom = new Promise(function(resolve) {\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator() // eslint-disable-next-line no-sequences\n    .then(function(value) {\n        return resolver(value), value;\n    }).catch(function(err) {\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// with relList.support\n        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nvar canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise(function(res, rej) {\n        var selector = \"\\n      link[rel=\\\"prefetch\\\"][href^=\\\"\".concat(href, \"\\\"],\\n      link[rel=\\\"preload\\\"][href^=\\\"\").concat(href, \"\\\"],\\n      script[src^=\\\"\").concat(href, \"\\\"]\");\n        if (document.querySelector(selector)) {\n            return res();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = \"prefetch\";\n        link.crossOrigin = undefined;\n        link.onload = res;\n        link.onerror = rej;\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nvar ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction appendScript(src, script) {\n    return new Promise(function(resolve, reject) {\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = function() {\n            return reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n        };\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = undefined;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nvar devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise(function(resolve, reject) {\n        var cancelled = false;\n        p.then(function(r) {\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (true) {\n            (devBuildPromise || Promise.resolve()).then(function() {\n                (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return setTimeout(function() {\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms);\n                });\n            });\n        }\n        if (false) {}\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    var onBuildManifest = new Promise(function(resolve) {\n        // Mandatory because this is not concurrent safe:\n        var cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = function() {\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getMiddlewareManifest() {\n    if (self.__MIDDLEWARE_MANIFEST) {\n        return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n    }\n    var onMiddlewareManifest = new Promise(function(resolve) {\n        var cb = self.__MIDDLEWARE_MANIFEST_CB;\n        self.__MIDDLEWARE_MANIFEST_CB = function() {\n            resolve(self.__MIDDLEWARE_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (true) {\n        return Promise.resolve({\n            scripts: [\n                assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js')), \n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then(function(manifest) {\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n        }\n        var allFiles = manifest[route].map(function(entry) {\n            return assetPrefix + '/_next/' + encodeURI(entry);\n        });\n        return {\n            scripts: allFiles.filter(function(v) {\n                return v.endsWith('.js');\n            }),\n            css: allFiles.filter(function(v) {\n                return v.endsWith('.css');\n            })\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    var maybeExecuteScript = function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (false) { var prom; } else {\n            return appendScript(src);\n        }\n    };\n    var fetchStyleSheet = function fetchStyleSheet(href) {\n        var prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then(function(res) {\n            if (!res.ok) {\n                throw new Error(\"Failed to load stylesheet: \".concat(href));\n            }\n            return res.text().then(function(text) {\n                return {\n                    href: href,\n                    content: text\n                };\n            });\n        }).catch(function(err) {\n            throw markAssetError(err);\n        }));\n        return prom;\n    };\n    var entrypoints = new Map();\n    var loadedScripts = new Map();\n    var styleSheets = new Map();\n    var routes = new Map();\n    return {\n        whenEntrypoint: function whenEntrypoint(route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint: function onEntrypoint(route, execute) {\n            (execute ? Promise.resolve().then(function() {\n                return execute();\n            }).then(function(exports) {\n                return {\n                    component: exports && exports.default || exports,\n                    exports: exports\n                };\n            }, function(err) {\n                return {\n                    error: err\n                };\n            }) : Promise.resolve(undefined)).then(function(input) {\n                var old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute: function loadRoute(route, prefetch) {\n            var _this = this;\n            return withFuture(route, routes, function() {\n                var _this1 = _this;\n                var devBuildPromiseResolve;\n                if (true) {\n                    devBuildPromise = new Promise(function(resolve) {\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(function(param) {\n                    var scripts = param.scripts, css = param.css;\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet)), \n                    ]);\n                }).then(function(res) {\n                    return _this1.whenEntrypoint(route).then(function(entrypoint) {\n                        return {\n                            entrypoint: entrypoint,\n                            styles: res[1]\n                        };\n                    });\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then(function(param) {\n                    var entrypoint = param.entrypoint, styles = param.styles;\n                    var res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch(function(err) {\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(function() {\n                    return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch: function prefetch(route) {\n            var _this = this;\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            var cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then(function(output) {\n                return Promise.all(canPrefetch ? output.scripts.map(function(script) {\n                    return prefetchViaDom(script, 'script');\n                }) : []);\n            }).then(function() {\n                var _this2 = _this;\n                (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return _this2.loadRoute(route, true).catch(function() {});\n                });\n            }).catch(function() {});\n        }\n    };\n} //# sourceMappingURL=route-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHRSxjQUFjO0FBQ3ZDRixvQkFBb0IsR0FBR0csWUFBWTtBQUNuQ0gsOEJBQThCLEdBQUdJLHNCQUFzQjtBQUN2REosNkJBQTZCLEdBQUdLLHFCQUFxQjtBQUNyREwseUJBQXlCLEdBQUdNLGlCQUFpQjtBQUM3QyxHQUFHLENBQUNDLHNCQUFzQixHQUFHQyxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQywySUFBc0Q7QUFDbEgsR0FBRyxDQUFDQyxvQkFBb0IsR0FBR0QsbUJBQU8sQ0FBQyx5RkFBeUI7U0FDbkRELHNCQUFzQixDQUFDRyxHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLENBQUNBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEdBQUdELEdBQUcsR0FBRyxDQUFDO1FBQ2xDRSxPQUFPLEVBQUVGLEdBQUc7SUFDaEIsQ0FBQztBQUNMLENBQUM7QUFDRCxFQUF1RTtBQUN2RSxFQUF5RTtBQUN6RSxFQUEyRTtBQUMzRSxFQUFvQztBQUNwQyxHQUFLLENBQUNHLGlCQUFpQixHQUFHLElBQUk7U0FDckJDLFVBQVUsQ0FBQ0MsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLFNBQVMsRUFBRSxDQUFDO0lBQ3RDLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHRixHQUFHLENBQUNHLEdBQUcsQ0FBQ0osR0FBRztJQUN2QixFQUFFLEVBQUVHLEtBQUssRUFBRSxDQUFDO1FBQ1IsRUFBRSxFQUFFLENBQVEsV0FBSUEsS0FBSyxFQUFFLENBQUM7WUFDcEIsTUFBTSxDQUFDQSxLQUFLLENBQUNFLE1BQU07UUFDdkIsQ0FBQztRQUNELE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxPQUFPLENBQUNKLEtBQUs7SUFDaEMsQ0FBQztJQUNELEdBQUcs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Q0FBQ0ssYUFBYSxHQUFHLE1BQU0sQ0FBQ3hHLE9BQU8sQ0FBQ0MsT0FBTztZQUMxRSxDQUFDO1lBQ0QsTUFBTSxDQUFDMkQsZ0JBQWdCLENBQUNDLFdBQVcsRUFBRUMsS0FBSyxFQUFFekQsSUFBSSxDQUFDLFFBQVEsQ0FBUG9HLE1BQU07Z0JBQUd6RyxNQUFNLENBQU5BLE9BQU8sQ0FBQzZGLEdBQUcsQ0FBQzFFLFdBQVcsR0FBR3NGLE1BQU0sQ0FBQzFDLE9BQU8sQ0FBQ3BFLEdBQUcsQ0FBQyxRQUFRLENBQVA2QyxNQUFNO29CQUFHcEIsTUFBTSxDQUFOQSxjQUFjLENBQUNvQixNQUFNLEVBQUUsQ0FBUTtxQkFDekksQ0FBQyxDQUFDO2VBQ1JuQyxJQUFJLENBQUMsUUFDakIsR0FEcUIsQ0FBQzs7aUJBQ1AsQ0FBQyxFQUFFakIsb0JBQW9CLEVBQUU4RCxtQkFBbUIsQ0FBQyxRQUFRO29CQUFKLE1BQU0sUUFBRHdDLFNBQVMsQ0FBQzVCLEtBQUssRUFBRSxJQUFJLEVBQUV4RCxLQUFLLENBQUMsUUFDcEcsR0FEd0csQ0FBQyxDQUFDOztZQUU5RixDQUFDLEVBQUVBLEtBQUssQ0FDUixRQUFRLEdBQUosQ0FBQyxDQUFDO1FBQ1YsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDLENBRXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLWxvYWRlci5qcz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXJrQXNzZXRFcnJvciA9IG1hcmtBc3NldEVycm9yO1xuZXhwb3J0cy5pc0Fzc2V0RXJyb3IgPSBpc0Fzc2V0RXJyb3I7XG5leHBvcnRzLmdldENsaWVudEJ1aWxkTWFuaWZlc3QgPSBnZXRDbGllbnRCdWlsZE1hbmlmZXN0O1xuZXhwb3J0cy5nZXRNaWRkbGV3YXJlTWFuaWZlc3QgPSBnZXRNaWRkbGV3YXJlTWFuaWZlc3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRlTG9hZGVyID0gY3JlYXRlUm91dGVMb2FkZXI7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMDtcbmZ1bmN0aW9uIHdpdGhGdXR1cmUoa2V5LCBtYXAsIGdlbmVyYXRvcikge1xuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZXI7XG4gICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbWFwLnNldChrZXksIGVudHJ5ID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcbiAgICAgICAgZnV0dXJlOiBwcm9tXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgIC50aGVuKCh2YWx1ZSk9PihyZXNvbHZlcih2YWx1ZSksIHZhbHVlKVxuICAgICkuY2F0Y2goKGVycik9PntcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkgOiBwcm9tO1xufVxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaykge1xuICAgIHRyeSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIHJldHVybigvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB8fCBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGNhblByZWZldGNoID0gaGFzUHJlZmV0Y2goKTtcbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKGhyZWYsIGFzLCBsaW5rKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaik9PntcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBgXG4gICAgICBsaW5rW3JlbD1cInByZWZldGNoXCJdW2hyZWZePVwiJHtocmVmfVwiXSxcbiAgICAgIGxpbmtbcmVsPVwicHJlbG9hZFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXG4gICAgICBzY3JpcHRbc3JjXj1cIiR7aHJlZn1cIl1gO1xuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsOlxuICAgICAgICBpZiAoYXMpIGxpbmsuYXMgPSBhcztcbiAgICAgICAgbGluay5yZWwgPSBgcHJlZmV0Y2hgO1xuICAgICAgICBsaW5rLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgbGluay5vbmxvYWQgPSByZXM7XG4gICAgICAgIGxpbmsub25lcnJvciA9IHJlajtcbiAgICAgICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9KTtcbn1cbmNvbnN0IEFTU0VUX0xPQURfRVJST1IgPSBTeW1ib2woJ0FTU0VUX0xPQURfRVJST1InKTtcbmZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7fSk7XG59XG5mdW5jdGlvbiBpc0Fzc2V0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVycjtcbn1cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChzcmMsIHNjcmlwdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAgICAgLy8gMS4gU2V0dXAgc3VjY2Vzcy9mYWlsdXJlIGhvb2tzIGluIGNhc2UgdGhlIGJyb3dzZXIgc3luY2hyb25vdXNseVxuICAgICAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gKCk9PnJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuICAgICAgICA7XG4gICAgICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgICAgICAvLyAgICBicm93c2VyIGJlZ2lucyB0byBmZXRjaC5cbiAgICAgICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTjtcbiAgICAgICAgLy8gMy4gRmluYWxseSwgc2V0IHRoZSBzb3VyY2UgYW5kIGluamVjdCBpbnRvIHRoZSBET00gaW4gY2FzZSB0aGUgY2hpbGRcbiAgICAgICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcbn1cbi8vIFdlIHdhaXQgZm9yIHBhZ2VzIHRvIGJlIGJ1aWx0IGluIGRldiBiZWZvcmUgd2Ugc3RhcnQgdGhlIHJvdXRlIHRyYW5zaXRpb25cbi8vIHRpbWVvdXQgdG8gcHJldmVudCBhbiB1bi1uZWNlc3NhcnkgaGFyZCBuYXZpZ2F0aW9uIGluIGRldmVsb3BtZW50LlxubGV0IGRldkJ1aWxkUHJvbWlzZTtcbi8vIFJlc29sdmUgYSBwcm9taXNlIHRoYXQgdGltZXMgb3V0IGFmdGVyIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KHAsIG1zLCBlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBwLnRoZW4oKHIpPT57XG4gICAgICAgICAgICAvLyBSZXNvbHZlZCwgY2FuY2VsIHRoZSB0aW1lb3V0XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgLy8gV2Ugd3JhcCB0aGVzZSBjaGVja3Mgc2VwYXJhdGVseSBmb3IgYmV0dGVyIGRlYWQtY29kZSBlbGltaW5hdGlvbiBpblxuICAgICAgICAvLyBwcm9kdWN0aW9uIGJ1bmRsZXMuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKGRldkJ1aWxkUHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgbXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG1zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcbiAgICB9XG4gICAgY29uc3Qgb25CdWlsZE1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIC8vIE1hbmRhdG9yeSBiZWNhdXNlIHRoaXMgaXMgbm90IGNvbmN1cnJlbnQgc2FmZTpcbiAgICAgICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpPT57XG4gICAgICAgICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVCk7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0KG9uQnVpbGRNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IGJ1aWxkIG1hbmlmZXN0JykpKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVNYW5pZmVzdCgpIHtcbiAgICBpZiAoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fTUlERExFV0FSRV9NQU5JRkVTVCk7XG4gICAgfVxuICAgIGNvbnN0IG9uTWlkZGxld2FyZU1hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIGNvbnN0IGNiID0gc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1RfQ0I7XG4gICAgICAgIHNlbGYuX19NSURETEVXQVJFX01BTklGRVNUX0NCID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX01JRERMRVdBUkVfTUFOSUZFU1QpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChvbk1pZGRsZXdhcmVNYW5pZmVzdCwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IG1pZGRsZXdhcmUgbWFuaWZlc3QnKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBzY3JpcHRzOiBbXG4gICAgICAgICAgICAgICAgYXNzZXRQcmVmaXggKyAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICsgZW5jb2RlVVJJKCgwLCBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKS5kZWZhdWx0KHJvdXRlLCAnLmpzJykpLCBcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICBjc3M6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KT0+di5lbmRzV2l0aCgnLmpzJylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXgpIHtcbiAgICBjb25zdCBlbnRyeXBvaW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBsb2FkZWRTY3JpcHRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjKSB7XG4gICAgICAgIC8vIFdpdGggSE1SIHdlIG1pZ2h0IG5lZWQgdG8gXCJyZWxvYWRcIiBzY3JpcHRzIHdoZW4gdGhleSBhcmVcbiAgICAgICAgLy8gZGlzcG9zZWQgYW5kIHJlYWRkZWQuIEV4ZWN1dGluZyBzY3JpcHRzIHR3aWNlIGhhcyBubyBmdW5jdGlvbmFsXG4gICAgICAgIC8vIGRpZmZlcmVuY2VzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgbGV0IHByb20gPSBsb2FkZWRTY3JpcHRzLmdldChzcmMpO1xuICAgICAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLCBwcm9tID0gYXBwZW5kU2NyaXB0KHNyYykpO1xuICAgICAgICAgICAgcmV0dXJuIHByb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kU2NyaXB0KHNyYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTdHlsZVNoZWV0KGhyZWYpIHtcbiAgICAgICAgbGV0IHByb20gPSBzdHlsZVNoZWV0cy5nZXQoaHJlZik7XG4gICAgICAgIGlmIChwcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVNoZWV0cy5zZXQoaHJlZiwgcHJvbSA9IGZldGNoKGhyZWYpLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdHlsZXNoZWV0OiAke2hyZWZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKCh0ZXh0KT0+KHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2hlbkVudHJ5cG9pbnQgKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudHJ5cG9pbnQgKHJvdXRlLCBleGVjdXRlKSB7XG4gICAgICAgICAgICAoZXhlY3V0ZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmV4ZWN1dGUoKVxuICAgICAgICAgICAgKS50aGVuKChleHBvcnRzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBleHBvcnRzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICwgKGVycik9Pih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKS50aGVuKChpbnB1dCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnJlc29sdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZSBpcyBvdXRkYXRlZCBhbmQgd2Ugd2FudCB0byBpbnZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRSb3V0ZSAocm91dGUsIHByZWZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgcm91dGVzLCAoKT0+e1xuICAgICAgICAgICAgICAgIGxldCBkZXZCdWlsZFByb21pc2VSZXNvbHZlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBkZXZCdWlsZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKHsgc2NyaXB0cyAsIGNzcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSkgPyBbXSA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSwgXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSksIE1TX01BWF9JRExFX0RFTEFZLCBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYFJvdXRlIGRpZCBub3QgY29tcGxldGUgbG9hZGluZzogJHtyb3V0ZX1gKSkpLnRoZW4oKHsgZW50cnlwb2ludCAsIHN0eWxlcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICB9LCBlbnRyeXBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXM7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIGVycm9ycyBkdXJpbmcgcHJlZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPT09IG51bGwgfHwgZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZldGNoIChyb3V0ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgICAgICAgbGV0IGNuO1xuICAgICAgICAgICAgaWYgKGNuID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKG91dHB1dCk9PlByb21pc2UuYWxsKGNhblByZWZldGNoID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpPT5wcmVmZXRjaFZpYURvbShzY3JpcHQsICdzY3JpcHQnKVxuICAgICAgICAgICAgICAgICkgOiBbXSlcbiAgICAgICAgICAgICkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+dGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpPT57fSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSkuY2F0Y2goLy8gc3dhbGxvdyBwcmVmZXRjaCBlcnJvcnNcbiAgICAgICAgICAgICgpPT57fSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFya0Fzc2V0RXJyb3IiLCJpc0Fzc2V0RXJyb3IiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiZ2V0TWlkZGxld2FyZU1hbmlmZXN0IiwiY3JlYXRlUm91dGVMb2FkZXIiLCJfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcmVxdWVzdElkbGVDYWxsYmFjayIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiTVNfTUFYX0lETEVfREVMQVkiLCJ3aXRoRnV0dXJlIiwia2V5IiwibWFwIiwiZ2VuZXJhdG9yIiwiZW50cnkiLCJnZXQiLCJmdXR1cmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVyIiwicHJvbSIsInNldCIsInRoZW4iLCJjYXRjaCIsImVyciIsImRlbGV0ZSIsImhhc1ByZWZldGNoIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpbmRvdyIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiZSIsImNhblByZWZldGNoIiwicHJlZmV0Y2hWaWFEb20iLCJocmVmIiwiYXMiLCJyZXMiLCJyZWoiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ1JPU1NfT1JJR0lOIiwib25sb2FkIiwib25lcnJvciIsImhlYWQiLCJhcHBlbmRDaGlsZCIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJhcHBlbmRTY3JpcHQiLCJzcmMiLCJzY3JpcHQiLCJyZWplY3QiLCJFcnJvciIsImJvZHkiLCJkZXZCdWlsZFByb21pc2UiLCJyZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0IiwicCIsIm1zIiwiY2FuY2VsbGVkIiwiciIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZXRUaW1lb3V0Iiwic2VsZiIsIl9fQlVJTERfTUFOSUZFU1QiLCJvbkJ1aWxkTWFuaWZlc3QiLCJjYiIsIl9fQlVJTERfTUFOSUZFU1RfQ0IiLCJfX01JRERMRVdBUkVfTUFOSUZFU1QiLCJvbk1pZGRsZXdhcmVNYW5pZmVzdCIsIl9fTUlERExFV0FSRV9NQU5JRkVTVF9DQiIsImdldEZpbGVzRm9yUm91dGUiLCJhc3NldFByZWZpeCIsInJvdXRlIiwic2NyaXB0cyIsImVuY29kZVVSSSIsImNzcyIsIm1hbmlmZXN0IiwiYWxsRmlsZXMiLCJmaWx0ZXIiLCJ2IiwiZW5kc1dpdGgiLCJtYXliZUV4ZWN1dGVTY3JpcHQiLCJsb2FkZWRTY3JpcHRzIiwiZmV0Y2hTdHlsZVNoZWV0Iiwic3R5bGVTaGVldHMiLCJmZXRjaCIsIm9rIiwidGV4dCIsImNvbnRlbnQiLCJlbnRyeXBvaW50cyIsIk1hcCIsInJvdXRlcyIsIndoZW5FbnRyeXBvaW50Iiwib25FbnRyeXBvaW50IiwiZXhlY3V0ZSIsImNvbXBvbmVudCIsImVycm9yIiwidW5kZWZpbmVkIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJwcmVmZXRjaCIsImRldkJ1aWxkUHJvbWlzZVJlc29sdmUiLCJhbGwiLCJoYXMiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiYXNzaWduIiwiZmluYWxseSIsImNuIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwidGVzdCIsImVmZmVjdGl2ZVR5cGUiLCJvdXRwdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Router\", ({\n    enumerable: true,\n    get: function get() {\n        return _router.default;\n    }\n}));\nObject.defineProperty(exports, \"withRouter\", ({\n    enumerable: true,\n    get: function get() {\n        return _withRouter.default;\n    }\n}));\nexports.useRouter = useRouter;\nexports.createRouter = createRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _isError = _interopRequireDefault(__webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ \"./node_modules/next/dist/client/with-router.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar singletonRouter = {\n    router: null,\n    readyCallbacks: [],\n    ready: function ready(cb) {\n        if (this.router) return cb();\n        if (true) {\n            this.readyCallbacks.push(cb);\n        }\n    }\n};\n// Create public properties and methods of the router in the singletonRouter\nvar urlPropertyFields = [\n    'pathname',\n    'route',\n    'query',\n    'asPath',\n    'components',\n    'isFallback',\n    'basePath',\n    'locale',\n    'locales',\n    'defaultLocale',\n    'isReady',\n    'isPreview',\n    'isLocaleDomain',\n    'domainLocales', \n];\nvar routerEvents = [\n    'routeChangeStart',\n    'beforeHistoryChange',\n    'routeChangeComplete',\n    'routeChangeError',\n    'hashChangeStart',\n    'hashChangeComplete', \n];\nvar coreMethodFields = [\n    'push',\n    'replace',\n    'reload',\n    'back',\n    'prefetch',\n    'beforePopState', \n];\n// Events is a static property on the router, the router doesn't have to be initialized to use it\nObject.defineProperty(singletonRouter, 'events', {\n    get: function get() {\n        return _router.default.events;\n    }\n});\nurlPropertyFields.forEach(function(field) {\n    // Here we need to use Object.defineProperty because we need to return\n    // the property assigned to the actual router\n    // The value might get changed as we change routes and this is the\n    // proper way to access it\n    Object.defineProperty(singletonRouter, field, {\n        get: function get() {\n            var router = getRouter();\n            return router[field];\n        }\n    });\n});\ncoreMethodFields.forEach(function(field) {\n    singletonRouter[field] = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var _router1;\n        var router = getRouter();\n        return (_router1 = router)[field].apply(_router1, _toConsumableArray(args));\n    };\n});\nrouterEvents.forEach(function(event) {\n    singletonRouter.ready(function() {\n        _router.default.events.on(event, function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            var eventField = \"on\".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));\n            var _singletonRouter = singletonRouter;\n            if (_singletonRouter[eventField]) {\n                try {\n                    var __singletonRouter;\n                    (__singletonRouter = _singletonRouter)[eventField].apply(__singletonRouter, _toConsumableArray(args));\n                } catch (err) {\n                    console.error(\"Error when running the Router event: \".concat(eventField));\n                    console.error((0, _isError).default(err) ? \"\".concat(err.message, \"\\n\").concat(err.stack) : err + '');\n                }\n            }\n        });\n    });\n});\nfunction getRouter() {\n    if (!singletonRouter.router) {\n        var message = 'No router instance found.\\n' + 'You should only use \"next/router\" on the client side of your app.\\n';\n        throw new Error(message);\n    }\n    return singletonRouter.router;\n}\nvar _default = singletonRouter;\nexports[\"default\"] = _default;\nfunction useRouter() {\n    _s();\n    return _react.default.useContext(_routerContext.RouterContext);\n}\n_s(useRouter, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction createRouter() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    singletonRouter.router = _construct(_router.default, _toConsumableArray(args));\n    singletonRouter.readyCallbacks.forEach(function(cb) {\n        return cb();\n    });\n    singletonRouter.readyCallbacks = [];\n    return singletonRouter.router;\n}\nfunction makePublicRouterInstance(router) {\n    var scopedRouter = router;\n    var instance = {};\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = urlPropertyFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var property = _step.value;\n            if (typeof scopedRouter[property] === 'object') {\n                instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]) // makes sure query is not stateful\n                ;\n                continue;\n            }\n            instance[property] = scopedRouter[property];\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    // Events is a static property on the router, the router doesn't have to be initialized to use it\n    instance.events = _router.default.events;\n    coreMethodFields.forEach(function(field) {\n        instance[field] = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            var _scopedRouter;\n            return (_scopedRouter = scopedRouter)[field].apply(_scopedRouter, _toConsumableArray(args));\n        };\n    });\n    return instance;\n} //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGSCwwQ0FBeUMsQ0FBQztJQUN0Q0ksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxRQUFRLENBQWJBLEdBQUcsR0FBYSxDQUFDO1FBQ2IsTUFBTSxDQUFDQyxPQUFPLENBQUNDLE9BQU87SUFDMUIsQ0FBQztBQUNMLENBQUMsRUFBQztBQUNGUCw4Q0FBNkMsQ0FBQztJQUMxQ0ksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxRQUFRLENBQWJBLEdBQUcsR0FBYSxDQUFDO1FBQ2IsTUFBTSxDQUFDRyxXQUFXLENBQUNELE9BQU87SUFDOUIsQ0FBQztBQUNMLENBQUMsRUFBQztBQUNGTCxpQkFBaUIsR0FBR08sU0FBUztBQUM3QlAsb0JBQW9CLEdBQUdRLFlBQVk7QUFDbkNSLGdDQUFnQyxHQUFHUyx3QkFBd0I7QUFDM0RULGtCQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDeEIsR0FBRyxDQUFDVSxNQUFNLEdBQUdDLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLDRDQUFPO0FBQ25ELEdBQUcsQ0FBQ1IsT0FBTyxHQUFHTyxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyx5RkFBNkI7QUFDMUUsR0FBRyxDQUFDQyxjQUFjLEdBQUdELG1CQUFPLENBQUMsMkZBQThCO0FBQzNELEdBQUcsQ0FBQ0UsUUFBUSxHQUFHSCxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyxpRUFBaUI7QUFDL0QsR0FBRyxDQUFDTixXQUFXLEdBQUdLLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLHFFQUFlO1NBQ3ZERCxzQkFBc0IsQ0FBQ0ksR0FBRyxFQUFF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TSxDQUFDb0QsTUFBTSxDQUFDQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ0wsWUFBWSxDQUFDRSxRQUFRLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUVGLFlBQVksQ0FBQ0UsUUFBUSxFQUFHLENBQW1DOztnQkFFL0ksUUFBUTtZQUNaLENBQUM7WUFDREQsUUFBUSxDQUFDQyxRQUFRLElBQUlGLFlBQVksQ0FBQ0UsUUFBUTtRQUM5QyxDQUFDOztRQVBJLGlCQUFjO1FBQWQsY0FBYzs7O2lCQUFkLHlCQUFjLElBQWQsU0FBYztnQkFBZCxTQUFjOzs7Z0JBQWQsaUJBQWM7c0JBQWQsY0FBYzs7OztJQVFuQixFQUFpRztJQUNqR0QsUUFBUSxDQUFDdEIsTUFBTSxHQUFHdEIsT0FBTyxDQUFDQyxPQUFPLENBQUNxQixNQUFNO0lBQ3hDRCxnQkFBZ0IsQ0FBQ0UsT0FBTyxDQUFDLFFBQVEsQ0FBUEMsS0FBSyxFQUFHLENBQUM7UUFDL0JvQixRQUFRLENBQUNwQixLQUFLLElBQUksUUFBUSxHQUFHLENBQUM7NkNBQVJFLElBQUk7Z0JBQUpBLElBQUk7O2dCQUNmaUIsYUFBWTtZQUFuQixNQUFNLEVBQUNBLGFBQVksR0FBWkEsWUFBWSxFQUFDbkIsS0FBSyxFQUFsQm1CLEtBQTRCLENBQTVCQSxhQUFZLHFCQUFXakIsSUFBSTtRQUN0QyxDQUFDO0lBQ0wsQ0FBQztJQUNELE1BQU0sQ0FBQ2tCLFFBQVE7QUFDbkIsQ0FBQyxDQUVpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZXIuanM/MzFmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JvdXRlci5kZWZhdWx0O1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2l0aFJvdXRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3dpdGhSb3V0ZXIuZGVmYXVsdDtcbiAgICB9XG59KTtcbmV4cG9ydHMudXNlUm91dGVyID0gdXNlUm91dGVyO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXIgPSBjcmVhdGVSb3V0ZXI7XG5leHBvcnRzLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSA9IG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JvdXRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlclwiKSk7XG52YXIgX3JvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX3dpdGhSb3V0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dpdGgtcm91dGVyXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmNvbnN0IHNpbmdsZXRvblJvdXRlciA9IHtcbiAgICByb3V0ZXI6IG51bGwsXG4gICAgcmVhZHlDYWxsYmFja3M6IFtdLFxuICAgIHJlYWR5IChjYikge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXIpIHJldHVybiBjYigpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICAgJ3BhdGhuYW1lJyxcbiAgICAncm91dGUnLFxuICAgICdxdWVyeScsXG4gICAgJ2FzUGF0aCcsXG4gICAgJ2NvbXBvbmVudHMnLFxuICAgICdpc0ZhbGxiYWNrJyxcbiAgICAnYmFzZVBhdGgnLFxuICAgICdsb2NhbGUnLFxuICAgICdsb2NhbGVzJyxcbiAgICAnZGVmYXVsdExvY2FsZScsXG4gICAgJ2lzUmVhZHknLFxuICAgICdpc1ByZXZpZXcnLFxuICAgICdpc0xvY2FsZURvbWFpbicsXG4gICAgJ2RvbWFpbkxvY2FsZXMnLCBcbl07XG5jb25zdCByb3V0ZXJFdmVudHMgPSBbXG4gICAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAgICdiZWZvcmVIaXN0b3J5Q2hhbmdlJyxcbiAgICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAgICdoYXNoQ2hhbmdlU3RhcnQnLFxuICAgICdoYXNoQ2hhbmdlQ29tcGxldGUnLCBcbl07XG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAgICdwdXNoJyxcbiAgICAncmVwbGFjZScsXG4gICAgJ3JlbG9hZCcsXG4gICAgJ2JhY2snLFxuICAgICdwcmVmZXRjaCcsXG4gICAgJ2JlZm9yZVBvcFN0YXRlJywgXG5dO1xuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgICBnZXQgKCkge1xuICAgICAgICByZXR1cm4gX3JvdXRlci5kZWZhdWx0LmV2ZW50cztcbiAgICB9XG59KTtcbnVybFByb3BlcnR5RmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xuICAgIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm5cbiAgICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcbiAgICAvLyBwcm9wZXIgd2F5IHRvIGFjY2VzcyBpdFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKTtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbmNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpPT57XG4gICAgc2luZ2xldG9uUm91dGVyW2ZpZWxkXSA9ICguLi5hcmdzKT0+e1xuICAgICAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKTtcbiAgICAgICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncyk7XG4gICAgfTtcbn0pO1xucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50KT0+e1xuICAgIHNpbmdsZXRvblJvdXRlci5yZWFkeSgoKT0+e1xuICAgICAgICBfcm91dGVyLmRlZmF1bHQuZXZlbnRzLm9uKGV2ZW50LCAoLi4uYXJncyk9PntcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RmllbGQgPSBgb24ke2V2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7ZXZlbnQuc3Vic3RyaW5nKDEpfWA7XG4gICAgICAgICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyO1xuICAgICAgICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIpID8gYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YCA6IGVyciArICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG5mdW5jdGlvbiBnZXRSb3V0ZXIoKSB7XG4gICAgaWYgKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgKyAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgb24gdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7XG59XG52YXIgX2RlZmF1bHQgPSBzaW5nbGV0b25Sb3V0ZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbmZ1bmN0aW9uIHVzZVJvdXRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlciguLi5hcmdzKSB7XG4gICAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBfcm91dGVyLmRlZmF1bHQoLi4uYXJncyk7XG4gICAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goKGNiKT0+Y2IoKVxuICAgICk7XG4gICAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW107XG4gICAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7XG59XG5mdW5jdGlvbiBtYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyKSB7XG4gICAgY29uc3Qgc2NvcGVkUm91dGVyID0gcm91dGVyO1xuICAgIGNvbnN0IGluc3RhbmNlID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB1cmxQcm9wZXJ0eUZpZWxkcyl7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVkUm91dGVyW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IE9iamVjdC5hc3NpZ24oQXJyYXkuaXNBcnJheShzY29wZWRSb3V0ZXJbcHJvcGVydHldKSA/IFtdIDoge30sIHNjb3BlZFJvdXRlcltwcm9wZXJ0eV0pIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBzY29wZWRSb3V0ZXJbcHJvcGVydHldO1xuICAgIH1cbiAgICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gICAgaW5zdGFuY2UuZXZlbnRzID0gX3JvdXRlci5kZWZhdWx0LmV2ZW50cztcbiAgICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xuICAgICAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJncyk9PntcbiAgICAgICAgICAgIHJldHVybiBzY29wZWRSb3V0ZXJbZmllbGRdKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfcm91dGVyIiwiZGVmYXVsdCIsIl93aXRoUm91dGVyIiwidXNlUm91dGVyIiwiY3JlYXRlUm91dGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcm91dGVyQ29udGV4dCIsIl9pc0Vycm9yIiwib2JqIiwiX19lc01vZHVsZSIsInNpbmdsZXRvblJvdXRlciIsInJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJjYiIsInB1c2giLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJldmVudHMiLCJmb3JFYWNoIiwiZmllbGQiLCJnZXRSb3V0ZXIiLCJhcmdzIiwiZXZlbnQiLCJvbiIsImV2ZW50RmllbGQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0cmluZyIsIl9zaW5nbGV0b25Sb3V0ZXIiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJFcnJvciIsIl9kZWZhdWx0IiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJzY29wZWRSb3V0ZXIiLCJpbnN0YW5jZSIsInByb3BlcnR5IiwiYXNzaWduIiwiQXJyYXkiLCJpc0FycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = withRouter;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nfunction withRouter(ComposedComponent) {\n    var WithRouterWrapper = function WithRouterWrapper(props) {\n        _s();\n        return(/*#__PURE__*/ _react.default.createElement(ComposedComponent, Object.assign({\n            router: (0, _router).useRouter()\n        }, props)));\n    };\n    var _s = $RefreshSig$();\n    _s(WithRouterWrapper, \"CeygcqajjFExIxFEzW4x/gfWEGQ=\");\n    WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;\n    WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;\n    if (true) {\n        var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';\n        WithRouterWrapper.displayName = \"withRouter(\".concat(name, \")\");\n    }\n    return WithRouterWrapper;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n} //# sourceMappingURL=with-router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC93aXRoLXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0csVUFBVTtBQUM1QixHQUFHLENBQUNDLE1BQU0sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsNENBQU87QUFDbkQsR0FBRyxDQUFDQyxPQUFPLEdBQUdELG1CQUFPLENBQUMsMkRBQVU7U0FDdkJILFVBQVUsQ0FBQ0ssaUJBQWlCLEVBQUUsQ0FBQztRQUMzQkMsaUJBQWlCLEdBQTFCLFFBQVEsQ0FBQ0EsaUJBQWlCLENBQUNDLEtBQUssRUFBRSxDQUFDOztRQUMvQixNQUFNLENBQUMsRUFBYSxZQUFDTixNQUFNLENBQUNGLE9BQU8sQ0FBQ1MsYUFBYSxDQUFDSCxpQkFBaUIsRUFBRVYsTUFBTSxDQUFDYyxNQUFNLENBQUMsQ0FBQztZQUNoRkMsTUFBTSxHQUFHLENBQUMsRUFBRU4sT0FBTyxFQUFFTyxTQUFTO1FBQ2xDLENBQUMsRUFBRUosS0FBSztJQUNaLENBQUM7O09BSlFELGlCQUFpQjtJQUsxQkEsaUJBQWlCLENBQUNNLGVBQWUsR0FBR1AsaUJBQWlCLENBQUNPLGVBQWU7SUFDckVOLGlCQUFpQixDQUFDTyxtQkFBbUIsR0FBR1IsaUJBQWlCLENBQUNRLG1CQUFtQjtJQUM3RSxFQUFFLEVBZk4sSUFlNkMsRUFBRSxDQUFDO1FBQ3hDLEdBQUssQ0FBQ0MsSUFBSSxHQUFHVCxpQkFBaUIsQ0FBQ1UsV0FBVyxJQUFJVixpQkFBaUIsQ0FBQ1MsSUFBSSxJQUFJLENBQVM7UUFDakZSLGlCQUFpQixDQUFDUyxXQUFXLEdBQUksQ0FBVyxhQUFPLE1BQUMsQ0FBTkQsSUFBSSxFQUFDLENBQUM7SUFDeEQsQ0FBQztJQUNELE1BQU0sQ0FBQ1IsaUJBQWlCO0FBQzVCLENBQUM7U0FDUUosc0JBQXNCLENBQUNjLEdBQUcsRUFBRSxDQUFDO0lBQ2xDLE1BQU0sQ0FBQ0EsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsR0FBR0QsR0FBRyxHQUFHLENBQUM7UUFDbENqQixPQUFPLEVBQUVpQixHQUFHO0lBQ2hCLENBQUM7QUFDTCxDQUFDLENBRXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3dpdGgtcm91dGVyLmpzP2FjN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcm91dGVyID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xuZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb3NlZENvbXBvbmVudCkge1xuICAgIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzKSB7XG4gICAgICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29tcG9zZWRDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgcm91dGVyOiAoMCwgX3JvdXRlcikudXNlUm91dGVyKClcbiAgICAgICAgfSwgcHJvcHMpKSk7XG4gICAgfVxuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmdldEluaXRpYWxQcm9wcyA9IENvbXBvc2VkQ29tcG9uZW50LmdldEluaXRpYWxQcm9wcztcbiAgICBXaXRoUm91dGVyV3JhcHBlci5vcmlnR2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQub3JpZ0dldEluaXRpYWxQcm9wcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBuYW1lID0gQ29tcG9zZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9zZWRDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bic7XG4gICAgICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgO1xuICAgIH1cbiAgICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXI7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGgtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJ3aXRoUm91dGVyIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfcm91dGVyIiwiQ29tcG9zZWRDb21wb25lbnQiLCJXaXRoUm91dGVyV3JhcHBlciIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsImFzc2lnbiIsInJvdXRlciIsInVzZVJvdXRlciIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJuYW1lIiwiZGlzcGxheU5hbWUiLCJvYmoiLCJfX2VzTW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/with-router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.escapeStringRegexp = escapeStringRegexp;\nfunction escapeStringRegexp(str) {\n    return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZXNjYXBlLXJlZ2V4cC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFLGtCQUFrQjtTQUN0Q0Esa0JBQWtCLENBQUNDLEdBQUcsRUFBRSxDQUFDO0lBQzlCLE1BQU0sQ0FBQ0EsR0FBRyxDQUFDQyxPQUFPLHlCQUF5QixDQUFNO0FBQ3JELENBQUMsQ0FFd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2VzY2FwZS1yZWdleHAuanM/ZGJmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXNjYXBlU3RyaW5nUmVnZXhwID0gZXNjYXBlU3RyaW5nUmVnZXhwO1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nUmVnZXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS1yZWdleHAuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwic3RyIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/escape-regexp.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\"));\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports[\"default\"] = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _isError = _interopRequireWildcard(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../../../server/denormalize-page-path */ \"./node_modules/next/dist/server/denormalize-page-path.js\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = _interopRequireDefault1(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _resolveRewrites = _interopRequireDefault1(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _getMiddlewareRegex = __webpack_require__(/*! ./utils/get-middleware-regex */ \"./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js\");\nvar _formatUrl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {};\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nvar detectDomainLocale;\nif (false) {}\nvar basePath =  false || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    var pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(\"\".concat(prefix).concat(pathname)) + path.slice(pathname.length);\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var detectedDomain; } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (false) { var localeLower, pathLower, pathname; }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    var queryIndex = path.indexOf('?');\n    var hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    path = pathNoQueryHash(path);\n    return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = \"/\".concat(path);\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        var locationOrigin = (0, _utils).getLocationOrigin();\n        var resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    var interpolatedRoute = '';\n    var dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    var dynamicGroups = dynamicRegex.groups;\n    var dynamicMatches = (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    var params = Object.keys(dynamicGroups);\n    if (!params.every(function(param) {\n        var value = dynamicMatches[param] || '';\n        var _param = dynamicGroups[param], repeat = _param.repeat, optional = _param.optional;\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        var replaced = \"[\".concat(repeat ? '...' : '').concat(param, \"]\");\n        if (optional) {\n            replaced = \"\".concat(!value ? '/' : '', \"[\").concat(replaced, \"]\");\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        function(segment) {\n            return encodeURIComponent(segment);\n        }).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params: params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    var filteredQuery = {};\n    Object.keys(query).forEach(function(key) {\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    var base;\n    var urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    var urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    var urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n        var normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        var finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        var interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            var query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            var ref = interpolateAs(finalUrl.pathname, finalUrl.pathname, query), result = ref.result, params = ref.params;\n            if (result) {\n                interpolatedAs = (0, _formatUrl).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var ref = _slicedToArray(resolveHref(router, url, true), 2), resolvedHref = ref[0], resolvedAs = ref[1];\n    var origin = (0, _utils).getLocationOrigin();\n    var hrefHadOrigin = resolvedHref.startsWith(origin);\n    var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    var preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, opts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then(function(res) {\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1, opts);\n            }\n            if (res.status === 404) {\n                return res.json().then(function(data) {\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(\"Failed to load static props\");\n                });\n            }\n            throw new Error(\"Failed to load static props\");\n        }\n        return opts.text ? res.text() : res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n    var ref = new URL(dataHref, window.location.href), cacheKey = ref.href;\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n        text: text\n    }).catch(function(err) {\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then(function(data) {\n        if (!persistCache || \"development\" !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch(function(err) {\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname1, query1, as1, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview, isRsc = param.isRsc;\n        var _this = this;\n        _classCallCheck(this, Router);\n        // Static Data Cache\n        this.sdc = {};\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {};\n        // In-flight middleware preflight requests\n        this.sde = {};\n        this._idx = 0;\n        this.onPopState = function(e) {\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var pathname = _this.pathname, query = _this.query;\n                _this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query: query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, as = state.as, options = state.options, idx = state.idx;\n            if (false) { var v; }\n            _this._idx = idx;\n            var pathname2 = (0, _parseRelativeUrl).parseRelativeUrl(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && as === addBasePath(_this.asPath) && pathname2 === addBasePath(_this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        var route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== '/_error') {\n            this.components[route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!isRsc\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route: route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback: isFallback\n        };\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options1 = {\n                    locale: locale\n                };\n                options1._shouldResolveHref = as1 !== pathname1;\n                this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n                    pathname: addBasePath(pathname1),\n                    query: query1\n                }), (0, _utils).getURL(), options1);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _createClass(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('pushState', url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change('replaceState', url, as, options);\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var shouldResolveHref, nextState, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _shallow, shallow, _scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, ref1, ref2, resolvedAs, rewritesResult, effect, route, parsedAs1, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, ref12, ref22, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, ref3, newUrl, newAs, notFoundRoute, isValidShallowRoute, _scroll1, shouldScroll, resetScroll;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (isLocalURL(url)) {\n                                    _ctx.next = 3;\n                                    break;\n                                }\n                                window.location.href = url;\n                                return _ctx.abrupt(\"return\", false);\n                            case 3:\n                                shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n                                nextState = _objectSpread({}, _this.state);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                if (options._h) {\n                                    _this.isReady = true;\n                                }\n                                prevLocale = nextState.locale;\n                                if (true) {\n                                    _ctx.next = 19;\n                                    break;\n                                }\n                                nextState.locale = options.locale === false ? _this.defaultLocale : options.locale || nextState.locale;\n                                if (typeof options.locale === 'undefined') {\n                                    options.locale = nextState.locale;\n                                }\n                                parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n                                localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, _this.locales);\n                                if (localePathResult.detectedLocale) {\n                                    nextState.locale = localePathResult.detectedLocale;\n                                    parsedAs.pathname = addBasePath(parsedAs.pathname);\n                                    as = (0, _formatUrl).formatWithValidation(parsedAs);\n                                    url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, _this.locales).pathname);\n                                }\n                                didNavigate = false;\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                detectedDomain = detectDomainLocale(_this.domainLocales, undefined, nextState.locale);\n                                // we need to wrap this in the env check again since regenerator runtime\n                                // moves this on its own due to the return\n                                if (false) {}\n                                if (!didNavigate) {\n                                    _ctx.next = 19;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", new Promise(function() {}));\n                            case 19:\n                                if (!options._h) {\n                                    _this.isSsr = false;\n                                }\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark('routeChange');\n                                }\n                                _shallow = options.shallow, shallow = _shallow === void 0 ? false : _shallow, _scroll = options.scroll, scroll = _scroll === void 0 ? true : _scroll;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (_this._inFlightRoute) {\n                                    _this.abortComponentLoad(_this._inFlightRoute, routeProps);\n                                }\n                                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, _this.defaultLocale));\n                                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, nextState.locale);\n                                _this._inFlightRoute = as;\n                                localeChange = prevLocale !== nextState.locale;\n                                if (!(!options._h && _this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                                    _ctx.next = 36;\n                                    break;\n                                }\n                                nextState.asPath = cleanedAs;\n                                Router.events.emit('hashChangeStart', as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                _this.changeState(method, url, as, _objectSpread({}, options, {\n                                    scroll: false\n                                }));\n                                if (scroll) {\n                                    _this.scrollToHash(cleanedAs);\n                                }\n                                _this.set(nextState, _this.components[nextState.route], null);\n                                Router.events.emit('hashChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 36:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                ;\n                                _ctx.prev = 39;\n                                ;\n                                _ctx.t0 = _slicedToArray;\n                                _ctx.next = 44;\n                                return Promise.all([\n                                    _this.pageLoader.getPageList(),\n                                    (0, _routeLoader).getClientBuildManifest(),\n                                    _this.pageLoader.getMiddlewareList(), \n                                ]);\n                            case 44:\n                                _ctx.t1 = _ctx.sent;\n                                ref1 = (0, _ctx.t0)(_ctx.t1, 2);\n                                pages = ref1[0];\n                                ref2 = ref1[1], rewrites = ref2.__rewrites, ref2;\n                                ref1;\n                                _ctx.next = 55;\n                                break;\n                            case 51:\n                                _ctx.prev = 51;\n                                _ctx.t2 = _ctx[\"catch\"](39);\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 55:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = 'replaceState';\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n                                if (!(shouldResolveHref && pathname !== '/_error')) {\n                                    _ctx.next = 70;\n                                    break;\n                                }\n                                options._shouldResolveHref = true;\n                                if (true) {\n                                    _ctx.next = 69;\n                                    break;\n                                }\n                                rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(cleanedAs, nextState.locale)), pages, rewrites, query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (!rewritesResult.externalDest) {\n                                    _ctx.next = 65;\n                                    break;\n                                }\n                                location.href = as;\n                                return _ctx.abrupt(\"return\", true);\n                            case 65:\n                                resolvedAs = rewritesResult.asPath;\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = addBasePath(pathname);\n                                    url = (0, _formatUrl).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 70;\n                                break;\n                            case 69:\n                                {\n                                    parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                    if (parsed.pathname !== pathname) {\n                                        pathname = parsed.pathname;\n                                        parsed.pathname = addBasePath(pathname);\n                                        url = (0, _formatUrl).formatWithValidation(parsed);\n                                    }\n                                }\n                            case 70:\n                                if (isLocalURL(as)) {\n                                    _ctx.next = 75;\n                                    break;\n                                }\n                                if (false) {}\n                                throw new Error(\"Invalid href: \\\"\".concat(url, \"\\\" and as: \\\"\").concat(as, \"\\\", received relative href and external as\") + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                            case 73:\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", false);\n                            case 75:\n                                resolvedAs = delLocale(delBasePath(resolvedAs), nextState.locale);\n                                if (!((!options.shallow || options._h === 1) && (options._h !== 1 || (0, _isDynamic).isDynamicRoute((0, _normalizeTrailingSlash).removePathTrailingSlash(pathname))))) {\n                                    _ctx.next = 96;\n                                    break;\n                                }\n                                _ctx.next = 79;\n                                return _this._preflightRequest({\n                                    as: as,\n                                    cache: \"development\" === 'production',\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query,\n                                    locale: nextState.locale,\n                                    isPreview: nextState.isPreview\n                                });\n                            case 79:\n                                effect = _ctx.sent;\n                                if (!(effect.type === 'rewrite')) {\n                                    _ctx.next = 84;\n                                    break;\n                                }\n                                {\n                                    query = _objectSpread({}, query, effect.parsedAs.query);\n                                    resolvedAs = effect.asPath;\n                                    pathname = effect.resolvedHref;\n                                    parsed.pathname = effect.resolvedHref;\n                                    url = (0, _formatUrl).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 96;\n                                break;\n                            case 84:\n                                if (!(effect.type === 'redirect' && effect.newAs)) {\n                                    _ctx.next = 88;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", _this.change(method, effect.newUrl, effect.newAs, options));\n                            case 88:\n                                if (!(effect.type === 'redirect' && effect.destination)) {\n                                    _ctx.next = 93;\n                                    break;\n                                }\n                                window.location.href = effect.destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {}));\n                            case 93:\n                                if (!(effect.type === 'refresh' && as !== window.location.pathname)) {\n                                    _ctx.next = 96;\n                                    break;\n                                }\n                                window.location.href = as;\n                                return _ctx.abrupt(\"return\", new Promise(function() {}));\n                            case 96:\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                if (!(0, _isDynamic).isDynamicRoute(route)) {\n                                    _ctx.next = 112;\n                                    break;\n                                }\n                                parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                                asPathname = parsedAs1.pathname;\n                                routeRegex = (0, _routeRegex).getRouteRegex(route);\n                                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                                shouldInterpolate = route === asPathname;\n                                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n                                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                                    _ctx.next = 111;\n                                    break;\n                                }\n                                missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                    return !query[param];\n                                });\n                                if (!(missingParams.length > 0)) {\n                                    _ctx.next = 109;\n                                    break;\n                                }\n                                if (true) {\n                                    console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(', '), \" in the `href`'s `query`\"));\n                                }\n                                throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(', '), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));\n                            case 109:\n                                _ctx.next = 112;\n                                break;\n                            case 111:\n                                if (shouldInterpolate) {\n                                    as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs1, {\n                                        pathname: interpolatedAs.result,\n                                        query: omitParmsFromQuery(query, interpolatedAs.params)\n                                    }));\n                                } else {\n                                    // Merge params into `query`, overwriting any specified in search\n                                    Object.assign(query, routeMatch);\n                                }\n                            case 112:\n                                Router.events.emit('routeChangeStart', as, routeProps);\n                                _ctx.prev = 113;\n                                ;\n                                _ctx.next = 117;\n                                return _this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, nextState.locale, nextState.isPreview);\n                            case 117:\n                                routeInfo = _ctx.sent;\n                                error = routeInfo.error, props = routeInfo.props, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;\n                                if (!((__N_SSG || __N_SSP) && props)) {\n                                    _ctx.next = 144;\n                                    break;\n                                }\n                                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {\n                                    _ctx.next = 129;\n                                    break;\n                                }\n                                destination = props.pageProps.__N_REDIRECT;\n                                if (!(destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                                    _ctx.next = 127;\n                                    break;\n                                }\n                                parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                ref3 = prepareUrlAs(_this, destination, destination), newUrl = ref3.url, newAs = ref3.as;\n                                return _ctx.abrupt(\"return\", _this.change(method, newUrl, newAs, options));\n                            case 127:\n                                window.location.href = destination;\n                                return _ctx.abrupt(\"return\", new Promise(function() {}));\n                            case 129:\n                                nextState.isPreview = !!props.__N_PREVIEW;\n                                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {\n                                    _ctx.next = 144;\n                                    break;\n                                }\n                                ;\n                                _ctx.prev = 132;\n                                _ctx.next = 135;\n                                return _this.fetchComponent('/404');\n                            case 135:\n                                notFoundRoute = '/404';\n                                _ctx.next = 141;\n                                break;\n                            case 138:\n                                _ctx.prev = 138;\n                                _ctx.t3 = _ctx[\"catch\"](132);\n                                notFoundRoute = '/_error';\n                            case 141:\n                                _ctx.next = 143;\n                                return _this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                                    shallow: false\n                                }, nextState.locale, nextState.isPreview);\n                            case 143:\n                                routeInfo = _ctx.sent;\n                            case 144:\n                                Router.events.emit('beforeHistoryChange', as, routeProps);\n                                _this.changeState(method, url, as, options);\n                                if (options._h && pathname === '/_error' && ((ref12 = self.__NEXT_DATA__.props) === null || ref12 === void 0 ? void 0 : (ref22 = ref12.pageProps) === null || ref22 === void 0 ? void 0 : ref22.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && nextState.route === route;\n                                ;\n                                shouldScroll = (_scroll1 = options.scroll) !== null && _scroll1 !== void 0 ? _scroll1 : !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                _ctx.next = 153;\n                                return _this.set(_objectSpread({}, nextState, {\n                                    route: route,\n                                    pathname: pathname,\n                                    query: query,\n                                    asPath: cleanedAs,\n                                    isFallback: false\n                                }), routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(function(e) {\n                                    if (e.cancelled) error = error || e;\n                                    else throw e;\n                                });\n                            case 153:\n                                if (!error) {\n                                    _ctx.next = 156;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                                throw error;\n                            case 156:\n                                if (false) {}\n                                Router.events.emit('routeChangeComplete', as, routeProps);\n                                return _ctx.abrupt(\"return\", true);\n                            case 161:\n                                _ctx.prev = 161;\n                                _ctx.t4 = _ctx[\"catch\"](113);\n                                if (!((0, _isError).default(_ctx.t4) && _ctx.t4.cancelled)) {\n                                    _ctx.next = 165;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", false);\n                            case 165:\n                                throw _ctx.t4;\n                            case 166:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, null, [\n                        [\n                            39,\n                            51\n                        ],\n                        [\n                            113,\n                            161\n                        ],\n                        [\n                            132,\n                            138\n                        ]\n                    ]);\n                }))();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as) {\n                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (true) {\n                    if (typeof window.history === 'undefined') {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === 'undefined') {\n                        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                        return;\n                    }\n                }\n                if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    '', as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var Component, styleSheets, props, ref, routeInfo;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                if (!err.cancelled) {\n                                    _ctx.next = 2;\n                                    break;\n                                }\n                                // bubble up cancellation errors\n                                throw err;\n                            case 2:\n                                if (!((0, _routeLoader).isAssetError(err) || loadErrorFail)) {\n                                    _ctx.next = 6;\n                                    break;\n                                }\n                                Router.events.emit('routeChangeError', err, as, routeProps);\n                                // If we can't load the page it could be one of following reasons\n                                //  1. Page doesn't exists\n                                //  2. Page does exist in a different zone\n                                //  3. Internal error while loading the page\n                                // So, doing a hard reload is the proper way to deal with this.\n                                window.location.href = as;\n                                // Changing the URL doesn't block executing the current code path.\n                                // So let's throw a cancellation error stop the routing logic.\n                                throw buildCancellationError();\n                            case 6:\n                                _ctx.prev = 6;\n                                ;\n                                ;\n                                ;\n                                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                ;\n                                _ctx.next = 14;\n                                return _this.fetchComponent('/_error');\n                            case 14:\n                                ref = _ctx.sent;\n                                Component = ref.page;\n                                styleSheets = ref.styleSheets;\n                                ref;\n                            case 18:\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (routeInfo.props) {\n                                    _ctx.next = 30;\n                                    break;\n                                }\n                                _ctx.prev = 20;\n                                _ctx.next = 23;\n                                return _this.getInitialProps(Component, {\n                                    err: err,\n                                    pathname: pathname,\n                                    query: query\n                                });\n                            case 23:\n                                routeInfo.props = _ctx.sent;\n                                _ctx.next = 30;\n                                break;\n                            case 26:\n                                _ctx.prev = 26;\n                                _ctx.t0 = _ctx[\"catch\"](20);\n                                console.error('Error in error page `getInitialProps`: ', _ctx.t0);\n                                routeInfo.props = {};\n                            case 30:\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 33:\n                                _ctx.prev = 33;\n                                _ctx.t1 = _ctx[\"catch\"](6);\n                                return _ctx.abrupt(\"return\", _this.handleRouteInfoError((0, _isError).default(_ctx.t1) ? _ctx.t1 : new Error(_ctx.t1 + ''), pathname, query, as, routeProps, true));\n                            case 36:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, null, [\n                        [\n                            6,\n                            33\n                        ],\n                        [\n                            20,\n                            26\n                        ]\n                    ]);\n                }))();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, locale, isPreview) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, __N_RSC, isValidElementType, dataHref, props, ref, fresh, data;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _ctx.prev = 0;\n                                existingRouteInfo = _this.components[route];\n                                if (!(routeProps.shallow && existingRouteInfo && _this.route === route)) {\n                                    _ctx.next = 4;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", existingRouteInfo);\n                            case 4:\n                                cachedRouteInfo = undefined;\n                                // can only use non-initial route info\n                                // cannot reuse route info in development since it can change after HMR\n                                if (false) {}\n                                _ctx.t0 = cachedRouteInfo;\n                                if (_ctx.t0) {\n                                    _ctx.next = 11;\n                                    break;\n                                }\n                                _ctx.next = 10;\n                                return _this.fetchComponent(route).then(function(res) {\n                                    return {\n                                        Component: res.page,\n                                        styleSheets: res.styleSheets,\n                                        __N_SSG: res.mod.__N_SSG,\n                                        __N_SSP: res.mod.__N_SSP,\n                                        __N_RSC: !!res.mod.__next_rsc__\n                                    };\n                                });\n                            case 10:\n                                _ctx.t0 = _ctx.sent;\n                            case 11:\n                                routeInfo = _ctx.t0;\n                                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP, __N_RSC = routeInfo.__N_RSC;\n                                if (false) {}\n                                isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                                if (isValidElementType(Component)) {\n                                    _ctx.next = 17;\n                                    break;\n                                }\n                                throw new Error(\"The default export is not a React Component in page: \\\"\".concat(pathname, \"\\\"\"));\n                            case 17:\n                                ;\n                                if (__N_SSG || __N_SSP || __N_RSC) {\n                                    dataHref = _this.pageLoader.getDataHref({\n                                        href: (0, _formatUrl).formatWithValidation({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        asPath: resolvedAs,\n                                        ssg: __N_SSG,\n                                        rsc: __N_RSC,\n                                        locale: locale\n                                    });\n                                }\n                                _ctx.next = 21;\n                                return _this._getData(function() {\n                                    return __N_SSG || __N_SSP ? fetchNextData(dataHref, _this.isSsr, false, __N_SSG ? _this.sdc : _this.sdr, !!__N_SSG && !isPreview) : _this.getInitialProps(Component, {\n                                        pathname: pathname,\n                                        query: query,\n                                        asPath: as,\n                                        locale: locale,\n                                        locales: _this.locales,\n                                        defaultLocale: _this.defaultLocale\n                                    });\n                                });\n                            case 21:\n                                props = _ctx.sent;\n                                if (!__N_RSC) {\n                                    _ctx.next = 29;\n                                    break;\n                                }\n                                _ctx.next = 25;\n                                return _this._getData(function() {\n                                    return _this._getFlightData(dataHref);\n                                });\n                            case 25:\n                                ref = _ctx.sent;\n                                fresh = ref.fresh;\n                                data = ref.data;\n                                props.pageProps = Object.assign(props.pageProps, {\n                                    __flight_serialized__: data,\n                                    __flight_fresh__: fresh\n                                });\n                            case 29:\n                                routeInfo.props = props;\n                                _this.components[route] = routeInfo;\n                                return _ctx.abrupt(\"return\", routeInfo);\n                            case 34:\n                                _ctx.prev = 34;\n                                _ctx.t1 = _ctx[\"catch\"](0);\n                                return _ctx.abrupt(\"return\", _this.handleRouteInfoError((0, _isError).getProperError(_ctx.t1), pathname, query, as, routeProps));\n                            case 37:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, null, [\n                        [\n                            0,\n                            34\n                        ]\n                    ]);\n                }))();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(state, data, resetScroll) {\n                this.state = state;\n                return this.sub(data, this.components['/_app'].Component, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var ref = _slicedToArray(this.asPath.split('#'), 2), oldUrlNoHash = ref[0], oldHash = ref[1];\n                var ref4 = _slicedToArray(as.split('#'), 2), newUrlNoHash = ref4[0], newHash = ref4[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var ref = _slicedToArray(as.split('#'), 2), tmp = ref[1], hash = tmp === void 0 ? '' : tmp;\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === '' || hash === 'top') {\n                    window.scrollTo(0, 0);\n                    return;\n                }\n                // First we check if the element by id is found\n                var idEl = document.getElementById(hash);\n                if (idEl) {\n                    idEl.scrollIntoView();\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(hash)[0];\n                if (nameEl) {\n                    nameEl.scrollIntoView();\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url) {\n                var asPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : url, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var parsed, pathname, query, parsedAs, localePathResult, pages, resolvedAs, rewrites, ref, rewritesResult, effects, route;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                if (false) {}\n                                _ctx.next = 5;\n                                return _this.pageLoader.getPageList();\n                            case 5:\n                                pages = _ctx.sent;\n                                resolvedAs = asPath;\n                                if (true) {\n                                    _ctx.next = 22;\n                                    break;\n                                }\n                                ;\n                                ;\n                                _ctx.next = 12;\n                                return (0, _routeLoader).getClientBuildManifest();\n                            case 12:\n                                ref = _ctx.sent;\n                                rewrites = ref.__rewrites;\n                                ref;\n                                rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, _this.locale)), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (!rewritesResult.externalDest) {\n                                    _ctx.next = 18;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\");\n                            case 18:\n                                resolvedAs = delLocale(delBasePath(rewritesResult.asPath), _this.locale);\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    url = (0, _formatUrl).formatWithValidation(parsed);\n                                }\n                                _ctx.next = 23;\n                                break;\n                            case 22:\n                                {\n                                    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                    if (parsed.pathname !== pathname) {\n                                        pathname = parsed.pathname;\n                                        parsed.pathname = pathname;\n                                        url = (0, _formatUrl).formatWithValidation(parsed);\n                                    }\n                                }\n                            case 23:\n                                if (false) {}\n                                return _ctx.abrupt(\"return\");\n                            case 25:\n                                _ctx.next = 27;\n                                return _this._preflightRequest({\n                                    as: addBasePath(asPath),\n                                    cache: true,\n                                    pages: pages,\n                                    pathname: pathname,\n                                    query: query,\n                                    locale: _this.locale,\n                                    isPreview: _this.isPreview\n                                });\n                            case 27:\n                                effects = _ctx.sent;\n                                if (effects.type === 'rewrite') {\n                                    parsed.pathname = effects.resolvedHref;\n                                    pathname = effects.resolvedHref;\n                                    query = _objectSpread({}, query, effects.parsedAs.query);\n                                    resolvedAs = effects.asPath;\n                                    url = (0, _formatUrl).formatWithValidation(parsed);\n                                }\n                                route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n                                _ctx.next = 32;\n                                return Promise.all([\n                                    _this.pageLoader._isSsg(route).then(function(isSsg) {\n                                        return isSsg ? fetchNextData(_this.pageLoader.getDataHref({\n                                            href: url,\n                                            asPath: resolvedAs,\n                                            ssg: true,\n                                            locale: typeof options.locale !== 'undefined' ? options.locale : _this.locale\n                                        }), false, false, _this.sdc, true) : false;\n                                    }),\n                                    _this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n                                ]);\n                            case 32:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee);\n                }))();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var cancelled, cancel, handleCancelled, componentResult;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                cancelled = false;\n                                cancel = _this.clc = function() {\n                                    cancelled = true;\n                                };\n                                handleCancelled = function() {\n                                    if (cancelled) {\n                                        var error = new Error(\"Abort fetching component for route: \\\"\".concat(route, \"\\\"\"));\n                                        error.cancelled = true;\n                                        throw error;\n                                    }\n                                    if (cancel === _this.clc) {\n                                        _this.clc = null;\n                                    }\n                                };\n                                _ctx.prev = 3;\n                                _ctx.next = 6;\n                                return _this.pageLoader.loadPage(route);\n                            case 6:\n                                componentResult = _ctx.sent;\n                                handleCancelled();\n                                return _ctx.abrupt(\"return\", componentResult);\n                            case 11:\n                                _ctx.prev = 11;\n                                _ctx.t0 = _ctx[\"catch\"](3);\n                                handleCancelled();\n                                throw _ctx.t0;\n                            case 15:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, null, [\n                        [\n                            3,\n                            11\n                        ]\n                    ]);\n                }))();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error('Loading initial props cancelled');\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                // Do not cache RSC flight response since it's not a static resource\n                return fetchNextData(dataHref, true, true, this.sdc, false).then(function(serialized) {\n                    return {\n                        fresh: true,\n                        data: serialized\n                    };\n                });\n            }\n        },\n        {\n            key: \"_preflightRequest\",\n            value: function _preflightRequest(options) {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var asPathname, cleanedAs, fns, requiresPreflight, preflight, parsed, fsPathname, matchedPage, resolvedHref, cleanRedirect, ref, newUrl, newAs;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                asPathname = pathNoQueryHash(options.as);\n                                cleanedAs = delLocale(hasBasePath(asPathname) ? delBasePath(asPathname) : asPathname, options.locale);\n                                _ctx.next = 4;\n                                return _this.pageLoader.getMiddlewareList();\n                            case 4:\n                                fns = _ctx.sent;\n                                requiresPreflight = fns.some(function(param) {\n                                    var _param = _slicedToArray(param, 2), middleware = _param[0], isSSR = _param[1];\n                                    return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n                                });\n                                if (requiresPreflight) {\n                                    _ctx.next = 8;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 8:\n                                ;\n                                _ctx.prev = 9;\n                                _ctx.next = 12;\n                                return _this._getPreflightData({\n                                    preflightHref: options.as,\n                                    shouldCache: options.cache,\n                                    isPreview: options.isPreview\n                                });\n                            case 12:\n                                preflight = _ctx.sent;\n                                _ctx.next = 18;\n                                break;\n                            case 15:\n                                _ctx.prev = 15;\n                                _ctx.t0 = _ctx[\"catch\"](9);\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    destination: options.as\n                                });\n                            case 18:\n                                if (!preflight.rewrite) {\n                                    _ctx.next = 27;\n                                    break;\n                                }\n                                if (preflight.rewrite.startsWith('/')) {\n                                    _ctx.next = 21;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    destination: options.as\n                                });\n                            case 21:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, _this.locales).pathname);\n                                fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n                                ;\n                                ;\n                                if (options.pages.includes(fsPathname)) {\n                                    matchedPage = true;\n                                    resolvedHref = fsPathname;\n                                } else {\n                                    resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                                    if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                                        matchedPage = true;\n                                    }\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'rewrite',\n                                    asPath: parsed.pathname,\n                                    parsedAs: parsed,\n                                    matchedPage: matchedPage,\n                                    resolvedHref: resolvedHref\n                                });\n                            case 27:\n                                if (!preflight.redirect) {\n                                    _ctx.next = 33;\n                                    break;\n                                }\n                                if (!preflight.redirect.startsWith('/')) {\n                                    _ctx.next = 32;\n                                    break;\n                                }\n                                cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, _this.locales).pathname);\n                                ref = prepareUrlAs(_this, cleanRedirect, cleanRedirect), newUrl = ref.url, newAs = ref.as;\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    newUrl: newUrl,\n                                    newAs: newAs\n                                });\n                            case 32:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'redirect',\n                                    destination: preflight.redirect\n                                });\n                            case 33:\n                                if (!(preflight.refresh && !preflight.ssr)) {\n                                    _ctx.next = 35;\n                                    break;\n                                }\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'refresh'\n                                });\n                            case 35:\n                                return _ctx.abrupt(\"return\", {\n                                    type: 'next'\n                                });\n                            case 36:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee, null, [\n                        [\n                            9,\n                            15\n                        ]\n                    ]);\n                }))();\n            }\n        },\n        {\n            key: \"_getPreflightData\",\n            value: function _getPreflightData(params) {\n                var _this = this;\n                var preflightHref = params.preflightHref, _shouldCache = params.shouldCache, shouldCache = _shouldCache === void 0 ? false : _shouldCache, isPreview = params.isPreview;\n                var ref = new URL(preflightHref, window.location.href), cacheKey = ref.href;\n                if (false) {}\n                return fetch(preflightHref, {\n                    method: 'HEAD',\n                    credentials: 'same-origin',\n                    headers: {\n                        'x-middleware-preflight': '1'\n                    }\n                }).then(function(res) {\n                    if (!res.ok) {\n                        throw new Error(\"Failed to preflight request\");\n                    }\n                    return {\n                        cache: res.headers.get('x-middleware-cache'),\n                        redirect: res.headers.get('Location'),\n                        refresh: res.headers.has('x-middleware-refresh'),\n                        rewrite: res.headers.get('x-middleware-rewrite'),\n                        ssr: !!res.headers.get('x-middleware-ssr')\n                    };\n                }).then(function(data) {\n                    if (shouldCache && data.cache !== 'no-cache') {\n                        _this.sde[cacheKey] = data;\n                    }\n                    return data;\n                }).catch(function(err) {\n                    delete _this.sde[cacheKey];\n                    throw err;\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var ref = this.components['/_app'], App = ref.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils).loadGetInitialProps(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"abortComponentLoad\",\n            value: function abortComponentLoad(as, routeProps) {\n                if (this.clc) {\n                    Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n                    this.clc();\n                    this.clc = null;\n                }\n            }\n        },\n        {\n            key: \"route\",\n            get: function get() {\n                return this.state.route;\n            }\n        },\n        {\n            key: \"pathname\",\n            get: function get() {\n                return this.state.pathname;\n            }\n        },\n        {\n            key: \"query\",\n            get: function get() {\n                return this.state.query;\n            }\n        },\n        {\n            key: \"asPath\",\n            get: function get() {\n                return this.state.asPath;\n            }\n        },\n        {\n            key: \"locale\",\n            get: function get() {\n                return this.state.locale;\n            }\n        },\n        {\n            key: \"isFallback\",\n            get: function get() {\n                return this.state.isFallback;\n            }\n        },\n        {\n            key: \"isPreview\",\n            get: function get() {\n                return this.state.isPreview;\n            }\n        }\n    ]);\n    return Router;\n}();\nexports[\"default\"] = Router;\nRouter.events = (0, _mitt).default(); //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0UsZUFBZTtBQUN6Q0YsaUJBQWlCLEdBQUdHLFNBQVM7QUFDN0JILGlCQUFpQixHQUFHSSxTQUFTO0FBQzdCSixtQkFBbUIsR0FBR0ssV0FBVztBQUNqQ0wsbUJBQW1CLEdBQUdNLFdBQVc7QUFDakNOLG1CQUFtQixHQUFHTyxXQUFXO0FBQ2pDUCxrQkFBa0IsR0FBR1EsVUFBVTtBQUMvQlIscUJBQXFCLEdBQUdTLGFBQWE7QUFDckNULG1CQUFtQixHQUFHVSxXQUFXO0FBQ2pDVixrQkFBZSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3hCLEdBQUcsQ0FBQ1ksdUJBQXVCLEdBQUdDLG1CQUFPLENBQUMsNkdBQTBDO0FBQ2hGLEdBQUcsQ0FBQ0MsWUFBWSxHQUFHRCxtQkFBTyxDQUFDLHFGQUE4QjtBQUN6RCxHQUFHLENBQUNFLFFBQVEsR0FBR0MsdUJBQXVCLENBQUNILG1CQUFPLENBQUMsdUVBQXVCO0FBQ3RFLEdBQUcsQ0FBQ0ksb0JBQW9CLEdBQUdKLG1CQUFPLENBQUMsdUdBQXVDO0FBQzFFLEdBQUcsQ0FBQ0ssb0JBQW9CLEdBQUdMLG1CQUFPLENBQUMsd0dBQStCO0FBQ2xFLEdBQUcsQ0FBQ00sS0FBSyxHQUFHQyx1QkFBc0IsQ0FBQ1AsbUJBQU8sQ0FBQyw0REFBUztBQUNwRCxHQUFHLENBQUNRLE1BQU0sR0FBR1IsbUJBQU8sQ0FBQyw4REFBVTtBQUMvQixHQUFHLENBQUNTLFVBQVUsR0FBR1QsbUJBQU8sQ0FBQywwRkFBb0I7QUFDN0MsR0FBRyxDQUFDVSxpQkFBaUIsR0FBR1YsbUJBQU8sQ0FBQywwR0FBNEI7QUFDNUQsR0FBRyxDQUFDVyxZQUFZLEdBQUdYLG1CQUFPLENBQUMsNEZBQXFCO0FBQ2hELEdBQUcsQ0FBQ1ksZ0JBQWdCLEdBQUdMLHVCQUFzQixDQUFDUCxtQkFBTyxDQUFDLHVDQUEwQjtBQUNoRixHQUFHLENBQUNhLGFBQWEsR0FBR2IsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDbkQsR0FBRyxDQUFDYyxXQUFXLEdBQUdkLG1CQUFPLENBQUMsNEZBQXFCO0FBQy9DLEdBQUcsQ0FBQ2UsbUJBQW1CLEdBQUdmLG1CQUFPLENBQUMsOEdBQThCO0FBQ2hFLEdBQUcsQ0FBQ2dCLFVBQVUsR0FBR2hCLG1CQUFPLENBQUMsMEZBQW9CO1NBQ3BDTyx1QkFBc0IsQ0FBQ1UsR0FBRyxFQUFFLENBQUM7SUFDbEMsTUFBTSxDQUFDQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHRCxHQUFHLEdBQUcsQ0FBQztRQUNsQ25CLE9BQU8sRUFBRW1CLEdBQUc7SUFDaEIsQ0FBQztBQUNMLENBQUM7U0FDUWQsdUJBQXVCLENBQUNjLEdBQUcsRUFBRSxDQUFDO0lBQ25DLEVBQUUsRUFBRUEsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsRUFBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBQ0QsR0FBRztJQUNkLENBQUMsTUFBTSxDQUFDO1FBQ0osR0FBRyxDQUFDRSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsRUFBRSxFQUFFRixHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7WUFDZCxHQUFHLENBQUMsR0FBRyxDQUFDRyxHQUFHLElBQUlILEdBQUcsQ0FBQyxDQUFDO2dCQUNoQixFQUFFLEVBQUVoQyxNQUFNLENBQUNvQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTixHQUFHLEVBQUVHLEdBQUcsR0FBRyxDQUFDO29CQUNqRCxHQUFHLENBQUNJLElBQUksR0FBR3ZDLE1BQU0sQ0FBQ0MsY0FBYyxJQUFJRCxNQUFNLENBQUN3Qyx3QkFBd0IsR0FBR3hDLE1BQU0sQ0FBQ3dDLHdCQUF3QixDQUFDUixHQUFHLEVBQUVHLEdBQUcsSUFBSSxDQUFDLENBQUM7b0JBQ3BILEVBQUUsRUFBRUksSUFBSSxDQUFDRSxHQUFHLElBQUlGLElBQUksQ0FBQ0csR0FBRyxFQUFFLENBQUM7d0JBQ3ZCMUMsTUFBTSxDQUFDQyxjQUFjLENBQUNpQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUksSUFBSTtvQkFDM0MsQ0FBQyxNQUFNLENBQUM7d0JBQ0pMLE1BQU0sQ0FBQ0MsR0FBRyxJQUFJSCxHQUFHLENBQUNHLEdBQUc7b0JBQ3pCLENBQUM7Z0JBQ0wsQ0FBQztZQUNMLENBQUM7UUFDTCxDQUFDO1FBQ0RELE1BQU0sQ0FBQ3JCLE9BQU8sR0FBR21CLEdBQUc7UUFDcEIsTUFBTSxDQUFDRSxNQUFNO0lBQ2pCLENBQUM7QUFDTCxDQUFDO0FBQ0QsR0FBRyxDQUFDUyxrQkFBa0I7QUFDdEIsRUFBRSxFQUFFQyxLQUErQixFQUFFLEVBRXBDO0FBQ0QsR0FBSyxDQUFDRyxRQUFRLEdBQUdILE1BQWtDLElBQUksQ0FBRTtTQUNoREssc0JBQXNCLEdBQUcsQ0FBQztJQUMvQixNQUFNLENBQUNqRCxNQUFNLENBQUNrRCxNQUFNLENBQUMsR0FBRyxDQUFDQyxLQUFLLENBQUMsQ0FBaUIsbUJBQUcsQ0FBQztRQUNoREMsU0FBUyxFQUFFLElBQUk7SUFDbkIsQ0FBQztBQUNMLENBQUM7U0FDUUMsYUFBYSxDQUFDQyxJQUFJLEVBQUVDLE1BQU0sRUFBRSxDQUFDO0lBQ2xDLEVBQUUsR0FBR0QsSUFBSSxDQUFDRSxVQUFVLENBQUMsQ0FBRyxRQUFNRCxNQUFNLEVBQUUsQ0FBQztRQUNuQyxNQUFNLENBQUNELElBQUk7SUFDZixDQUFDO0lBQ0QsR0FBSyxDQUFDRyxRQUFRLEdBQUdDLGVBQWUsQ0FBQ0osSUFBSTtJQUNyQyxNQUFNLEVBQUUsQ0FBQyxFQUFFeEMsdUJBQXVCLEVBQUU2QywwQkFBMEIsQ0FBRSxHQUFXRixNQUFRLENBQWpCRixNQUFNLEVBQVksT0FBVEUsUUFBUSxLQUFNSCxJQUFJLENBQUNNLEtBQUssQ0FBQ0gsUUFBUSxDQUFDSSxNQUFNO0FBQ3ZILENBQUM7U0FDUXpELGVBQWUsQ0FBQ2tELElBQUksRUFBRVEsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLGFBQWEsRUFBRSxDQUFDO0lBQzVELEVBQUUsRUFBRXBCLEtBQStCLEVBQUUsdUJBT3BDLE1BQU0sQ0FBQztRQUNKLE1BQU0sQ0FBQyxLQUFLO0lBQ2hCLENBQUM7QUFDTCxDQUFDO1NBQ1F2QyxTQUFTLENBQUNpRCxJQUFJLEVBQUVRLE1BQU0sRUFBRVMsYUFBYSxFQUFFLENBQUM7SUFDN0MsRUFBRSxFQUFFM0IsS0FBK0IsRUFBRSx5Q0FLcEM7SUFDRCxNQUFNLENBQUNVLElBQUk7QUFDZixDQUFDO1NBQ1FoRCxTQUFTLENBQUNnRCxJQUFJLEVBQUVRLE1BQU0sRUFBRSxDQUFDO0lBQzlCLEVBQUUsRUFBRWxCLEtBQStCLEVBQUUseUNBS3BDO0lBQ0QsTUFBTSxDQUFDVSxJQUFJO0FBQ2YsQ0FBQztTQUNRSSxlQUFlLENBQUNKLElBQUksRUFBRSxDQUFDO0lBQzVCLEdBQUssQ0FBQ3FCLFVBQVUsR0FBR3JCLElBQUksQ0FBQ3NCLE9BQU8sQ0FBQyxDQUFHO0lBQ25DLEdBQUssQ0FBQ0MsU0FBUyxHQUFHdkIsSUFBSSxDQUFDc0IsT0FBTyxDQUFDLENBQUc7SUFDbEMsRUFBRSxFQUFFRCxVQUFVLElBQUksQ0FBQyxJQUFJRSxTQUFTLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDcEN2QixJQUFJLEdBQUdBLElBQUksQ0FBQ3dCLFNBQVMsQ0FBQyxDQUFDLEVBQUVILFVBQVUsSUFBSSxDQUFDLEdBQUdBLFVBQVUsR0FBR0UsU0FBUztJQUNyRSxDQUFDO0lBQ0QsTUFBTSxDQUFDdkIsSUFBSTtBQUNmLENBQUM7U0FDUS9DLFdBQVcsQ0FBQytDLElBQUksRUFBRSxDQUFDO0lBQ3hCQSxJQUFJLEdBQUdJLGVBQWUsQ0FBQ0osSUFBSTtJQUMzQixNQUFNLENBQUNBLElBQUksS0FBS1AsUUFBUSxJQUFJTyxJQUFJLENBQUNFLFVBQVUsQ0FBQ1QsUUFBUSxHQUFHLENBQUc7QUFDOUQsQ0FBQztTQUNRdkMsV0FBVyxDQUFDOEMsSUFBSSxFQUFFLENBQUM7SUFDeEIsRUFBNEM7SUFDNUMsTUFBTSxDQUFDRCxhQUFhLENBQUNDLElBQUksRUFBRVAsUUFBUTtBQUN2QyxDQUFDO1NBQ1F0QyxXQUFXLENBQUM2QyxJQUFJLEVBQUUsQ0FBQztJQUN4QkEsSUFBSSxHQUFHQSxJQUFJLENBQUNNLEtBQUssQ0FBQ2IsUUFBUSxDQUFDYyxNQUFNO0lBQ2pDLEVBQUUsR0FBR1AsSUFBSSxDQUFDRSxVQUFVLENBQUMsQ0FBRyxLQUFHRixJQUFJLEdBQUksQ0FBQyxHQUFPLE9BQUxBLElBQUk7SUFDMUMsTUFBTSxDQUFDQSxJQUFJO0FBQ2YsQ0FBQztTQUNRNUMsVUFBVSxDQUFDcUUsR0FBRyxFQUFFLENBQUM7SUFDdEIsRUFBZ0U7SUFDaEUsRUFBRSxFQUFFQSxHQUFHLENBQUN2QixVQUFVLENBQUMsQ0FBRyxPQUFLdUIsR0FBRyxDQUFDdkIsVUFBVSxDQUFDLENBQUcsT0FBS3VCLEdBQUcsQ0FBQ3ZCLFVBQVUsQ0FBQyxDQUFHLEtBQUcsTUFBTSxDQUFDLElBQUk7SUFDbEYsR0FBRyxDQUFDLENBQUM7UUFDRCxFQUE0RDtRQUM1RCxHQUFLLENBQUN3QixjQUFjLElBQUksQ0FBQyxFQUFFekQsTUFBTSxFQUFFMEQsaUJBQWlCO1FBQ3BELEdBQUssQ0FBQ0MsUUFBUSxHQUFHLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHLEVBQUVDLGNBQWM7UUFDNUMsTUFBTSxDQUFDRSxRQUFRLENBQUNFLE1BQU0sS0FBS0osY0FBYyxJQUFJekUsV0FBVyxDQUFDMkUsUUFBUSxDQUFDekIsUUFBUTtJQUM5RSxDQUFDLENBQUMsS0FBSyxFQUFFNEIsQ0FBQyxFQUFFLENBQUM7UUFDVCxNQUFNLENBQUMsS0FBSztJQUNoQixDQUFDO0FBQ0wsQ0FBQztTQUNRMUUsYUFBYSxDQUFDMkUsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRSxDQUFDO0lBQzlDLEdBQUcsQ0FBQ0MsaUJBQWlCLEdBQUcsQ0FBRTtJQUMxQixHQUFLLENBQUNDLFlBQVksSUFBSSxDQUFDLEVBQUU3RCxXQUFXLEVBQUU4RCxhQUFhLENBQUNMLEtBQUs7SUFDekQsR0FBSyxDQUFDTSxhQUFhLEdBQUdGLFlBQVksQ0FBQ0csTUFBTTtJQUN6QyxHQUFLLENBQUNDLGNBQWMsSUFDbkJQLFVBQVUsS0FBS0QsS0FBSyxJQUFJLENBQUMsRUFBRTFELGFBQWEsRUFBRW1FLGVBQWUsQ0FBQ0wsWUFBWSxFQUFFSCxVQUFVLElBQUksQ0FBRSxNQUN6RixFQUFzRTtJQUN0RUMsS0FBSztJQUNMQyxpQkFBaUIsR0FBR0gsS0FBSztJQUN6QixHQUFLLENBQUNVLE1BQU0sR0FBR2hHLE1BQU0sQ0FBQ2lHLElBQUksQ0FBQ0wsYUFBYTtJQUN4QyxFQUFFLEdBQUdJLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsS0FBSyxFQUFHLENBQUM7UUFDeEIsR0FBRyxDQUFDaEcsS0FBSyxHQUFHMkYsY0FBYyxDQUFDSyxLQUFLLEtBQUssQ0FBRTtRQUN2QyxHQUFLLENBQTBCUCxNQUFvQixHQUFwQkEsYUFBYSxDQUFDTyxLQUFLLEdBQTFDQyxNQUFNLEdBQWlCUixNQUFvQixDQUEzQ1EsTUFBTSxFQUFHQyxRQUFRLEdBQU1ULE1BQW9CLENBQWxDUyxRQUFRO1FBQ3pCLEVBQWlDO1FBQ2pDLEVBQTBEO1FBQzFELEdBQUcsQ0FBQ0MsUUFBUSxHQUFJLENBQUMsR0FBd0JILE1BQUssQ0FBM0JDLE1BQU0sR0FBRyxDQUFLLE9BQUcsQ0FBRSxHQUFTLE1BQUMsQ0FBUEQsS0FBSyxFQUFDLENBQUM7UUFDaEQsRUFBRSxFQUFFRSxRQUFRLEVBQUUsQ0FBQztZQUNYQyxRQUFRLEdBQUksR0FBdUJBLE1BQVEsRUFBNUJuRyxLQUFLLEdBQUcsQ0FBRyxLQUFHLENBQUUsR0FBQyxDQUFDLElBQVcsTUFBQyxDQUFWbUcsUUFBUSxFQUFDLENBQUM7UUFDakQsQ0FBQztRQUNELEVBQUUsRUFBRUYsTUFBTSxLQUFLRyxLQUFLLENBQUNDLE9BQU8sQ0FBQ3JHLEtBQUssR0FBR0EsS0FBSyxHQUFHLENBQUM7WUFDMUNBLEtBQUs7UUFDVCxDQUFDO1FBQ0QsTUFBTSxFQUFFa0csUUFBUSxJQUFJRixLQUFLLElBQUlMLGNBQWMsTUFDMUNMLGlCQUFpQixHQUFHQSxpQkFBaUIsQ0FBQ2dCLE9BQU8sQ0FBQ0gsUUFBUSxFQUFFRixNQUFNLEdBQUdqRyxLQUFLLENBQUN1RyxHQUFHLENBQzNFLEVBQXVEO1FBQ3ZELEVBQWtEO1FBQ2xELEVBQW9DO1FBQ3BDLFFBQVEsQ0FBUEMsT0FBTztZQUFHQyxNQUFNLENBQU5BLGtCQUFrQixDQUFDRCxPQUFPO1dBQ25DRSxJQUFJLENBQUMsQ0FBRyxNQUFJRCxrQkFBa0IsQ0FBQ3pHLEtBQUssTUFBTSxDQUFHO0lBQ25ELENBQUMsR0FBRyxDQUFDO1FBQ0RzRixpQkFBaUIsR0FBRyxDQUFFLENBQUMsQ0FBbUM7O0lBRTlELEVBQXVFO0lBQ3ZFLEVBQWtEO0lBQ2xELENBQUM7SUFDRCxNQUFNLENBQUMsQ0FBQztRQUNKTyxNQUFNLEVBQU5BLE1BQU07UUFDTmMsTUFBTSxFQUFFckIsaUJBQWlCO0lBQzdCLENBQUM7QUFDTCxDQUFDO1NBQ1FzQixrQkFBa0IsQ0FBQ3ZCLEtBQUssRUFBRVEsTUFBTSxFQUFFLENBQUM7SUFDeEMsR0FBSyxDQUFDZ0IsYUFBYSxHQUFHLENBQUMsQ0FBQztJQUN4QmhILE1BQU0sQ0FBQ2lHLElBQUksQ0FBQ1QsS0FBSyxFQUFFeUIsT0FBTyxDQUFDLFFBQVEsQ0FBUDlFLEdBQUcsRUFBRyxDQUFDO1FBQy9CLEVBQUUsR0FBRzZELE1BQU0sQ0FBQ2tCLFFBQVEsQ0FBQy9FLEdBQUcsR0FBRyxDQUFDO1lBQ3hCNkUsYUFBYSxDQUFDN0UsR0FBRyxJQUFJcUQsS0FBSyxDQUFDckQsR0FBRztRQUNsQyxDQUFDO0lBQ0wsQ0FBQztJQUNELE1BQU0sQ0FBQzZFLGFBQWE7QUFDeEIsQ0FBQztTQUNRcEcsV0FBVyxDQUFDdUcsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVMsRUFBRSxDQUFDO0lBQzNDLEVBQTRDO0lBQzVDLEdBQUcsQ0FBQ0MsSUFBSTtJQUNSLEdBQUcsQ0FBQ0MsV0FBVyxHQUFHLE1BQU0sQ0FBQ0gsSUFBSSxLQUFLLENBQVEsVUFBR0EsSUFBSSxJQUFJLENBQUMsRUFBRXJGLFVBQVUsRUFBRXlGLG9CQUFvQixDQUFDSixJQUFJO0lBQzdGLEVBQTZEO0lBQzdELEVBQW1EO0lBQ25ELEdBQUssQ0FBQ0ssYUFBYSxHQUFHRixXQUFXLENBQUNHLEtBQUs7SUFDdkMsR0FBSyxDQUFDQyxrQkFBa0IsR0FBR0YsYUFBYSxHQUFHRixXQUFXLENBQUMzRCxLQUFLLENBQUM2RCxhQUFhLENBQUMsQ0FBQyxFQUFFNUQsTUFBTSxJQUFJMEQsV0FBVztJQUNuRyxHQUFLLENBQUNLLFFBQVEsR0FBR0Qsa0JBQWtCLENBQUNFLEtBQUssQ0FBQyxDQUFHO0lBQzdDLEVBQUUsR0FBR0QsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFFLEdBQUVGLEtBQUssZUFBZSxDQUFDO1FBQ3pDSSxPQUFPLENBQUNDLEtBQUssQ0FBRSxDQUFvQyxzQ0FBYyxNQUEyRSxDQUF2RlIsV0FBVyxFQUFDLENBQTJFO1FBQzVJLEdBQUssQ0FBQ1MsYUFBYSxJQUFJLENBQUMsRUFBRXpHLE1BQU0sRUFBRTBHLHdCQUF3QixDQUFDTixrQkFBa0I7UUFDN0VKLFdBQVcsSUFBSUUsYUFBYSxHQUFHQSxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUUsS0FBSU8sYUFBYTtJQUN6RSxDQUFDO0lBQ0QsRUFBMkQ7SUFDM0QsRUFBRSxHQUFHdEgsVUFBVSxDQUFDNkcsV0FBVyxHQUFHLENBQUM7UUFDM0IsTUFBTSxDQUFDRixTQUFTLEdBQUcsQ0FBQztZQUNoQkUsV0FBVztRQUNmLENBQUMsR0FBR0EsV0FBVztJQUNuQixDQUFDO0lBQ0QsR0FBRyxDQUFDLENBQUM7UUFDREQsSUFBSSxHQUFHLEdBQUcsQ0FBQ25DLEdBQUcsQ0FBQ29DLFdBQVcsQ0FBQy9ELFVBQVUsQ0FBQyxDQUFHLE1BQUkyRCxNQUFNLENBQUNlLE1BQU0sR0FBR2YsTUFBTSxDQUFDMUQsUUFBUSxFQUFFLENBQVU7SUFDNUYsQ0FBQyxDQUFDLEtBQUssRUFBRTRCLENBQUMsRUFBRSxDQUFDO1FBQ1QsRUFBa0Q7UUFDbERpQyxJQUFJLEdBQUcsR0FBRyxDQUFDbkMsR0FBRyxDQUFDLENBQUcsSUFBRSxDQUFVO0lBQ2xDLENBQUM7SUFDRCxHQUFHLENBQUMsQ0FBQztRQUNELEdBQUssQ0FBQ2dELFFBQVEsR0FBRyxHQUFHLENBQUNoRCxHQUFHLENBQUNvQyxXQUFXLEVBQUVELElBQUk7UUFDMUNhLFFBQVEsQ0FBQzFFLFFBQVEsSUFBSSxDQUFDLEVBQUUzQyx1QkFBdUIsRUFBRTZDLDBCQUEwQixDQUFDd0UsUUFBUSxDQUFDMUUsUUFBUTtRQUM3RixHQUFHLENBQUMyRSxjQUFjLEdBQUcsQ0FBRTtRQUN2QixFQUFFLEdBQUcsQ0FBQyxFQUFFNUcsVUFBVSxFQUFFNkcsY0FBYyxDQUFDRixRQUFRLENBQUMxRSxRQUFRLEtBQUswRSxRQUFRLENBQUNHLFlBQVksSUFBSWpCLFNBQVMsRUFBRSxDQUFDO1lBQzFGLEdBQUssQ0FBQzdCLEtBQUssSUFBSSxDQUFDLEVBQUU5RCxZQUFZLEVBQUU2RyxzQkFBc0IsQ0FBQ0osUUFBUSxDQUFDRyxZQUFZO1lBQzVFLEdBQUssQ0FBd0IzSCxHQUEwRCxHQUExREEsYUFBYSxDQUFDd0gsUUFBUSxDQUFDMUUsUUFBUSxFQUFFMEUsUUFBUSxDQUFDMUUsUUFBUSxFQUFFK0IsS0FBSyxHQUE5RXNCLE1BQU0sR0FBZW5HLEdBQTBELENBQS9FbUcsTUFBTSxFQUFHZCxNQUFNLEdBQU1yRixHQUEwRCxDQUF0RXFGLE1BQU07WUFDdkIsRUFBRSxFQUFFYyxNQUFNLEVBQUUsQ0FBQztnQkFDVHNCLGNBQWMsSUFBSSxDQUFDLEVBQUVyRyxVQUFVLEVBQUV5RixvQkFBb0IsQ0FBQyxDQUFDO29CQUNuRC9ELFFBQVEsRUFBRXFELE1BQU07b0JBQ2hCMEIsSUFBSSxFQUFFTCxRQUFRLENBQUNLLElBQUk7b0JBQ25CaEQsS0FBSyxFQUFFdUIsa0JBQWtCLENBQUN2QixLQUFLLEVBQUVRLE1BQU07Z0JBQzNDLENBQUM7WUFDTCxDQUFDO1FBQ0wsQ0FBQztRQUNELEVBQW9FO1FBQ3BFLEdBQUssQ0FBQ3lDLFlBQVksR0FBR04sUUFBUSxDQUFDL0MsTUFBTSxLQUFLa0MsSUFBSSxDQUFDbEMsTUFBTSxHQUFHK0MsUUFBUSxDQUFDZixJQUFJLENBQUN4RCxLQUFLLENBQUN1RSxRQUFRLENBQUMvQyxNQUFNLENBQUN2QixNQUFNLElBQUlzRSxRQUFRLENBQUNmLElBQUk7UUFDbEgsTUFBTSxDQUFDQyxTQUFTLEdBQUcsQ0FBQztZQUNoQm9CLFlBQVk7WUFDWkwsY0FBYyxJQUFJSyxZQUFZO1FBQ2xDLENBQUMsR0FBR0EsWUFBWTtJQUNwQixDQUFDLENBQUMsS0FBSyxFQUFFQyxFQUFFLEVBQUUsQ0FBQztRQUNWLE1BQU0sQ0FBQ3JCLFNBQVMsR0FBRyxDQUFDO1lBQ2hCRSxXQUFXO1FBQ2YsQ0FBQyxHQUFHQSxXQUFXO0lBQ25CLENBQUM7QUFDTCxDQUFDO1NBQ1FvQixXQUFXLENBQUM1RCxHQUFHLEVBQUUsQ0FBQztJQUN2QixHQUFLLENBQUNLLE1BQU0sSUFBSSxDQUFDLEVBQUU3RCxNQUFNLEVBQUUwRCxpQkFBaUI7SUFDNUMsTUFBTSxDQUFDRixHQUFHLENBQUN2QixVQUFVLENBQUM0QixNQUFNLElBQUlMLEdBQUcsQ0FBQ0QsU0FBUyxDQUFDTSxNQUFNLENBQUN2QixNQUFNLElBQUlrQixHQUFHO0FBQ3RFLENBQUM7U0FDUTZELFlBQVksQ0FBQ3pCLE1BQU0sRUFBRXBDLEdBQUcsRUFBRThELEVBQUUsRUFBRSxDQUFDO0lBQ3BDLEVBQXNEO0lBQ3RELEVBQWtEO0lBQ2xELEdBQUcsQ0FBOEJqSSxHQUE4QixrQkFBOUJBLFdBQVcsQ0FBQ3VHLE1BQU0sRUFBRXBDLEdBQUcsRUFBRSxJQUFJLE9BQXpEMEQsWUFBWSxHQUFnQjdILEdBQThCLEtBQTVDa0ksVUFBVSxHQUFJbEksR0FBOEI7SUFDL0QsR0FBSyxDQUFDd0UsTUFBTSxJQUFJLENBQUMsRUFBRTdELE1BQU0sRUFBRTBELGlCQUFpQjtJQUM1QyxHQUFLLENBQUM4RCxhQUFhLEdBQUdOLFlBQVksQ0FBQ2pGLFVBQVUsQ0FBQzRCLE1BQU07SUFDcEQsR0FBSyxDQUFDNEQsV0FBVyxHQUFHRixVQUFVLElBQUlBLFVBQVUsQ0FBQ3RGLFVBQVUsQ0FBQzRCLE1BQU07SUFDOURxRCxZQUFZLEdBQUdFLFdBQVcsQ0FBQ0YsWUFBWTtJQUN2Q0ssVUFBVSxHQUFHQSxVQUFVLEdBQUdILFdBQVcsQ0FBQ0csVUFBVSxJQUFJQSxVQUFVO0lBQzlELEdBQUssQ0FBQ0csV0FBVyxHQUFHRixhQUFhLEdBQUdOLFlBQVksR0FBR2pJLFdBQVcsQ0FBQ2lJLFlBQVk7SUFDM0UsR0FBSyxDQUFDUyxVQUFVLEdBQUdMLEVBQUUsR0FBR0YsV0FBVyxDQUFDL0gsV0FBVyxDQUFDdUcsTUFBTSxFQUFFMEIsRUFBRSxLQUFLQyxVQUFVLElBQUlMLFlBQVk7SUFDekYsTUFBTSxDQUFDLENBQUM7UUFDSjFELEdBQUcsRUFBRWtFLFdBQVc7UUFDaEJKLEVBQUUsRUFBRUcsV0FBVyxHQUFHRSxVQUFVLEdBQUcxSSxXQUFXLENBQUMwSSxVQUFVO0lBQ3pELENBQUM7QUFDTCxDQUFDO1NBQ1FDLG1CQUFtQixDQUFDMUYsUUFBUSxFQUFFMkYsS0FBSyxFQUFFLENBQUM7SUFDM0MsR0FBSyxDQUFDQyxhQUFhLElBQUksQ0FBQyxFQUFFdkksdUJBQXVCLEVBQUV3SSx1QkFBdUIsRUFBRSxDQUFDLEVBQUVuSSxvQkFBb0IsRUFBRW9JLG1CQUFtQixDQUFDOUYsUUFBUTtJQUNqSSxFQUFFLEVBQUU0RixhQUFhLEtBQUssQ0FBTSxTQUFJQSxhQUFhLEtBQUssQ0FBUyxVQUFFLENBQUM7UUFDMUQsTUFBTSxDQUFDNUYsUUFBUTtJQUNuQixDQUFDO0lBQ0QsRUFBMkM7SUFDM0MsRUFBRSxHQUFHMkYsS0FBSyxDQUFDbEMsUUFBUSxDQUFDbUMsYUFBYSxHQUFHLENBQUM7UUFDakMsRUFBaUQ7UUFDakRELEtBQUssQ0FBQ0ksSUFBSSxDQUFDLFFBQVEsQ0FBUEMsSUFBSSxFQUFHLENBQUM7WUFDaEIsRUFBRSxHQUFHLENBQUMsRUFBRWpJLFVBQVUsRUFBRTZHLGNBQWMsQ0FBQ29CLElBQUksTUFBTSxDQUFDLEVBQUU1SCxXQUFXLEVBQUU4RCxhQUFhLENBQUM4RCxJQUFJLEVBQUVDLEVBQUUsQ0FBQ0MsSUFBSSxDQUFDTixhQUFhLEdBQUcsQ0FBQztnQkFDdEc1RixRQUFRLEdBQUdnRyxJQUFJO2dCQUNmLE1BQU0sQ0FBQyxJQUFJO1lBQ2YsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxFQUFFLENBQUMsRUFBRTNJLHVCQUF1QixFQUFFd0ksdUJBQXVCLENBQUM3RixRQUFRO0FBQ3hFLENBQUM7QUFDRCxHQUFLLENBQUNtRyx1QkFBdUIsR0FBR2hILE1BQStHLElBQUksQ0FNaEo7QUFDSCxHQUFLLENBQUN5SCxrQkFBa0IsR0FBR0MsTUFBTSxDQUFDLENBQW9CO1NBQzdDQyxVQUFVLENBQUN4RixHQUFHLEVBQUV5RixRQUFRLEVBQUVDLElBQUksRUFBRSxDQUFDO0lBQ3RDLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDM0YsR0FBRyxFQUFFLENBQUM7UUFDZixFQUFzRTtRQUN0RSxFQUF5RDtRQUN6RCxFQUFFO1FBQ0YsRUFBb0U7UUFDcEUsRUFBWTtRQUNaLEVBQXlFO1FBQ3pFLEVBQUU7UUFDRixFQUFpRTtRQUNqRSxFQUFzRTtRQUN0RSxFQUE4QztRQUM5QyxFQUEwQztRQUMxQzRGLFdBQVcsRUFBRSxDQUFhO0lBQzlCLENBQUMsRUFBRUMsSUFBSSxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7UUFDWixFQUFFLEdBQUdBLEdBQUcsQ0FBQ0MsRUFBRSxFQUFFLENBQUM7WUFDVixFQUFFLEVBQUVOLFFBQVEsR0FBRyxDQUFDLElBQUlLLEdBQUcsQ0FBQ0UsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDO2dCQUNwQyxNQUFNLENBQUNSLFVBQVUsQ0FBQ3hGLEdBQUcsRUFBRXlGLFFBQVEsR0FBRyxDQUFDLEVBQUVDLElBQUk7WUFDN0MsQ0FBQztZQUNELEVBQUUsRUFBRUksR0FBRyxDQUFDRSxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7Z0JBQ3JCLE1BQU0sQ0FBQ0YsR0FBRyxDQUFDRyxJQUFJLEdBQUdKLElBQUksQ0FBQyxRQUFRLENBQVBLLElBQUksRUFBRyxDQUFDO29CQUM1QixFQUFFLEVBQUVBLElBQUksQ0FBQ0MsUUFBUSxFQUFFLENBQUM7d0JBQ2hCLE1BQU0sQ0FBQyxDQUFDOzRCQUNKQSxRQUFRLEVBQUViLGtCQUFrQjt3QkFDaEMsQ0FBQztvQkFDTCxDQUFDO29CQUNELEtBQUssQ0FBQyxHQUFHLENBQUNsSCxLQUFLLENBQUUsQ0FBMkI7Z0JBQ2hELENBQUM7WUFDTCxDQUFDO1lBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQ0EsS0FBSyxDQUFFLENBQTJCO1FBQ2hELENBQUM7UUFDRCxNQUFNLENBQUNzSCxJQUFJLENBQUNVLElBQUksR0FBR04sR0FBRyxDQUFDTSxJQUFJLEtBQUtOLEdBQUcsQ0FBQ0csSUFBSTtJQUM1QyxDQUFDO0FBQ0wsQ0FBQztTQUNRSSxhQUFhLENBQUNDLFFBQVEsRUFBRUMsY0FBYyxFQUFFSCxJQUFJLEVBQUVJLGFBQWEsRUFBRUMsWUFBWSxFQUFFLENBQUM7SUFDakYsR0FBSyxDQUF1QixHQUF1QyxHQUF2QyxHQUFHLENBQUNyRyxHQUFHLENBQUNrRyxRQUFRLEVBQUV2QixNQUFNLENBQUMyQixRQUFRLENBQUNyRSxJQUFJLEdBQXBEc0UsUUFBUSxHQUFNLEdBQXVDLENBQTNEdEUsSUFBSTtJQUNaLEVBQUUsRUFBRW1FLGFBQWEsQ0FBQ0csUUFBUSxNQUFNdEgsU0FBUyxFQUFFLENBQUM7UUFDeEMsTUFBTSxDQUFDbUgsYUFBYSxDQUFDRyxRQUFRO0lBQ2pDLENBQUM7SUFDRCxNQUFNLENBQUNILGFBQWEsQ0FBQ0csUUFBUSxJQUFJbkIsVUFBVSxDQUFDYyxRQUFRLEVBQUVDLGNBQWMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDM0VILElBQUksRUFBSkEsSUFBSTtJQUNSLENBQUMsRUFBRVEsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7UUFDYixFQUFxRTtRQUNyRSxFQUFvRTtRQUNwRSxFQUFRO1FBQ1IsRUFBRSxHQUFHTixjQUFjLEVBQUUsQ0FBQzthQUNqQixDQUFDLEVBQUV0SyxZQUFZLEVBQUU2SyxjQUFjLENBQUNELEdBQUc7UUFDeEMsQ0FBQztRQUNELEtBQUssQ0FBQ0EsR0FBRztJQUNiLENBQUMsRUFBRWhCLElBQUksQ0FBQyxRQUFRLENBQVBLLElBQUksRUFBRyxDQUFDO1FBQ2IsRUFBRSxHQUFHTyxZQUFZLElBNVV6QixDQUFhLGlCQTRVeUMsQ0FBWSxhQUFFLENBQUM7WUFDekQsTUFBTSxDQUFDRCxhQUFhLENBQUNHLFFBQVE7UUFDakMsQ0FBQztRQUNELE1BQU0sQ0FBQ1QsSUFBSTtJQUNmLENBQUMsRUFBRVUsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7UUFDYixNQUFNLENBQUNMLGFBQWEsQ0FBQ0csUUFBUTtRQUM3QixLQUFLLENBQUNFLEdBQUc7SUFDYixDQUFDO0FBQ0wsQ0FBQztJQUNLRSxNQUFNLGlCQUFaLFFBQVE7YUFBRkEsTUFBTSxDQUNJQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsR0FBRyxFQUFFLEtBQW1LO1lBQWpLQyxZQUFZLEdBQWQsS0FBbUssQ0FBaktBLFlBQVksRUFBR0MsVUFBVSxHQUEzQixLQUFtSyxDQUFsSkEsVUFBVSxFQUFHQyxHQUFHLEdBQWpDLEtBQW1LLENBQXJJQSxHQUFHLEVBQUdDLE9BQU8sR0FBM0MsS0FBbUssQ0FBL0hBLE9BQU8sRUFBR0MsU0FBUyxHQUF2RCxLQUFtSyxDQUFySEEsU0FBUyxFQUFHVixHQUFHLEdBQTdELEtBQW1LLENBQXpHQSxHQUFHLEVBQUdXLFlBQVksR0FBNUUsS0FBbUssQ0FBbkdBLFlBQVksRUFBR0MsVUFBVSxHQUF6RixLQUFtSyxDQUFwRkEsVUFBVSxFQUFHMUksTUFBTSxHQUFsRyxLQUFtSyxDQUF2RUEsTUFBTSxFQUFHQyxPQUFPLEdBQTVHLEtBQW1LLENBQTlEQSxPQUFPLEVBQUdRLGFBQWEsR0FBNUgsS0FBbUssQ0FBcERBLGFBQWEsRUFBR1AsYUFBYSxHQUE1SSxLQUFtSyxDQUFwQ0EsYUFBYSxFQUFHeUksU0FBUyxHQUF4SixLQUFtSyxDQUFwQkEsU0FBUyxFQUFHQyxLQUFLLEdBQWhLLEtBQW1LLENBQVJBLEtBQUs7OztRQUNoTSxFQUFvQjtRQUNwQixJQUFJLENBQUNDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDYixFQUErQztRQUMvQyxJQUFJLENBQUNDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDYixFQUEwQztRQUMxQyxJQUFJLENBQUNDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDYixJQUFJLENBQUNDLElBQUksR0FBRyxDQUFDO1FBQ2IsSUFBSSxDQUFDQyxVQUFVLEdBQUcsUUFDekIsQ0FEMEJDLENBQUMsRUFBRyxDQUFDO1lBQ3BCLEdBQUssQ0FBQ0MsS0FBSyxHQUFHRCxDQUFDLENBQUNDLEtBQUs7WUFDckIsRUFBRSxHQUFHQSxLQUFLLEVBQUUsQ0FBQztnQkFDVCxFQUE2QztnQkFDN0MsRUFBc0Q7Z0JBQ3RELEVBQWtDO2dCQUNsQyxFQUFFO2dCQUNGLEVBQW9FO2dCQUNwRSxFQUE0QjtnQkFDNUIsRUFBNEQ7Z0JBQzVELEVBQWtGO2dCQUNsRixFQUFnRDtnQkFDaEQsR0FBSyxDQUFHeEosUUFBUSxTQUFSQSxRQUFRLEVBQUcrQixLQUFLLFNBQUxBLEtBQUs7c0JBQ25CMEgsV0FBVyxDQUFDLENBQWMsZ0JBQUcsQ0FBQyxFQUFFbkwsVUFBVSxFQUFFeUYsb0JBQW9CLENBQUMsQ0FBQztvQkFDbkUvRCxRQUFRLEVBQUVqRCxXQUFXLENBQUNpRCxRQUFRO29CQUM5QitCLEtBQUssRUFBTEEsS0FBSztnQkFDVCxDQUFDLElBQUksQ0FBQyxFQUFFakUsTUFBTSxFQUFFNEwsTUFBTTtnQkFDdEIsTUFBTTtZQUNWLENBQUM7WUFDRCxFQUFFLEdBQUdGLEtBQUssQ0FBQ0csR0FBRyxFQUFFLENBQUM7Z0JBQ2IsTUFBTTtZQUNWLENBQUM7WUFDRCxHQUFHLENBQUNDLFlBQVk7WUFDaEIsR0FBSyxDQUFHdEksR0FBRyxHQUEyQmtJLEtBQUssQ0FBbkNsSSxHQUFHLEVBQUc4RCxFQUFFLEdBQXNCb0UsS0FBSyxDQUE3QnBFLEVBQUUsRUFBR3lFLE9BQU8sR0FBWUwsS0FBSyxDQUF4QkssT0FBTyxFQUFHQyxHQUFHLEdBQU1OLEtBQUssQ0FBZE0sR0FBRztZQUNoQyxFQUFFLEVBQUUzSyxLQUFxQyxFQUFFLFVBc0IxQztrQkFDSWtLLElBQUksR0FBR1MsR0FBRztZQUNmLEdBQUssQ0FBRzlKLFNBQVEsSUFBTyxDQUFDLEVBQUVoQyxpQkFBaUIsRUFBRXdNLGdCQUFnQixDQUFDbEosR0FBRyxFQUF6RHRCLFFBQVE7WUFDaEIsRUFBZ0Q7WUFDaEQsRUFBeUQ7WUFDekQsRUFBRSxRQUFPeUssS0FBSyxJQUFJckYsRUFBRSxLQUFLckksV0FBVyxPQUFNMEgsTUFBTSxLQUFLekUsU0FBUSxLQUFLakQsV0FBVyxPQUFNaUQsUUFBUSxHQUFHLENBQUM7Z0JBQzNGLE1BQU07WUFDVixDQUFDO1lBQ0QsRUFBdUQ7WUFDdkQsRUFBd0Q7WUFDeEQsRUFBRSxRQUFPMEssSUFBSSxXQUFVQSxJQUFJLENBQUNsQixLQUFLLEdBQUcsQ0FBQztnQkFDakMsTUFBTTtZQUNWLENBQUM7a0JBQ0ltQixNQUFNLENBQUMsQ0FBYyxlQUFFckosR0FBRyxFQUFFOEQsRUFBRSxFQUFFN0ksTUFBTSxDQUFDa0QsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFb0ssT0FBTyxFQUFFLENBQUM7Z0JBQzdEZSxPQUFPLEVBQUVmLE9BQU8sQ0FBQ2UsT0FBTyxVQUFTQyxRQUFRO2dCQUN6Q3hLLE1BQU0sRUFBRXdKLE9BQU8sQ0FBQ3hKLE1BQU0sVUFBU1MsYUFBYTtZQUNoRCxDQUFDLEdBQUc4SSxZQUFZO1FBQ3BCLENBQUM7UUFDRCxFQUF1QztRQUN2QyxHQUFLLENBQUMvSCxLQUFLLElBQUksQ0FBQyxFQUFFeEUsdUJBQXVCLEVBQUV3SSx1QkFBdUIsQ0FBQ3lDLFNBQVM7UUFDNUUsRUFBNkM7UUFDN0MsSUFBSSxDQUFDd0MsVUFBVSxHQUFHLENBQUMsQ0FBQztRQUNwQixFQUFvRDtRQUNwRCxFQUF3RDtRQUN4RCxFQUFrQztRQUNsQyxFQUFFLEVBQUV4QyxTQUFTLEtBQUssQ0FBUyxVQUFFLENBQUM7WUFDMUIsSUFBSSxDQUFDd0MsVUFBVSxDQUFDakosS0FBSyxJQUFJLENBQUM7Z0JBQ3RCZ0gsU0FBUyxFQUFUQSxTQUFTO2dCQUNUa0MsT0FBTyxFQUFFLElBQUk7Z0JBQ2JDLEtBQUssRUFBRXZDLFlBQVk7Z0JBQ25CTixHQUFHLEVBQUhBLEdBQUc7Z0JBQ0g4QyxPQUFPLEVBQUV4QyxZQUFZLElBQUlBLFlBQVksQ0FBQ3dDLE9BQU87Z0JBQzdDQyxPQUFPLEVBQUV6QyxZQUFZLElBQUlBLFlBQVksQ0FBQ3lDLE9BQU87Z0JBQzdDQyxPQUFPLElBQUlsQyxLQUFLO1lBQ3BCLENBQUM7UUFDTCxDQUFDO1FBQ0QsSUFBSSxDQUFDNkIsVUFBVSxDQUFDLENBQU8sVUFBSSxDQUFDO1lBQ3hCakMsU0FBUyxFQUFFRixHQUFHO1lBQ2R5QyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ25CLENBQUM7UUFDRCxFQUE0QztRQUM1QyxFQUFnRjtRQUNoRixJQUFJLENBQUNDLE1BQU0sR0FBR2hELE1BQU0sQ0FBQ2dELE1BQU07UUFDM0IsSUFBSSxDQUFDM0MsVUFBVSxHQUFHQSxVQUFVO1FBQzVCLEVBQThEO1FBQzlELEVBQWtEO1FBQ2xELEdBQUssQ0FBQzRDLGlCQUFpQixJQUFJLENBQUMsRUFBRXZOLFVBQVUsRUFBRTZHLGNBQWMsQ0FBQzBELFNBQVMsS0FBSzRCLElBQUksQ0FBQ3FCLGFBQWEsQ0FBQ0MsVUFBVTtRQUNwRyxJQUFJLENBQUNsTSxRQUFRLEdBQUdBLFFBQVE7UUFDeEIsSUFBSSxDQUFDbU0sR0FBRyxHQUFHM0MsWUFBWTtRQUN2QixJQUFJLENBQUM0QyxHQUFHLEdBQUcsSUFBSTtRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHL0MsT0FBTztRQUN2QixFQUE2RDtRQUM3RCxFQUEwQjtRQUMxQixJQUFJLENBQUM2QixLQUFLLEdBQUcsSUFBSTtRQUNqQixJQUFJLENBQUNtQixjQUFjLEdBQUcsS0FBSztRQUMzQixJQUFJLENBQUNDLE9BQU8sTUFBTTNCLElBQUksQ0FBQ3FCLGFBQWEsQ0FBQ08sSUFBSSxJQUFJNUIsSUFBSSxDQUFDcUIsYUFBYSxDQUFDUSxHQUFHLElBQUk3QixJQUFJLENBQUNxQixhQUFhLENBQUNTLE1BQU0sS0FBSzlCLElBQUksQ0FBQ3FCLGFBQWEsQ0FBQ1UsR0FBRyxLQUFLWCxpQkFBaUIsS0FBS3BCLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQ2tFLE1BQU0sS0FBSy9NLEtBQStCO1FBQzlNLEVBQUUsRUFBRUEsS0FBK0IsRUFBRSxFQUtwQztRQUNELElBQUksQ0FBQ3FLLEtBQUssR0FBRyxDQUFDO1lBQ1YzSCxLQUFLLEVBQUxBLEtBQUs7WUFDTDdCLFFBQVEsRUFBRXNJLFNBQVM7WUFDbkJ2RyxLQUFLLEVBQUV3RyxNQUFNO1lBQ2I5RCxNQUFNLEVBQUU2RyxpQkFBaUIsR0FBR2hELFNBQVMsR0FBR0UsR0FBRztZQUMzQ1EsU0FBUyxJQUFJQSxTQUFTO1lBQ3RCM0ksTUFBTSxFQUFFbEIsTUFBK0IsR0FBR2tCLENBQU0sR0FBR00sU0FBUztZQUM1RG9JLFVBQVUsRUFBVkEsVUFBVTtRQUNkLENBQUM7UUFDRCxFQUFFLEVBQUUsSUFBNkIsRUFBRSxDQUFDO1lBQ2hDLEVBQWtFO1lBQ2xFLEVBQTRDO1lBQzVDLEVBQUUsR0FBR1AsR0FBRyxDQUFDekksVUFBVSxDQUFDLENBQUksTUFBRyxDQUFDO2dCQUN4QixFQUEyRDtnQkFDM0QsRUFBNEQ7Z0JBQzVELEdBQUssQ0FBQzhKLFFBQU8sR0FBRyxDQUFDO29CQUNieEosTUFBTSxFQUFOQSxNQUFNO2dCQUNWLENBQUM7Z0JBQ0R3SixRQUFPLENBQUN3QyxrQkFBa0IsR0FBRzdELEdBQUcsS0FBS0YsU0FBUztnQkFDOUMsSUFBSSxDQUFDbUIsV0FBVyxDQUFDLENBQWMsZ0JBQUcsQ0FBQyxFQUFFbkwsVUFBVSxFQUFFeUYsb0JBQW9CLENBQUMsQ0FBQztvQkFDbkUvRCxRQUFRLEVBQUVqRCxXQUFXLENBQUN1TCxTQUFTO29CQUMvQnZHLEtBQUssRUFBRXdHLE1BQU07Z0JBQ2pCLENBQUMsSUFBSSxDQUFDLEVBQUV6SyxNQUFNLEVBQUU0TCxNQUFNLElBQUlHLFFBQU87WUFDckMsQ0FBQztZQUNEeEQsTUFBTSxDQUFDaUcsZ0JBQWdCLENBQUMsQ0FBVSxXQUFFLElBQUksQ0FBQ2hELFVBQVU7WUFDbkQsRUFBMkQ7WUFDM0QsRUFBbUQ7WUFDbkQsRUFBRSxFQUFFbkssS0FBcUMsRUFBRSxFQUkxQztRQUNMLENBQUM7Ozs7WUFFTHFOLEdBQU0sRUFBTkEsQ0FBTTttQkFBTkEsUUFBUSxDQUFSQSxNQUFNLEdBQUcsQ0FBQztnQkFDTm5HLE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ3dFLE1BQU07WUFDMUIsQ0FBQzs7O1lBQ0QsRUFFQzs7R0FBQSxHQUFDQyxHQUFJLEVBQUpBLENBQUk7bUJBQUpBLFFBQVEsQ0FBUkEsSUFBSSxHQUFHLENBQUM7Z0JBQ05wRyxNQUFNLENBQUNDLE9BQU8sQ0FBQ21HLElBQUk7WUFDdkIsQ0FBQzs7O1lBQ0QsRUFLQzs7Ozs7R0FBQSxHQUFDQyxHQUFJLEVBQUpBLENBQUk7bUJBQUpBLFFBQVEsQ0FBUkEsSUFBSSxDQUFDcEwsR0FBRyxFQUFFOEQsRUFBRSxFQUFnQixDQUFDO29CQUFmeUUsT0FBTyxvRUFBRyxDQUFDLENBQUM7Z0JBQ3hCLEVBQUUsRUFBRTFLLEtBQXFDLEVBQUUsRUFZMUM7O3NCQUNnQmdHLFlBQVksQ0FBQyxJQUFJLEVBQUU3RCxHQUFHLEVBQUU4RCxFQUFFLEdBQXhDOUQsR0FBRyxPQUFIQSxHQUFHLEVBQUc4RCxFQUFFLE9BQUZBLEVBQUU7Z0JBQ1gsTUFBTSxDQUFDLElBQUksQ0FBQ3VGLE1BQU0sQ0FBQyxDQUFXLFlBQUVySixHQUFHLEVBQUU4RCxFQUFFLEVBQUV5RSxPQUFPO1lBQ3BELENBQUM7OztZQUNELEVBS0M7Ozs7O0dBQUEsR0FBQzdHLEdBQU8sRUFBUEEsQ0FBTzttQkFBUEEsUUFBUTFCLENBQVIwQixPQUFPLENBQUMxQixHQUFHLEVBQUU4RCxFQUFFLEVBQWdCLENBQUM7b0JBQWZ5RSxPQUFPLG9FQUFHLENBQUMsQ0FBQzs7c0JBQ1YxRSxZQUFZLENBQUMsSUFBSSxFQUFFN0QsR0FBRyxFQUFFOEQsRUFBRSxHQUF4QzlELEdBQUcsT0FBSEEsR0FBRyxFQUFHOEQsRUFBRSxPQUFGQSxFQUFFO2dCQUNYLE1BQU0sQ0FBQyxJQUFJLENBQUN1RixNQUFNLENBQUMsQ0FBYyxlQUFFckosR0FBRyxFQUFFOEQsRUFBRSxFQUFFeUUsT0FBTztZQUN2RCxDQUFDOzs7WUFDS2MsR0FBTSxFQUFOQSxDQUFNO21CQUFaLFFBQVEsQ0FBRkEsTUFBTSxDQUFDZ0MsTUFBTSxFQUFFckwsR0FBRyxFQUFFOEQsRUFBRSxFQUFFeUUsT0FBTyxFQUFFRCxZQUFZOztpRUFBbkQsUUFBUSxXQUE2QyxDQUFDO3dCQUs1Q2dELGlCQUFpQixFQUNqQkMsU0FBUyxFQVFUQyxVQUFVLEVBTU5DLFFBQVEsRUFDUkMsZ0JBQWdCLEVBT2xCQyxXQUFXLEVBSVBDLEdBQUcsRUFVTHhNLGNBQWMsRUFPTnlNLFlBQVksWUFrQnRCdkMsT0FBTyxXQUFVd0MsTUFBTSxFQUN6QkMsVUFBVSxFQU9WQyxTQUFTLEVBRVhDLFlBQVksRUFxQlpDLE1BQU0sRUFDSnhOLFFBQVEsRUFBRytCLEtBQUssRUFJbEI0RCxLQUFLLEVBQUU4SCxRQUFRLGNBdUJmcEksVUFBVSxFQVFBcUksY0FBYyxFQW9DbEJDLE1BQU0sRUE0QlY5TCxLQUFLLEVBRURrTCxTQUFRLEVBQ1JqTCxVQUFVLEVBQ1Y4TCxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsaUJBQWlCLEVBQ2pCbkosY0FBYyxFQUVWb0osYUFBYSxFQW9CbkJDLEtBQUksRUFBRUMsS0FBSSxFQUNWQyxTQUFTLEVBQ1A1SixLQUFLLEVBQUcwRyxLQUFLLEVBQUdDLE9BQU8sRUFBR0MsT0FBTyxFQUl6QmlELFdBQVcsRUFLUEMsVUFBVSxFQUVxQmpKLElBQTRDLEVBQXBFa0osTUFBTSxFQUFPQyxLQUFLLEVBUy9CQyxhQUFhLEVBb0JuQkMsbUJBQW1CLEVBQ3JCQyxRQUFPLEVBQ0xDLFlBQVksRUFDWkMsV0FBVzs7OztvQ0EvUWhCMVIsVUFBVSxDQUFDcUUsR0FBRzs7OztnQ0FDZitFLE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ3JFLElBQUksR0FBR3JDLEdBQUc7NkRBQ25CLEtBQUs7O2dDQUVWc0wsaUJBQWlCLEdBQUcvQyxPQUFPLENBQUMrRSxFQUFFLElBQUkvRSxPQUFPLENBQUN3QyxrQkFBa0IsSUFBSXBNLGVBQWUsQ0FBQ3FCLEdBQUcsTUFBTXJCLGVBQWUsQ0FBQ21GLEVBQUU7Z0NBQzNHeUgsU0FBUywyQkFDSHJELEtBQUs7Z0NBRWpCLEVBQXlEO2dDQUN6RCxFQUE0RDtnQ0FDNUQsRUFBRSxFQUFFSyxPQUFPLENBQUMrRSxFQUFFLEVBQUUsQ0FBQzswQ0FDUi9DLE9BQU8sR0FBRyxJQUFJO2dDQUN2QixDQUFDO2dDQUNLaUIsVUFBVSxHQUFHRCxTQUFTLENBQUN4TSxNQUFNO3dDQUNBOzs7O2dDQUMvQndNLFNBQVMsQ0FBQ3hNLE1BQU0sR0FBR3dKLE9BQU8sQ0FBQ3hKLE1BQU0sS0FBSyxLQUFLLFNBQVFTLGFBQWEsR0FBRytJLE9BQU8sQ0FBQ3hKLE1BQU0sSUFBSXdNLFNBQVMsQ0FBQ3hNLE1BQU07Z0NBQ3JHLEVBQUUsRUFBRSxNQUFNLENBQUN3SixPQUFPLENBQUN4SixNQUFNLEtBQUssQ0FBVyxZQUFFLENBQUM7b0NBQ3hDd0osT0FBTyxDQUFDeEosTUFBTSxHQUFHd00sU0FBUyxDQUFDeE0sTUFBTTtnQ0FDckMsQ0FBQztnQ0FDSzBNLFFBQVEsSUFBSSxDQUFDLEVBQUUvTyxpQkFBaUIsRUFBRXdNLGdCQUFnQixDQUFDMU4sV0FBVyxDQUFDc0ksRUFBRSxJQUFJcEksV0FBVyxDQUFDb0ksRUFBRSxJQUFJQSxFQUFFO2dDQUN6RjRILGdCQUFnQixJQUFJLENBQUMsRUFBRXJQLG9CQUFvQixFQUFFNkMsbUJBQW1CLENBQUN1TSxRQUFRLENBQUMvTSxRQUFRLFFBQU9NLE9BQU87Z0NBQ3RHLEVBQUUsRUFBRTBNLGdCQUFnQixDQUFDdk0sY0FBYyxFQUFFLENBQUM7b0NBQ2xDb00sU0FBUyxDQUFDeE0sTUFBTSxHQUFHMk0sZ0JBQWdCLENBQUN2TSxjQUFjO29DQUNsRHNNLFFBQVEsQ0FBQy9NLFFBQVEsR0FBR2pELFdBQVcsQ0FBQ2dRLFFBQVEsQ0FBQy9NLFFBQVE7b0NBQ2pEb0YsRUFBRSxJQUFJLENBQUMsRUFBRTlHLFVBQVUsRUFBRXlGLG9CQUFvQixDQUFDZ0osUUFBUTtvQ0FDbER6TCxHQUFHLEdBQUd2RSxXQUFXLEVBQUUsQ0FBQyxFQUFFWSxvQkFBb0IsRUFBRTZDLG1CQUFtQixDQUFDMUQsV0FBVyxDQUFDd0UsR0FBRyxJQUFJdEUsV0FBVyxDQUFDc0UsR0FBRyxJQUFJQSxHQUFHLFFBQU9oQixPQUFPLEVBQUVOLFFBQVE7Z0NBQ3JJLENBQUM7Z0NBQ0dpTixXQUFXLEdBQUcsS0FBSztnQ0FDdkIsRUFBd0U7Z0NBQ3hFLEVBQTBDO2dDQUMxQyxFQUFFLEVBQUU5TixLQUErQixFQUFFLEVBVXBDO2dDQUNLdUIsY0FBYyxHQUFHeEIsa0JBQWtCLE9BQU1xQixhQUFhLEVBQUVJLFNBQVMsRUFBRWtNLFNBQVMsQ0FBQ3hNLE1BQU07Z0NBQ3pGLEVBQXdFO2dDQUN4RSxFQUEwQztnQ0FDMUMsRUFBRSxFQUFFbEIsS0FBK0IsRUFBRSxFQVVwQztxQ0FDRzhOLFdBQVc7Ozs7NkRBQ0osR0FBRyxDQUFDNEIsT0FBTyxDQUFDLFFBQVEsR0FBSixDQUFDLENBQUM7O2dDQUdqQyxFQUFFLEdBQUdoRixPQUFPLENBQUMrRSxFQUFFLEVBQUUsQ0FBQzswQ0FDVG5FLEtBQUssR0FBRyxLQUFLO2dDQUN0QixDQUFDO2dDQUNELEVBQW9EO2dDQUNwRCxFQUFFLEVBQUUzTSxNQUFNLENBQUNnUixFQUFFLEVBQUUsQ0FBQztvQ0FDWkMsV0FBVyxDQUFDQyxJQUFJLENBQUMsQ0FBYTtnQ0FDbEMsQ0FBQzsyQ0FDMENuRixPQUFPLENBQTFDZSxPQUFPLEVBQVBBLE9BQU8seUJBQUUsS0FBSyx1QkFBcUJmLE9BQU8sQ0FBekJ1RCxNQUFNLEVBQU5BLE1BQU0sd0JBQUUsSUFBSTtnQ0FDL0JDLFVBQVUsR0FBRyxDQUFDO29DQUNoQnpDLE9BQU8sRUFBUEEsT0FBTztnQ0FDWCxDQUFDO2dDQUNELEVBQUUsUUFBT3FFLGNBQWMsRUFBRSxDQUFDOzBDQUNqQkMsa0JBQWtCLE9BQU1ELGNBQWMsRUFBRTVCLFVBQVU7Z0NBQzNELENBQUM7Z0NBQ0RqSSxFQUFFLEdBQUdySSxXQUFXLENBQUNILFNBQVMsQ0FBQ0UsV0FBVyxDQUFDc0ksRUFBRSxJQUFJcEksV0FBVyxDQUFDb0ksRUFBRSxJQUFJQSxFQUFFLEVBQUV5RSxPQUFPLENBQUN4SixNQUFNLFFBQU9TLGFBQWE7Z0NBQy9Gd00sU0FBUyxHQUFHelEsU0FBUyxDQUFDQyxXQUFXLENBQUNzSSxFQUFFLElBQUlwSSxXQUFXLENBQUNvSSxFQUFFLElBQUlBLEVBQUUsRUFBRXlILFNBQVMsQ0FBQ3hNLE1BQU07c0NBQy9FNE8sY0FBYyxHQUFHN0osRUFBRTtnQ0FDcEJtSSxZQUFZLEdBQUdULFVBQVUsS0FBS0QsU0FBUyxDQUFDeE0sTUFBTTt1Q0FNN0N3SixPQUFPLENBQUMrRSxFQUFFLFVBQVNPLGVBQWUsQ0FBQzdCLFNBQVMsTUFBTUMsWUFBWTs7OztnQ0FDL0RWLFNBQVMsQ0FBQ3BJLE1BQU0sR0FBRzZJLFNBQVM7Z0NBQzVCakYsTUFBTSxDQUFDZ0QsTUFBTSxDQUFDK0QsSUFBSSxDQUFDLENBQWlCLGtCQUFFaEssRUFBRSxFQUFFaUksVUFBVTtnQ0FDcEQsRUFBOEQ7c0NBQ3pENUQsV0FBVyxDQUFDa0QsTUFBTSxFQUFFckwsR0FBRyxFQUFFOEQsRUFBRSxvQkFDekJ5RSxPQUFPO29DQUNWdUQsTUFBTSxFQUFFLEtBQUs7O2dDQUVqQixFQUFFLEVBQUVBLE1BQU0sRUFBRSxDQUFDOzBDQUNKaUMsWUFBWSxDQUFDL0IsU0FBUztnQ0FDL0IsQ0FBQztzQ0FDSXJPLEdBQUcsQ0FBQzROLFNBQVMsUUFBTy9CLFVBQVUsQ0FBQytCLFNBQVMsQ0FBQ2hMLEtBQUssR0FBRyxJQUFJO2dDQUMxRHdHLE1BQU0sQ0FBQ2dELE1BQU0sQ0FBQytELElBQUksQ0FBQyxDQUFvQixxQkFBRWhLLEVBQUUsRUFBRWlJLFVBQVU7NkRBQ2hELElBQUk7O2dDQUVYRyxNQUFNLElBQUksQ0FBQyxFQUFFeFAsaUJBQWlCLEVBQUV3TSxnQkFBZ0IsQ0FBQ2xKLEdBQUc7Z0NBQ2xEdEIsUUFBUSxHQUFjd04sTUFBTSxDQUE1QnhOLFFBQVEsRUFBRytCLEtBQUssR0FBTXlMLE1BQU0sQ0FBakJ6TCxLQUFLOzs7Ozs7dUNBTXlCOE0sT0FBTyxDQUFDUyxHQUFHLENBQUMsQ0FBQzswQ0FDL0M1RyxVQUFVLENBQUM2RyxXQUFXO3FDQUMxQixDQUFDLEVBQUVoUyxZQUFZLEVBQUVpUyxzQkFBc0I7MENBQ25DOUcsVUFBVSxDQUFDK0csaUJBQWlCO2dDQUNyQyxDQUFDOzs7O2dDQUpBOUosS0FBSztnREFBZ0I4SCxRQUFRLFFBQXBCaUMsVUFBVTs7Ozs7OztnQ0FNcEIsRUFBd0U7Z0NBQ3hFLEVBQStCO2dDQUMvQnJKLE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ3JFLElBQUksR0FBR3lCLEVBQUU7NkRBQ2xCLEtBQUs7O2dDQUVoQixFQUF1RTtnQ0FDdkUsRUFBOEU7Z0NBQzlFLEVBQXVEO2dDQUN2RCxFQUFvRTtnQ0FDcEUsRUFBc0U7Z0NBQ3RFLEVBQUUsU0FBUXVLLFFBQVEsQ0FBQ3JDLFNBQVMsTUFBTUMsWUFBWSxFQUFFLENBQUM7b0NBQzdDWixNQUFNLEdBQUcsQ0FBYztnQ0FDM0IsQ0FBQztnQ0FHR3RILFVBQVUsR0FBR0QsRUFBRTtnQ0FDbkIsRUFBNkQ7Z0NBQzdELEVBQWdFO2dDQUNoRSxFQUEyRDtnQ0FDM0RwRixRQUFRLEdBQUdBLFFBQVEsSUFBSSxDQUFDLEVBQUUzQyx1QkFBdUIsRUFBRXdJLHVCQUF1QixDQUFDN0ksV0FBVyxDQUFDZ0QsUUFBUSxLQUFLQSxRQUFRO3NDQUN4RzRNLGlCQUFpQixJQUFJNU0sUUFBUSxLQUFLLENBQVM7Ozs7Z0NBQzNDNkosT0FBTyxDQUFDd0Msa0JBQWtCLEdBQUcsSUFBSTt3Q0FDdUI7Ozs7Z0NBQzlDcUIsY0FBYyxJQUFJLENBQUMsRUFBRXhQLGdCQUFnQixFQUFFZCxPQUFPLENBQUNMLFdBQVcsQ0FBQ0gsU0FBUyxDQUFDMFEsU0FBUyxFQUFFVCxTQUFTLENBQUN4TSxNQUFNLElBQUlzRixLQUFLLEVBQUU4SCxRQUFRLEVBQUUxTCxLQUFLLEVBQUUsUUFBUSxDQUFQNk4sQ0FBQztvQ0FBR2xLLE1BQU0sQ0FBTkEsbUJBQW1CLENBQUNrSyxDQUFDLEVBQUVqSyxLQUFLO3lDQUM1SnJGLE9BQU87cUNBQ1ZvTixjQUFjLENBQUNtQyxZQUFZOzs7O2dDQUMzQjdILFFBQVEsQ0FBQ3JFLElBQUksR0FBR3lCLEVBQUU7NkRBQ1gsSUFBSTs7Z0NBRWZDLFVBQVUsR0FBR3FJLGNBQWMsQ0FBQ2pKLE1BQU07Z0NBQ2xDLEVBQUUsRUFBRWlKLGNBQWMsQ0FBQ29DLFdBQVcsSUFBSXBDLGNBQWMsQ0FBQzFJLFlBQVksRUFBRSxDQUFDO29DQUM1RCxFQUFnRTtvQ0FDaEUsRUFBNEM7b0NBQzVDaEYsUUFBUSxHQUFHME4sY0FBYyxDQUFDMUksWUFBWTtvQ0FDdEN3SSxNQUFNLENBQUN4TixRQUFRLEdBQUdqRCxXQUFXLENBQUNpRCxRQUFRO29DQUN0Q3NCLEdBQUcsSUFBSSxDQUFDLEVBQUVoRCxVQUFVLEVBQUV5RixvQkFBb0IsQ0FBQ3lKLE1BQU07Z0NBQ3JELENBQUM7Ozs7Z0NBQ0UsQ0FBQztvQ0FDSkEsTUFBTSxDQUFDeE4sUUFBUSxHQUFHMEYsbUJBQW1CLENBQUMxRixRQUFRLEVBQUUyRixLQUFLO29DQUNyRCxFQUFFLEVBQUU2SCxNQUFNLENBQUN4TixRQUFRLEtBQUtBLFFBQVEsRUFBRSxDQUFDO3dDQUMvQkEsUUFBUSxHQUFHd04sTUFBTSxDQUFDeE4sUUFBUTt3Q0FDMUJ3TixNQUFNLENBQUN4TixRQUFRLEdBQUdqRCxXQUFXLENBQUNpRCxRQUFRO3dDQUN0Q3NCLEdBQUcsSUFBSSxDQUFDLEVBQUVoRCxVQUFVLEVBQUV5RixvQkFBb0IsQ0FBQ3lKLE1BQU07b0NBQ3JELENBQUM7Z0NBQ0wsQ0FBQzs7b0NBRUF2USxVQUFVLENBQUNtSSxFQUFFOzs7O3lDQUMyQixFQUFFLEU7Z0NBQ3ZDLEtBQUssQ0FBQyxHQUFHLENBQUMxRixLQUFLLENBQUUsQ0FBZSxrQkFBbUIwRixNQUFFLENBQW5COUQsR0FBRyxFQUFDLENBQVcsZ0JBQUssTUFBeUMsQ0FBNUM4RCxFQUFFLEVBQUMsQ0FBeUMsK0NBQUssQ0FBa0Y7O2dDQUUxTGlCLE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ3JFLElBQUksR0FBR3lCLEVBQUU7NkRBQ2xCLEtBQUs7O2dDQUVoQkMsVUFBVSxHQUFHeEksU0FBUyxDQUFDRyxXQUFXLENBQUNxSSxVQUFVLEdBQUd3SCxTQUFTLENBQUN4TSxNQUFNO3dDQUsxRHdKLE9BQU8sQ0FBQ2UsT0FBTyxJQUFJZixPQUFPLENBQUMrRSxFQUFFLEtBQUssQ0FBQyxNQUFNL0UsT0FBTyxDQUFDK0UsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU3USxVQUFVLEVBQUU2RyxjQUFjLEVBQUUsQ0FBQyxFQUFFdkgsdUJBQXVCLEVBQUV3SSx1QkFBdUIsQ0FBQzdGLFFBQVE7Ozs7OzZDQUNqSStQLGlCQUFpQixDQUFDLENBQUM7b0NBQ3pDM0ssRUFBRSxFQUFGQSxFQUFFO29DQUNGNEssS0FBSyxFQS9yQnJCLENBQWEsaUJBK3JCbUMsQ0FBWTtvQ0FDNUNySyxLQUFLLEVBQUxBLEtBQUs7b0NBQ0wzRixRQUFRLEVBQVJBLFFBQVE7b0NBQ1IrQixLQUFLLEVBQUxBLEtBQUs7b0NBQ0wxQixNQUFNLEVBQUV3TSxTQUFTLENBQUN4TSxNQUFNO29DQUN4QjJJLFNBQVMsRUFBRTZELFNBQVMsQ0FBQzdELFNBQVM7Z0NBQ2xDLENBQUM7O2dDQVJLMkUsTUFBTTtzQ0FTUkEsTUFBTSxDQUFDc0MsSUFBSSxLQUFLLENBQVM7Ozs7Z0NBQUUsQ0FBQztvQ0FDNUJsTyxLQUFLLHFCQUNFQSxLQUFLLEVBQ0w0TCxNQUFNLENBQUNaLFFBQVEsQ0FBQ2hMLEtBQUs7b0NBRTVCc0QsVUFBVSxHQUFHc0ksTUFBTSxDQUFDbEosTUFBTTtvQ0FDMUJ6RSxRQUFRLEdBQUcyTixNQUFNLENBQUMzSSxZQUFZO29DQUM5QndJLE1BQU0sQ0FBQ3hOLFFBQVEsR0FBRzJOLE1BQU0sQ0FBQzNJLFlBQVk7b0NBQ3JDMUQsR0FBRyxJQUFJLENBQUMsRUFBRWhELFVBQVUsRUFBRXlGLG9CQUFvQixDQUFDeUosTUFBTTtnQ0FDckQsQ0FBQzs7OztzQ0FBVUcsTUFBTSxDQUFDc0MsSUFBSSxLQUFLLENBQVUsYUFBSXRDLE1BQU0sQ0FBQ1csS0FBSzs7OzttRUFDckMzRCxNQUFNLENBQUNnQyxNQUFNLEVBQUVnQixNQUFNLENBQUNVLE1BQU0sRUFBRVYsTUFBTSxDQUFDVyxLQUFLLEVBQUV6RSxPQUFPOztzQ0FDeEQ4RCxNQUFNLENBQUNzQyxJQUFJLEtBQUssQ0FBVSxhQUFJdEMsTUFBTSxDQUFDUSxXQUFXOzs7O2dDQUN2RDlILE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ3JFLElBQUksR0FBR2dLLE1BQU0sQ0FBQ1EsV0FBVzs2REFDbEMsR0FBRyxDQUFDVSxPQUFPLENBQUMsUUFBUSxHQUFKLENBQUMsQ0FBQzs7c0NBQ2xCbEIsTUFBTSxDQUFDc0MsSUFBSSxLQUFLLENBQVMsWUFBSTdLLEVBQUUsS0FBS2lCLE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ2hJLFFBQVE7Ozs7Z0NBQ25FcUcsTUFBTSxDQUFDMkIsUUFBUSxDQUFDckUsSUFBSSxHQUFHeUIsRUFBRTs2REFDbEIsR0FBRyxDQUFDeUosT0FBTyxDQUFDLFFBQVEsR0FBSixDQUFDLENBQUM7O2dDQUczQmhOLEtBQUssSUFBSSxDQUFDLEVBQUV4RSx1QkFBdUIsRUFBRXdJLHVCQUF1QixDQUFDN0YsUUFBUTtzQ0FDdEUsQ0FBQyxFQUFFakMsVUFBVSxFQUFFNkcsY0FBYyxDQUFDL0MsS0FBSzs7OztnQ0FDOUJrTCxTQUFRLElBQUksQ0FBQyxFQUFFL08saUJBQWlCLEVBQUV3TSxnQkFBZ0IsQ0FBQ25GLFVBQVU7Z0NBQzdEdkQsVUFBVSxHQUFHaUwsU0FBUSxDQUFDL00sUUFBUTtnQ0FDOUI0TixVQUFVLElBQUksQ0FBQyxFQUFFeFAsV0FBVyxFQUFFOEQsYUFBYSxDQUFDTCxLQUFLO2dDQUNqRGdNLFVBQVUsSUFBSSxDQUFDLEVBQUUxUCxhQUFhLEVBQUVtRSxlQUFlLENBQUNzTCxVQUFVLEVBQUU5TCxVQUFVO2dDQUN0RWdNLGlCQUFpQixHQUFHak0sS0FBSyxLQUFLQyxVQUFVO2dDQUN4QzZDLGNBQWMsR0FBR21KLGlCQUFpQixHQUFHNVEsYUFBYSxDQUFDMkUsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLEtBQUssSUFBSSxDQUFDLENBQUM7dUNBQ2xGOEwsVUFBVSxJQUFJQyxpQkFBaUIsS0FBS25KLGNBQWMsQ0FBQ3RCLE1BQU07Ozs7Z0NBQ3BEMEssYUFBYSxHQUFHeFIsTUFBTSxDQUFDaUcsSUFBSSxDQUFDb0wsVUFBVSxDQUFDeEwsTUFBTSxFQUFFOE4sTUFBTSxDQUFDLFFBQVEsQ0FBUHhOLEtBQUs7b0NBQUcsTUFBTSxFQUFMWCxLQUFLLENBQUNXLEtBQUs7O3NDQUU3RXFMLGFBQWEsQ0FBQzNOLE1BQU0sR0FBRyxDQUFDOzs7O2dDQUN4QixFQUFFLEVBcnVCdEIsSUFxdUI2RCxFQUFFLENBQUM7b0NBQ3hDaUUsT0FBTyxDQUFDOEwsSUFBSSxDQUFFLEdBQStFLE1BQTRCLENBQXpHckMsaUJBQWlCLEdBQUksQ0FBa0Isc0JBQUssQ0FBK0IsOEJBQUUsQ0FBNEIsaUNBQUssQ0FBWSxjQUEyQixNQUE0QixDQUFyREMsYUFBYSxDQUFDM0ssSUFBSSxDQUFDLENBQUksTUFBRSxDQUE0QjtnQ0FDck0sQ0FBQztnQ0FDRCxLQUFLLENBQUMsR0FBRyxDQUFDMUQsS0FBSyxFQUFFb08saUJBQWlCLEdBQUksQ0FBdUIsdUJBQXlDQyxNQUF3QixDQUEvRHpNLEdBQUcsRUFBQyxDQUFpQyxvQ0FBMkIsTUFBK0IsQ0FBeER5TSxhQUFhLENBQUMzSyxJQUFJLENBQUMsQ0FBSSxNQUFFLENBQStCLG9DQUFLLENBQTJCLDJCQUEwRHZCLE1BQUssQ0FBN0RDLFVBQVUsRUFBQyxDQUEyQyw0Q0FBUSxNQUFHLENBQVRELEtBQUssRUFBQyxDQUFHLFNBQU0sQ0FBNEMsOENBQTJFLE9BQXpFaU0saUJBQWlCLEdBQUcsQ0FBMkIsNkJBQUcsQ0FBc0I7Ozs7O2dDQUU5WCxFQUFFLEVBQUVBLGlCQUFpQixFQUFFLENBQUM7b0NBQzNCMUksRUFBRSxJQUFJLENBQUMsRUFBRTlHLFVBQVUsRUFBRXlGLG9CQUFvQixDQUFDeEgsTUFBTSxDQUFDa0QsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFc04sU0FBUSxFQUFFLENBQUM7d0NBQ25FL00sUUFBUSxFQUFFMkUsY0FBYyxDQUFDdEIsTUFBTTt3Q0FDL0J0QixLQUFLLEVBQUV1QixrQkFBa0IsQ0FBQ3ZCLEtBQUssRUFBRTRDLGNBQWMsQ0FBQ3BDLE1BQU07b0NBQzFELENBQUM7Z0NBQ0wsQ0FBQyxNQUFNLENBQUM7b0NBQ0osRUFBaUU7b0NBQ2pFaEcsTUFBTSxDQUFDa0QsTUFBTSxDQUFDc0MsS0FBSyxFQUFFOEwsVUFBVTtnQ0FDbkMsQ0FBQzs7Z0NBRUx4RixNQUFNLENBQUNnRCxNQUFNLENBQUMrRCxJQUFJLENBQUMsQ0FBa0IsbUJBQUVoSyxFQUFFLEVBQUVpSSxVQUFVOzs7OzZDQUd0QitDLFlBQVksQ0FBQ3ZPLEtBQUssRUFBRTdCLFFBQVEsRUFBRStCLEtBQUssRUFBRXFELEVBQUUsRUFBRUMsVUFBVSxFQUFFZ0ksVUFBVSxFQUFFUixTQUFTLENBQUN4TSxNQUFNLEVBQUV3TSxTQUFTLENBQUM3RCxTQUFTOztnQ0FBN0hrRixTQUFTO2dDQUNQNUosS0FBSyxHQUFrQzRKLFNBQVMsQ0FBaEQ1SixLQUFLLEVBQUcwRyxLQUFLLEdBQTBCa0QsU0FBUyxDQUF4Q2xELEtBQUssRUFBR0MsT0FBTyxHQUFnQmlELFNBQVMsQ0FBaENqRCxPQUFPLEVBQUdDLE9BQU8sR0FBTWdELFNBQVMsQ0FBdEJoRCxPQUFPO3VDQUVsQ0QsT0FBTyxJQUFJQyxPQUFPLEtBQUtGLEtBQUs7Ozs7c0NBQ3pCQSxLQUFLLENBQUNxRixTQUFTLElBQUlyRixLQUFLLENBQUNxRixTQUFTLENBQUNDLFlBQVk7Ozs7Z0NBQ3pDbkMsV0FBVyxHQUFHbkQsS0FBSyxDQUFDcUYsU0FBUyxDQUFDQyxZQUFZO3NDQUk1Q25DLFdBQVcsQ0FBQ3BPLFVBQVUsQ0FBQyxDQUFHLE9BQUtpTCxLQUFLLENBQUNxRixTQUFTLENBQUNFLHNCQUFzQixLQUFLLEtBQUs7Ozs7Z0NBQ3pFbkMsVUFBVSxJQUFJLENBQUMsRUFBRXBRLGlCQUFpQixFQUFFd00sZ0JBQWdCLENBQUMyRCxXQUFXO2dDQUN0RUMsVUFBVSxDQUFDcE8sUUFBUSxHQUFHMEYsbUJBQW1CLENBQUMwSSxVQUFVLENBQUNwTyxRQUFRLEVBQUUyRixLQUFLO2dDQUMvQlIsSUFBNEMsR0FBNUNBLFlBQVksUUFBT2dKLFdBQVcsRUFBRUEsV0FBVyxHQUFuRUUsTUFBTSxHQUFrQmxKLElBQTRDLENBQXpFN0QsR0FBRyxFQUFlZ04sS0FBSyxHQUFNbkosSUFBNEMsQ0FBM0RDLEVBQUU7bUVBQ1p1RixNQUFNLENBQUNnQyxNQUFNLEVBQUUwQixNQUFNLEVBQUVDLEtBQUssRUFBRXpFLE9BQU87O2dDQUVyRHhELE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ3JFLElBQUksR0FBR3dLLFdBQVc7NkRBQzNCLEdBQUcsQ0FBQ1UsT0FBTyxDQUFDLFFBQVEsR0FBSixDQUFDLENBQUM7O2dDQUU3QmhDLFNBQVMsQ0FBQzdELFNBQVMsS0FBS2dDLEtBQUssQ0FBQ3dGLFdBQVc7c0NBRXJDeEYsS0FBSyxDQUFDdkQsUUFBUSxLQUFLYixrQkFBa0I7Ozs7Ozs7NkNBR3RCNkosY0FBYyxDQUFDLENBQU07O2dDQUNoQ2xDLGFBQWEsR0FBRyxDQUFNOzs7Ozs7Z0NBRXRCQSxhQUFhLEdBQUcsQ0FBUzs7OzZDQUVONkIsWUFBWSxDQUFDN0IsYUFBYSxFQUFFQSxhQUFhLEVBQUV4TSxLQUFLLEVBQUVxRCxFQUFFLEVBQUVDLFVBQVUsRUFBRSxDQUFDO29DQUN0RnVGLE9BQU8sRUFBRSxLQUFLO2dDQUNsQixDQUFDLEVBQUVpQyxTQUFTLENBQUN4TSxNQUFNLEVBQUV3TSxTQUFTLENBQUM3RCxTQUFTOztnQ0FGeENrRixTQUFTOztnQ0FLakI3RixNQUFNLENBQUNnRCxNQUFNLENBQUMrRCxJQUFJLENBQUMsQ0FBcUIsc0JBQUVoSyxFQUFFLEVBQUVpSSxVQUFVO3NDQUNuRDVELFdBQVcsQ0FBQ2tELE1BQU0sRUFBRXJMLEdBQUcsRUFBRThELEVBQUUsRUFBRXlFLE9BQU87Z0NBQ3pDLEVBQUUsRUFBRUEsT0FBTyxDQUFDK0UsRUFBRSxJQUFJNU8sUUFBUSxLQUFLLENBQVMsY0FBTWdPLEtBQUksR0FBRzlELElBQUksQ0FBQ3FCLGFBQWEsQ0FBQ1AsS0FBSyxNQUFNLElBQUksSUFBSWdELEtBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUlDLEtBQUksR0FBR0QsS0FBSSxDQUFDcUMsU0FBUyxNQUFNLElBQUksSUFBSXBDLEtBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUdBLEtBQUksQ0FBQ3lDLFVBQVUsTUFBTSxHQUFHLEtBQUsxRixLQUFLLEtBQUssSUFBSSxJQUFJQSxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHQSxLQUFLLENBQUNxRixTQUFTLEdBQUcsQ0FBQztvQ0FDL1EsRUFBeUQ7b0NBQ3pELEVBQWtDO29DQUNsQ3JGLEtBQUssQ0FBQ3FGLFNBQVMsQ0FBQ0ssVUFBVSxHQUFHLEdBQUc7Z0NBQ3BDLENBQUM7Z0NBRUtsQyxtQkFBbUIsR0FBRzNFLE9BQU8sQ0FBQ2UsT0FBTyxJQUFJaUMsU0FBUyxDQUFDaEwsS0FBSyxLQUFLQSxLQUFLOztnQ0FFbEU2TSxZQUFZLElBQUlELFFBQU8sR0FBRzVFLE9BQU8sQ0FBQ3VELE1BQU0sTUFBTSxJQUFJLElBQUlxQixRQUFPLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBR0EsUUFBTyxJQUFJRCxtQkFBbUI7Z0NBQ3pHRyxXQUFXLEdBQUdELFlBQVksR0FBRyxDQUFDO29DQUNoQ3pFLENBQUMsRUFBRSxDQUFDO29DQUNKRyxDQUFDLEVBQUUsQ0FBQztnQ0FDUixDQUFDLEdBQUcsSUFBSTs7NkNBQ0duTCxHQUFHLG1CQUNQNE4sU0FBUztvQ0FDWmhMLEtBQUssRUFBTEEsS0FBSztvQ0FDTDdCLFFBQVEsRUFBUkEsUUFBUTtvQ0FDUitCLEtBQUssRUFBTEEsS0FBSztvQ0FDTDBDLE1BQU0sRUFBRTZJLFNBQVM7b0NBQ2pCdkUsVUFBVSxFQUFFLEtBQUs7b0NBQ2xCbUYsU0FBUyxFQUFFdEUsWUFBWSxLQUFLLElBQUksSUFBSUEsWUFBWSxLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUdBLFlBQVksR0FBRytFLFdBQVcsRUFBRXpHLEtBQUssQ0FBQyxRQUM5RyxDQUQrR3FCLENBQUMsRUFBRyxDQUFDO29DQUNyRyxFQUFFLEVBQUVBLENBQUMsQ0FBQzVKLFNBQVMsRUFBRTJFLEtBQUssR0FBR0EsS0FBSyxJQUFJaUYsQ0FBQzt5Q0FDOUIsS0FBSyxDQUFDQSxDQUFDO2dDQUNoQixDQUFDOztxQ0FDR2pGLEtBQUs7Ozs7Z0NBQ0wrRCxNQUFNLENBQUNnRCxNQUFNLENBQUMrRCxJQUFJLENBQUMsQ0FBa0IsbUJBQUU5SyxLQUFLLEVBQUVnSixTQUFTLEVBQUVELFVBQVU7Z0NBQ25FLEtBQUssQ0FBQy9JLEtBQUs7O2dDQUVmLEVBQUUsRUFBRW5GLEtBQStCLEVBQUUsRUFJcEM7Z0NBQ0RrSixNQUFNLENBQUNnRCxNQUFNLENBQUMrRCxJQUFJLENBQUMsQ0FBcUIsc0JBQUVoSyxFQUFFLEVBQUVpSSxVQUFVOzZEQUNqRCxJQUFJOzs7O3VDQUVOLENBQUMsRUFBRTdQLFFBQVEsRUFBRUosT0FBTyxxQkFBZXVDLFNBQVM7Ozs7NkRBQ3RDLEtBQUs7O2dDQUVoQixLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUViLENBQUM7Ozs7WUFDRDhKLEdBQVcsRUFBWEEsQ0FBVzttQkFBWEEsUUFBUSxDQUFSQSxXQUFXLENBQUNrRCxNQUFNLEVBQUVyTCxHQUFHLEVBQUU4RCxFQUFFLEVBQWdCLENBQUM7b0JBQWZ5RSxPQUFPLG9FQUFHLENBQUMsQ0FBQztnQkFDckMsRUFBRSxFQXIwQlYsSUFxMEJpRCxFQUFFLENBQUM7b0JBQ3hDLEVBQUUsRUFBRSxNQUFNLENBQUN4RCxNQUFNLENBQUNDLE9BQU8sS0FBSyxDQUFXLFlBQUUsQ0FBQzt3QkFDeENqQyxPQUFPLENBQUNDLEtBQUssQ0FBRSxDQUF5Qzt3QkFDeEQsTUFBTTtvQkFDVixDQUFDO29CQUNELEVBQUUsRUFBRSxNQUFNLENBQUMrQixNQUFNLENBQUNDLE9BQU8sQ0FBQ3FHLE1BQU0sTUFBTSxDQUFXLFlBQUUsQ0FBQzt3QkFDaER0SSxPQUFPLENBQUNDLEtBQUssQ0FBRSxDQUF3QiwwQkFBUyxNQUFpQixDQUF4QnFJLE1BQU0sRUFBQyxDQUFpQjt3QkFDakUsTUFBTTtvQkFDVixDQUFDO2dCQUNMLENBQUM7Z0JBQ0QsRUFBRSxFQUFFQSxNQUFNLEtBQUssQ0FBVyxlQUFLLENBQUMsRUFBRTdPLE1BQU0sRUFBRTRMLE1BQU0sT0FBT3RFLEVBQUUsRUFBRSxDQUFDO29CQUN4RCxJQUFJLENBQUN5RixRQUFRLEdBQUdoQixPQUFPLENBQUNlLE9BQU87b0JBQy9CdkUsTUFBTSxDQUFDQyxPQUFPLENBQUNxRyxNQUFNLEVBQUUsQ0FBQzt3QkFDcEJyTCxHQUFHLEVBQUhBLEdBQUc7d0JBQ0g4RCxFQUFFLEVBQUZBLEVBQUU7d0JBQ0Z5RSxPQUFPLEVBQVBBLE9BQU87d0JBQ1BGLEdBQUcsRUFBRSxJQUFJO3dCQUNURyxHQUFHLEVBQUUsSUFBSSxDQUFDVCxJQUFJLEdBQUdzRCxNQUFNLEtBQUssQ0FBVyxhQUFHLElBQUksQ0FBQ3RELElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksR0FBRyxDQUFDO29CQUN2RSxDQUFDLEVBQ0QsRUFBcUY7b0JBQ3JGLEVBQXdFO29CQUN4RSxDQUFFLEdBQUVqRSxFQUFFO2dCQUNWLENBQUM7WUFDTCxDQUFDOzs7WUFDSzBMLEdBQW9CLEVBQXBCQSxDQUFvQjttQkFBMUIsUUFBUSxDQUFGQSxvQkFBb0IsQ0FBQzNJLEdBQUcsRUFBRW5JLFFBQVEsRUFBRStCLEtBQUssRUFBRXFELEVBQUUsRUFBRWlJLFVBQVUsRUFBRTBELGFBQWE7O2lFQUE5RSxRQUFRLFdBQXdFLENBQUM7d0JBa0JyRWxJLFNBQVMsRUFDVHVDLFdBQVcsRUFDWEosS0FBSyxPQUlIa0QsU0FBUzs7OztxQ0F2QmYvRixHQUFHLENBQUN4SSxTQUFTOzs7O2dDQUNiLEVBQWdDO2dDQUNoQyxLQUFLLENBQUN3SSxHQUFHOzt1Q0FFUixDQUFDLEVBQUU1SyxZQUFZLEVBQUV5VCxZQUFZLENBQUM3SSxHQUFHLEtBQUs0SSxhQUFhOzs7O2dDQUNwRDFJLE1BQU0sQ0FBQ2dELE1BQU0sQ0FBQytELElBQUksQ0FBQyxDQUFrQixtQkFBRWpILEdBQUcsRUFBRS9DLEVBQUUsRUFBRWlJLFVBQVU7Z0NBQzFELEVBQWlFO2dDQUNqRSxFQUEwQjtnQ0FDMUIsRUFBMEM7Z0NBQzFDLEVBQTRDO2dDQUM1QyxFQUErRDtnQ0FDL0RoSCxNQUFNLENBQUMyQixRQUFRLENBQUNyRSxJQUFJLEdBQUd5QixFQUFFO2dDQUN6QixFQUFrRTtnQ0FDbEUsRUFBOEQ7Z0NBQzlELEtBQUssQ0FBQzVGLHNCQUFzQjs7Ozs7O3NDQU14QixNQUFNLENBQUNxSixTQUFTLEtBQUssQ0FBVyxjQUFJLE1BQU0sQ0FBQ3VDLFdBQVcsS0FBSyxDQUFXOzs7Ozs7NkNBQ3JCcUYsY0FBYyxDQUFDLENBQVM7OztnQ0FBaEU1SCxTQUFTLE9BQWY3QyxJQUFJO2dDQUFjb0YsV0FBVyxPQUFYQSxXQUFXOzs7Z0NBRTlCOEMsU0FBUyxHQUFHLENBQUM7b0NBQ2ZsRCxLQUFLLEVBQUxBLEtBQUs7b0NBQ0xuQyxTQUFTLEVBQVRBLFNBQVM7b0NBQ1R1QyxXQUFXLEVBQVhBLFdBQVc7b0NBQ1hqRCxHQUFHLEVBQUhBLEdBQUc7b0NBQ0g3RCxLQUFLLEVBQUU2RCxHQUFHO2dDQUNkLENBQUM7b0NBQ0krRixTQUFTLENBQUNsRCxLQUFLOzs7Ozs7NkNBRWlCaUcsZUFBZSxDQUFDcEksU0FBUyxFQUFFLENBQUM7b0NBQ3JEVixHQUFHLEVBQUhBLEdBQUc7b0NBQ0huSSxRQUFRLEVBQVJBLFFBQVE7b0NBQ1IrQixLQUFLLEVBQUxBLEtBQUs7Z0NBQ1QsQ0FBQzs7Z0NBSkRtTSxTQUFTLENBQUNsRCxLQUFLOzs7Ozs7Z0NBTWYzRyxPQUFPLENBQUNDLEtBQUssQ0FBQyxDQUF5QztnQ0FDdkQ0SixTQUFTLENBQUNsRCxLQUFLLEdBQUcsQ0FBQyxDQUFDOzs2REFHckJrRCxTQUFTOzs7O21FQUVKNEMsb0JBQW9CLEVBQUUsQ0FBQyxFQUFFdFQsUUFBUSxFQUFFSixPQUFPLHNCQUFnQyxHQUFHLENBQUNzQyxLQUFLLFdBQWdCLENBQUUsSUFBR00sUUFBUSxFQUFFK0IsS0FBSyxFQUFFcUQsRUFBRSxFQUFFaUksVUFBVSxFQUFFLElBQUk7Ozs7Ozs7Ozs7Ozs7OztnQkFFakssQ0FBQzs7OztZQUNLK0MsR0FBWSxFQUFaQSxDQUFZO21CQUFsQixRQUFRLENBQUZBLFlBQVksQ0FBQ3ZPLEtBQUssRUFBRTdCLFFBQVEsRUFBRStCLEtBQUssRUFBRXFELEVBQUUsRUFBRUMsVUFBVSxFQUFFZ0ksVUFBVSxFQUFFaE4sTUFBTSxFQUFFMkksU0FBUzs7aUVBQXhGLFFBQVEsV0FBa0YsQ0FBQzt3QkFFN0VrSSxpQkFBaUIsRUFJbkJDLGVBQWUsRUFNYmpELFNBQVMsRUFRUHJGLFNBQVMsRUFBR29DLE9BQU8sRUFBR0MsT0FBTyxFQUFHQyxPQUFPLEVBRW5DaUcsa0JBQWtCLEVBSzFCeEosUUFBUSxFQWFOb0QsS0FBSyxFQVdtQixHQUN6QixFQURPcUcsS0FBSyxFQUFHN0osSUFBSTs7Ozs7Z0NBakRsQjBKLGlCQUFpQixTQUFRcEcsVUFBVSxDQUFDakosS0FBSztzQ0FDM0N3TCxVQUFVLENBQUN6QyxPQUFPLElBQUlzRyxpQkFBaUIsVUFBU3JQLEtBQUssS0FBS0EsS0FBSzs7Ozs2REFDeERxUCxpQkFBaUI7O2dDQUV4QkMsZUFBZSxHQUFHeFEsU0FBUztnQ0FDL0IsRUFBc0M7Z0NBQ3RDLEVBQXVFO2dDQUN2RSxFQUFFLEVBdDVCZCxLQXM1QmdILEVBQUUsRUFFckc7MENBQ2lCd1EsZUFBZTs7Ozs7OzZDQUFlVixjQUFjLENBQUM1TyxLQUFLLEVBQUVzRixJQUFJLENBQUMsUUFBUSxDQUFQQyxHQUFHO29DQUFHLE1BQzNGLENBRDRGLENBQUM7d0NBQzVFeUIsU0FBUyxFQUFFekIsR0FBRyxDQUFDcEIsSUFBSTt3Q0FDbkJvRixXQUFXLEVBQUVoRSxHQUFHLENBQUNnRSxXQUFXO3dDQUM1QkgsT0FBTyxFQUFFN0QsR0FBRyxDQUFDa0ssR0FBRyxDQUFDckcsT0FBTzt3Q0FDeEJDLE9BQU8sRUFBRTlELEdBQUcsQ0FBQ2tLLEdBQUcsQ0FBQ3BHLE9BQU87d0NBQ3hCQyxPQUFPLElBQUkvRCxHQUFHLENBQUNrSyxHQUFHLENBQUNDLFlBQVk7b0NBQ25DLENBQUM7Ozs7O2dDQU5DckQsU0FBUztnQ0FRUHJGLFNBQVMsR0FBb0NxRixTQUFTLENBQXREckYsU0FBUyxFQUFHb0MsT0FBTyxHQUEwQmlELFNBQVMsQ0FBMUNqRCxPQUFPLEVBQUdDLE9BQU8sR0FBZ0JnRCxTQUFTLENBQWhDaEQsT0FBTyxFQUFHQyxPQUFPLEdBQU0rQyxTQUFTLENBQXRCL0MsT0FBTzt5Q0FDTixFQUFFLEU7Z0NBQy9CaUcsa0JBQWtCLEdBQU05VCxrSUFBTjtvQ0FDckI4VCxrQkFBa0IsQ0FBQ3ZJLFNBQVM7Ozs7Z0NBQzdCLEtBQUssQ0FBQyxHQUFHLENBQUNuSixLQUFLLENBQUUsQ0FBc0QseURBQVcsTUFBQyxDQUFWTSxRQUFRLEVBQUMsQ0FBQzs7O2dDQUkzRixFQUFFLEVBQUVpTCxPQUFPLElBQUlDLE9BQU8sSUFBSUMsT0FBTyxFQUFFLENBQUM7b0NBQ2hDdkQsUUFBUSxTQUFRYyxVQUFVLENBQUM4SSxXQUFXLENBQUMsQ0FBQzt3Q0FDcEM3TixJQUFJLEdBQUcsQ0FBQyxFQUFFckYsVUFBVSxFQUFFeUYsb0JBQW9CLENBQUMsQ0FBQzs0Q0FDeEMvRCxRQUFRLEVBQVJBLFFBQVE7NENBQ1IrQixLQUFLLEVBQUxBLEtBQUs7d0NBQ1QsQ0FBQzt3Q0FDRDBDLE1BQU0sRUFBRVksVUFBVTt3Q0FDbEJvTSxHQUFHLEVBQUV4RyxPQUFPO3dDQUNaeUcsR0FBRyxFQUFFdkcsT0FBTzt3Q0FDWjlLLE1BQU0sRUFBTkEsTUFBTTtvQ0FDVixDQUFDO2dDQUNMLENBQUM7OzZDQUN3QnNSLFFBQVEsQ0FBQyxRQUFRO29DQUFKMUcsTUFBTSxDQUFOQSxPQUFPLElBQUlDLE9BQU8sR0FBR3ZELGFBQWEsQ0FBQ0MsUUFBUSxRQUFPNkMsS0FBSyxFQUFFLEtBQUssRUFBRVEsT0FBTyxTQUFRL0IsR0FBRyxTQUFRQyxHQUFHLElBQUk4QixPQUFPLEtBQUtqQyxTQUFTLFVBQVNpSSxlQUFlLENBQUNwSSxTQUFTLEVBQzFMLENBQUM7d0NBQ0c3SSxRQUFRLEVBQVJBLFFBQVE7d0NBQ1IrQixLQUFLLEVBQUxBLEtBQUs7d0NBQ0wwQyxNQUFNLEVBQUVXLEVBQUU7d0NBQ1YvRSxNQUFNLEVBQU5BLE1BQU07d0NBQ05DLE9BQU8sUUFBT0EsT0FBTzt3Q0FDckJRLGFBQWEsUUFBT0EsYUFBYTtvQ0FDckMsQ0FBQzs7O2dDQVJDa0ssS0FBSztxQ0FVUEcsT0FBTzs7Ozs7NkNBQzhCd0csUUFBUSxDQUFDLFFBQVE7b0NBQUosTUFBTSxPQUFEQyxjQUFjLENBQUNoSyxRQUFROzs7Z0NBQXBELEdBQ3pCO2dDQURPeUosS0FBSyxHQUFhLEdBQ3pCLENBRE9BLEtBQUs7Z0NBQUc3SixJQUFJLEdBQU0sR0FDekIsQ0FEZUEsSUFBSTtnQ0FFcEJ3RCxLQUFLLENBQUNxRixTQUFTLEdBQUc5VCxNQUFNLENBQUNrRCxNQUFNLENBQUN1TCxLQUFLLENBQUNxRixTQUFTLEVBQUUsQ0FBQztvQ0FDOUN3QixxQkFBcUIsRUFBRXJLLElBQUk7b0NBQzNCc0ssZ0JBQWdCLEVBQUVULEtBQUs7Z0NBQzNCLENBQUM7O2dDQUVMbkQsU0FBUyxDQUFDbEQsS0FBSyxHQUFHQSxLQUFLO3NDQUNsQkYsVUFBVSxDQUFDakosS0FBSyxJQUFJcU0sU0FBUzs2REFDM0JBLFNBQVM7Ozs7bUVBRUo0QyxvQkFBb0IsRUFBRSxDQUFDLEVBQUV0VCxRQUFRLEVBQUV1VSxjQUFjLFdBQU8vUixRQUFRLEVBQUUrQixLQUFLLEVBQUVxRCxFQUFFLEVBQUVpSSxVQUFVOzs7Ozs7Ozs7OztnQkFFM0csQ0FBQzs7OztZQUNEcE8sR0FBRyxFQUFIQSxDQUFHO21CQUFIQSxRQUFRLENBQVJBLEdBQUcsQ0FBQ3VLLEtBQUssRUFBRWhDLElBQUksRUFBRW1ILFdBQVcsRUFBRSxDQUFDO2dCQUMzQixJQUFJLENBQUNuRixLQUFLLEdBQUdBLEtBQUs7Z0JBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUNpQyxHQUFHLENBQUNqRSxJQUFJLEVBQUUsSUFBSSxDQUFDc0QsVUFBVSxDQUFDLENBQU8sUUFBRWpDLFNBQVMsRUFBRThGLFdBQVc7WUFDekUsQ0FBQzs7O1lBQ0QsRUFHQzs7O0dBQUEsR0FBQ3FELEdBQWMsRUFBZEEsQ0FBYzttQkFBZEEsUUFBUSxDQUFSQSxjQUFjLENBQUNDLEVBQUUsRUFBRSxDQUFDO2dCQUNsQixJQUFJLENBQUN2SCxJQUFJLEdBQUd1SCxFQUFFO1lBQ2xCLENBQUM7OztZQUNEOUMsR0FBZSxFQUFmQSxDQUFlO21CQUFmQSxRQUFRLENBQVJBLGVBQWUsQ0FBQy9KLEVBQUUsRUFBRSxDQUFDO2dCQUNqQixFQUFFLEdBQUcsSUFBSSxDQUFDWCxNQUFNLEVBQUUsTUFBTSxDQUFDLEtBQUs7Z0JBQzlCLEdBQUssQ0FBMkIsR0FBc0Isa0JBQXRCLElBQUksQ0FBQ0EsTUFBTSxDQUFDTCxLQUFLLENBQUMsQ0FBRyxTQUE5QzhOLFlBQVksR0FBYSxHQUFzQixLQUFqQ0MsT0FBTyxHQUFJLEdBQXNCO2dCQUN0RCxHQUFLLENBQTJCL00sSUFBYSxrQkFBYkEsRUFBRSxDQUFDaEIsS0FBSyxDQUFDLENBQUcsU0FBckNnTyxZQUFZLEdBQWFoTixJQUFhLEtBQXhCaU4sT0FBTyxHQUFJak4sSUFBYTtnQkFDN0MsRUFBeUU7Z0JBQ3pFLEVBQUUsRUFBRWlOLE9BQU8sSUFBSUgsWUFBWSxLQUFLRSxZQUFZLElBQUlELE9BQU8sS0FBS0UsT0FBTyxFQUFFLENBQUM7b0JBQ2xFLE1BQU0sQ0FBQyxJQUFJO2dCQUNmLENBQUM7Z0JBQ0QsRUFBMEQ7Z0JBQzFELEVBQUUsRUFBRUgsWUFBWSxLQUFLRSxZQUFZLEVBQUUsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLEtBQUs7Z0JBQ2hCLENBQUM7Z0JBQ0QsRUFBeUQ7Z0JBQ3pELEVBQXVEO2dCQUN2RCxFQUEyRDtnQkFDM0QsRUFBbUM7Z0JBQ25DLE1BQU0sQ0FBQ0QsT0FBTyxLQUFLRSxPQUFPO1lBQzlCLENBQUM7OztZQUNEaEQsR0FBWSxFQUFaQSxDQUFZO21CQUFaQSxRQUFRLENBQVJBLFlBQVksQ0FBQ2pLLEVBQUUsRUFBRSxDQUFDO2dCQUNkLEdBQUssQ0FBaUJBLEdBQWEsa0JBQWJBLEVBQUUsQ0FBQ2hCLEtBQUssQ0FBQyxDQUFHLFNBQXpCVyxHQUFTLEdBQUlLLEdBQWEsS0FBMUJMLElBQUksR0FBSkEsR0FBUyxjQUFGLENBQUUsSUFBVEEsR0FBUztnQkFDbEIsRUFBZ0U7Z0JBQ2hFLEVBQXFCO2dCQUNyQixFQUFFLEVBQUVBLElBQUksS0FBSyxDQUFFLEtBQUlBLElBQUksS0FBSyxDQUFLLE1BQUUsQ0FBQztvQkFDaENzQixNQUFNLENBQUNpTSxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUM7b0JBQ3BCLE1BQU07Z0JBQ1YsQ0FBQztnQkFDRCxFQUErQztnQkFDL0MsR0FBSyxDQUFDQyxJQUFJLEdBQUc1QixRQUFRLENBQUM2QixjQUFjLENBQUN6TixJQUFJO2dCQUN6QyxFQUFFLEVBQUV3TixJQUFJLEVBQUUsQ0FBQztvQkFDUEEsSUFBSSxDQUFDRSxjQUFjO29CQUNuQixNQUFNO2dCQUNWLENBQUM7Z0JBQ0QsRUFBa0U7Z0JBQ2xFLEVBQXFCO2dCQUNyQixHQUFLLENBQUNDLE1BQU0sR0FBRy9CLFFBQVEsQ0FBQ2dDLGlCQUFpQixDQUFDNU4sSUFBSSxFQUFFLENBQUM7Z0JBQ2pELEVBQUUsRUFBRTJOLE1BQU0sRUFBRSxDQUFDO29CQUNUQSxNQUFNLENBQUNELGNBQWM7Z0JBQ3pCLENBQUM7WUFDTCxDQUFDOzs7WUFDRDlDLEdBQVEsRUFBUkEsQ0FBUTttQkFBUkEsUUFBUSxDQUFSQSxRQUFRLENBQUNsTCxNQUFNLEVBQUUsQ0FBQztnQkFDZCxNQUFNLENBQUMsSUFBSSxDQUFDQSxNQUFNLEtBQUtBLE1BQU07WUFDakMsQ0FBQzs7O1lBTU9tTyxHQUFRLEVBQVJBLENBQVE7bUJBTGhCLEVBS0M7Ozs7O0dBQUEsR0FBQyxRQUFRLENBQUZBLFFBQVEsQ0FBQ3RSLEdBQUc7b0JBQUVtRCxNQUFNLG9FQUFHbkQsR0FBRyxFQUFFdUksT0FBTyxvRUFBRyxDQUFDLENBQUM7O2lFQUE5QyxRQUFRLFdBQXdDLENBQUM7d0JBQzNDMkQsTUFBTSxFQUNKeE4sUUFBUSxFQUFHK0IsS0FBSyxFQU1WZ0wsUUFBUSxFQUNOQyxnQkFBZ0IsRUFNeEJySCxLQUFLLEVBQ1BOLFVBQVUsRUFFTm9JLFFBQVEsT0FFTkMsY0FBYyxFQXlCbEJtRixPQUFPLEVBbUJQaFIsS0FBSzs7OztnQ0EvRFAyTCxNQUFNLElBQUksQ0FBQyxFQUFFeFAsaUJBQWlCLEVBQUV3TSxnQkFBZ0IsQ0FBQ2xKLEdBQUc7Z0NBQ2xEdEIsUUFBUSxHQUFjd04sTUFBTSxDQUE1QnhOLFFBQVEsRUFBRytCLEtBQUssR0FBTXlMLE1BQU0sQ0FBakJ6TCxLQUFLO2dDQUN0QixFQUFFLEVBQUU1QyxLQUErQixFQUFFLEVBV3BDOzs2Q0FDd0J1SixVQUFVLENBQUM2RyxXQUFXOztnQ0FBekM1SixLQUFLO2dDQUNQTixVQUFVLEdBQUdaLE1BQU07d0NBQ3FDOzs7Ozs7O3dDQUVwQixDQUFDLEVBQUVsSCxZQUFZLEVBQUVpUyxzQkFBc0I7OztnQ0FBNUQvQixRQUFRLE9BQXBCaUMsVUFBVTs7Z0NBQ1BoQyxjQUFjLElBQUksQ0FBQyxFQUFFeFAsZ0JBQWdCLEVBQUVkLE9BQU8sQ0FBQ0wsV0FBVyxDQUFDSCxTQUFTLENBQUM2SCxNQUFNLFFBQU9wRSxNQUFNLElBQUlzRixLQUFLLEVBQUU4SCxRQUFRLEVBQUVELE1BQU0sQ0FBQ3pMLEtBQUssRUFBRSxRQUFRLENBQVA2TixDQUFDO29DQUFHbEssTUFBTSxDQUFOQSxtQkFBbUIsQ0FBQ2tLLENBQUMsRUFBRWpLLEtBQUs7eUNBQzNKckYsT0FBTztxQ0FDVm9OLGNBQWMsQ0FBQ21DLFlBQVk7Ozs7OztnQ0FHL0J4SyxVQUFVLEdBQUd4SSxTQUFTLENBQUNHLFdBQVcsQ0FBQzBRLGNBQWMsQ0FBQ2pKLE1BQU0sU0FBUXBFLE1BQU07Z0NBQ3RFLEVBQUUsRUFBRXFOLGNBQWMsQ0FBQ29DLFdBQVcsSUFBSXBDLGNBQWMsQ0FBQzFJLFlBQVksRUFBRSxDQUFDO29DQUM1RCxFQUFnRTtvQ0FDaEUsRUFBNEM7b0NBQzVDaEYsUUFBUSxHQUFHME4sY0FBYyxDQUFDMUksWUFBWTtvQ0FDdEN3SSxNQUFNLENBQUN4TixRQUFRLEdBQUdBLFFBQVE7b0NBQzFCc0IsR0FBRyxJQUFJLENBQUMsRUFBRWhELFVBQVUsRUFBRXlGLG9CQUFvQixDQUFDeUosTUFBTTtnQ0FDckQsQ0FBQzs7OztnQ0FDRSxDQUFDO29DQUNKQSxNQUFNLENBQUN4TixRQUFRLEdBQUcwRixtQkFBbUIsQ0FBQzhILE1BQU0sQ0FBQ3hOLFFBQVEsRUFBRTJGLEtBQUs7b0NBQzVELEVBQUUsRUFBRTZILE1BQU0sQ0FBQ3hOLFFBQVEsS0FBS0EsUUFBUSxFQUFFLENBQUM7d0NBQy9CQSxRQUFRLEdBQUd3TixNQUFNLENBQUN4TixRQUFRO3dDQUMxQndOLE1BQU0sQ0FBQ3hOLFFBQVEsR0FBR0EsUUFBUTt3Q0FDMUJzQixHQUFHLElBQUksQ0FBQyxFQUFFaEQsVUFBVSxFQUFFeUYsb0JBQW9CLENBQUN5SixNQUFNO29DQUNyRCxDQUFDO2dDQUNMLENBQUM7O3lDQUV3QyxFQUFFLEU7Ozs7NkNBR2hCdUMsaUJBQWlCLENBQUMsQ0FBQztvQ0FDMUMzSyxFQUFFLEVBQUVySSxXQUFXLENBQUMwSCxNQUFNO29DQUN0QnVMLEtBQUssRUFBRSxJQUFJO29DQUNYckssS0FBSyxFQUFMQSxLQUFLO29DQUNMM0YsUUFBUSxFQUFSQSxRQUFRO29DQUNSK0IsS0FBSyxFQUFMQSxLQUFLO29DQUNMMUIsTUFBTSxRQUFPQSxNQUFNO29DQUNuQjJJLFNBQVMsUUFBT0EsU0FBUztnQ0FDN0IsQ0FBQzs7Z0NBUks2SixPQUFPO2dDQVNiLEVBQUUsRUFBRUEsT0FBTyxDQUFDNUMsSUFBSSxLQUFLLENBQVMsVUFBRSxDQUFDO29DQUM3QnpDLE1BQU0sQ0FBQ3hOLFFBQVEsR0FBRzZTLE9BQU8sQ0FBQzdOLFlBQVk7b0NBQ3RDaEYsUUFBUSxHQUFHNlMsT0FBTyxDQUFDN04sWUFBWTtvQ0FDL0JqRCxLQUFLLHFCQUNFQSxLQUFLLEVBQ0w4USxPQUFPLENBQUM5RixRQUFRLENBQUNoTCxLQUFLO29DQUU3QnNELFVBQVUsR0FBR3dOLE9BQU8sQ0FBQ3BPLE1BQU07b0NBQzNCbkQsR0FBRyxJQUFJLENBQUMsRUFBRWhELFVBQVUsRUFBRXlGLG9CQUFvQixDQUFDeUosTUFBTTtnQ0FDckQsQ0FBQztnQ0FDSzNMLEtBQUssSUFBSSxDQUFDLEVBQUV4RSx1QkFBdUIsRUFBRXdJLHVCQUF1QixDQUFDN0YsUUFBUTs7dUNBQ3JFNk8sT0FBTyxDQUFDUyxHQUFHLENBQUMsQ0FBQzswQ0FDVjVHLFVBQVUsQ0FBQ29LLE1BQU0sQ0FBQ2pSLEtBQUssRUFBRXNGLElBQUksQ0FBQyxRQUFRLENBQVA0TCxLQUFLLEVBQUcsQ0FBQzt3Q0FDekMsTUFBTSxDQUFDQSxLQUFLLEdBQUdwTCxhQUFhLE9BQU1lLFVBQVUsQ0FBQzhJLFdBQVcsQ0FBQyxDQUFDOzRDQUN0RDdOLElBQUksRUFBRXJDLEdBQUc7NENBQ1RtRCxNQUFNLEVBQUVZLFVBQVU7NENBQ2xCb00sR0FBRyxFQUFFLElBQUk7NENBQ1RwUixNQUFNLEVBQUUsTUFBTSxDQUFDd0osT0FBTyxDQUFDeEosTUFBTSxLQUFLLENBQVcsYUFBR3dKLE9BQU8sQ0FBQ3hKLE1BQU0sU0FBUUEsTUFBTTt3Q0FDaEYsQ0FBQyxHQUFHLEtBQUssRUFBRSxLQUFLLFFBQU82SSxHQUFHLEVBQUUsSUFBSSxJQUFJLEtBQUs7b0NBQzdDLENBQUM7MENBQ0lSLFVBQVUsQ0FBQ21CLE9BQU8sQ0FBQ21KLFFBQVEsR0FBRyxDQUFVLFlBQUcsQ0FBVSxXQUFFblIsS0FBSztnQ0FDckUsQ0FBQzs7Ozs7O2dCQUNMLENBQUM7Ozs7WUFDSzRPLEdBQWMsRUFBZEEsQ0FBYzttQkFBcEIsUUFBUSxDQUFGQSxjQUFjLENBQUM1TyxLQUFLOztpRUFBMUIsUUFBUSxXQUFvQixDQUFDO3dCQUNyQmxDLFNBQVMsRUFDUHNULE1BQU0sRUFHTkMsZUFBZSxFQVdYQyxlQUFlOzs7O2dDQWZyQnhULFNBQVMsR0FBRyxLQUFLO2dDQUNmc1QsTUFBTSxTQUFRdkgsR0FBRyxHQUFHLFFBQ2hDLEdBRG9DLENBQUM7b0NBQzNCL0wsU0FBUyxHQUFHLElBQUk7Z0NBQ3BCLENBQUM7Z0NBQ0t1VCxlQUFlLEdBQUcsUUFDOUIsR0FEa0MsQ0FBQztvQ0FDekIsRUFBRSxFQUFFdlQsU0FBUyxFQUFFLENBQUM7d0NBQ1osR0FBSyxDQUFDMkUsS0FBSyxHQUFHLEdBQUcsQ0FBQzVFLEtBQUssQ0FBRSxDQUFxQyx3Q0FBUSxNQUFDLENBQVBtQyxLQUFLLEVBQUMsQ0FBQzt3Q0FDdkV5QyxLQUFLLENBQUMzRSxTQUFTLEdBQUcsSUFBSTt3Q0FDdEIsS0FBSyxDQUFDMkUsS0FBSztvQ0FDZixDQUFDO29DQUNELEVBQUUsRUFBRTJPLE1BQU0sV0FBVXZILEdBQUcsRUFBRSxDQUFDOzhDQUNqQkEsR0FBRyxHQUFHLElBQUk7b0NBQ25CLENBQUM7Z0NBQ0wsQ0FBQzs7OzZDQUVzQ2hELFVBQVUsQ0FBQzBLLFFBQVEsQ0FBQ3ZSLEtBQUs7O2dDQUF0RHNSLGVBQWU7Z0NBQ3JCRCxlQUFlOzZEQUNSQyxlQUFlOzs7O2dDQUV0QkQsZUFBZTtnQ0FDZixLQUFLOzs7Ozs7Ozs7OztnQkFFYixDQUFDOzs7O1lBQ0R2QixHQUFRLEVBQVJBLENBQVE7bUJBQVJBLFFBQVEsQ0FBUkEsUUFBUSxDQUFDMEIsRUFBRSxFQUFFLENBQUM7O2dCQUNWLEdBQUcsQ0FBQzFULFNBQVMsR0FBRyxLQUFLO2dCQUNyQixHQUFLLENBQUNzVCxNQUFNLEdBQUcsUUFDckIsR0FEeUIsQ0FBQztvQkFDaEJ0VCxTQUFTLEdBQUcsSUFBSTtnQkFDcEIsQ0FBQztnQkFDRCxJQUFJLENBQUMrTCxHQUFHLEdBQUd1SCxNQUFNO2dCQUNqQixNQUFNLENBQUNJLEVBQUUsR0FBR2xNLElBQUksQ0FBQyxRQUFRLENBQVBLLElBQUksRUFBRyxDQUFDO29CQUN0QixFQUFFLEVBQUV5TCxNQUFNLFdBQVV2SCxHQUFHLEVBQUUsQ0FBQzs4QkFDakJBLEdBQUcsR0FBRyxJQUFJO29CQUNuQixDQUFDO29CQUNELEVBQUUsRUFBRS9MLFNBQVMsRUFBRSxDQUFDO3dCQUNaLEdBQUssQ0FBQ3dJLEdBQUcsR0FBRyxHQUFHLENBQUN6SSxLQUFLLENBQUMsQ0FBaUM7d0JBQ3ZEeUksR0FBRyxDQUFDeEksU0FBUyxHQUFHLElBQUk7d0JBQ3BCLEtBQUssQ0FBQ3dJLEdBQUc7b0JBQ2IsQ0FBQztvQkFDRCxNQUFNLENBQUNYLElBQUk7Z0JBQ2YsQ0FBQztZQUNMLENBQUM7OztZQUNEb0ssR0FBYyxFQUFkQSxDQUFjO21CQUFkQSxRQUFRLENBQVJBLGNBQWMsQ0FBQ2hLLFFBQVEsRUFBRSxDQUFDO2dCQUN0QixFQUFvRTtnQkFDcEUsTUFBTSxDQUFDRCxhQUFhLENBQUNDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQ3NCLEdBQUcsRUFBRSxLQUFLLEVBQUUvQixJQUFJLENBQUMsUUFBUSxDQUFQbU0sVUFBVSxFQUFHLENBQUM7b0JBQzVFLE1BQU0sQ0FBQyxDQUFDO3dCQUNKakMsS0FBSyxFQUFFLElBQUk7d0JBQ1g3SixJQUFJLEVBQUU4TCxVQUFVO29CQUNwQixDQUFDO2dCQUNMLENBQUM7WUFDTCxDQUFDOzs7WUFDS3ZELEdBQWlCLEVBQWpCQSxDQUFpQjttQkFBdkIsUUFBUSxDQUFGQSxpQkFBaUIsQ0FBQ2xHLE9BQU87O2lFQUEvQixRQUFRLFdBQXlCLENBQUM7d0JBQ3hCL0gsVUFBVSxFQUNWd0wsU0FBUyxFQUNUaUcsR0FBRyxFQUNIQyxpQkFBaUIsRUFRbkJDLFNBQVMsRUF1QkhqRyxNQUFNLEVBQ05rRyxVQUFVLEVBQ1o1RCxXQUFXLEVBQ1g5SyxZQUFZLEVBb0JOMk8sYUFBYSxFQUNrQnhPLEdBQWdELEVBQXhFa0osTUFBTSxFQUFPQyxLQUFLOzs7O2dDQTFEakN4TSxVQUFVLEdBQUc3QixlQUFlLENBQUM0SixPQUFPLENBQUN6RSxFQUFFO2dDQUN2Q2tJLFNBQVMsR0FBR3pRLFNBQVMsQ0FBQ0MsV0FBVyxDQUFDZ0YsVUFBVSxJQUFJOUUsV0FBVyxDQUFDOEUsVUFBVSxJQUFJQSxVQUFVLEVBQUUrSCxPQUFPLENBQUN4SixNQUFNOzs2Q0FDbkZxSSxVQUFVLENBQUMrRyxpQkFBaUI7O2dDQUE3QzhELEdBQUc7Z0NBQ0hDLGlCQUFpQixHQUFHRCxHQUFHLENBQUN4TixJQUFJLENBQUMsUUFBUSxRQUFlLENBQUM7MkVBQXRCNk4sVUFBVSxjQUFFQyxLQUFLO29DQUNsRCxNQUFNLEVBQUUsQ0FBQyxFQUFFMVYsYUFBYSxFQUFFbUUsZUFBZSxFQUFFLENBQUMsRUFBRWpFLG1CQUFtQixFQUFFeVYsa0JBQWtCLENBQUNGLFVBQVUsR0FBR0MsS0FBSyxHQUFHdkcsU0FBUztnQ0FDeEgsQ0FBQztvQ0FDSWtHLGlCQUFpQjs7Ozs2REFDWCxDQUFDO29DQUNKdkQsSUFBSSxFQUFFLENBQU07Z0NBQ2hCLENBQUM7Ozs7OzZDQUlzQjhELGlCQUFpQixDQUFDLENBQUM7b0NBQ3RDQyxhQUFhLEVBQUVuSyxPQUFPLENBQUN6RSxFQUFFO29DQUN6QjZPLFdBQVcsRUFBRXBLLE9BQU8sQ0FBQ21HLEtBQUs7b0NBQzFCaEgsU0FBUyxFQUFFYSxPQUFPLENBQUNiLFNBQVM7Z0NBQ2hDLENBQUM7O2dDQUpEeUssU0FBUzs7Ozs7OzZEQU9GLENBQUM7b0NBQ0p4RCxJQUFJLEVBQUUsQ0FBVTtvQ0FDaEI5QixXQUFXLEVBQUV0RSxPQUFPLENBQUN6RSxFQUFFO2dDQUMzQixDQUFDOztxQ0FFRHFPLFNBQVMsQ0FBQ1MsT0FBTzs7OztvQ0FHWlQsU0FBUyxDQUFDUyxPQUFPLENBQUNuVSxVQUFVLENBQUMsQ0FBRzs7Ozs2REFDMUIsQ0FBQztvQ0FDSmtRLElBQUksRUFBRSxDQUFVO29DQUNoQjlCLFdBQVcsRUFBRXRFLE9BQU8sQ0FBQ3pFLEVBQUU7Z0NBQzNCLENBQUM7O2dDQUVDb0ksTUFBTSxJQUFJLENBQUMsRUFBRXhQLGlCQUFpQixFQUFFd00sZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFN00sb0JBQW9CLEVBQUU2QyxtQkFBbUIsQ0FBQzFELFdBQVcsQ0FBQzJXLFNBQVMsQ0FBQ1MsT0FBTyxJQUFJbFgsV0FBVyxDQUFDeVcsU0FBUyxDQUFDUyxPQUFPLElBQUlULFNBQVMsQ0FBQ1MsT0FBTyxRQUFPNVQsT0FBTyxFQUFFTixRQUFRO2dDQUMxTTBULFVBQVUsSUFBSSxDQUFDLEVBQUVyVyx1QkFBdUIsRUFBRXdJLHVCQUF1QixDQUFDMkgsTUFBTSxDQUFDeE4sUUFBUTs7O2dDQUd2RixFQUFFLEVBQUU2SixPQUFPLENBQUNsRSxLQUFLLENBQUNsQyxRQUFRLENBQUNpUSxVQUFVLEdBQUcsQ0FBQztvQ0FDckM1RCxXQUFXLEdBQUcsSUFBSTtvQ0FDbEI5SyxZQUFZLEdBQUcwTyxVQUFVO2dDQUM3QixDQUFDLE1BQU0sQ0FBQztvQ0FDSjFPLFlBQVksR0FBR1UsbUJBQW1CLENBQUNnTyxVQUFVLEVBQUU3SixPQUFPLENBQUNsRSxLQUFLO29DQUM1RCxFQUFFLEVBQUVYLFlBQVksS0FBS3dJLE1BQU0sQ0FBQ3hOLFFBQVEsSUFBSTZKLE9BQU8sQ0FBQ2xFLEtBQUssQ0FBQ2xDLFFBQVEsQ0FBQ3VCLFlBQVksR0FBRyxDQUFDO3dDQUMzRThLLFdBQVcsR0FBRyxJQUFJO29DQUN0QixDQUFDO2dDQUNMLENBQUM7NkRBQ00sQ0FBQztvQ0FDSkcsSUFBSSxFQUFFLENBQVM7b0NBQ2Z4TCxNQUFNLEVBQUUrSSxNQUFNLENBQUN4TixRQUFRO29DQUN2QitNLFFBQVEsRUFBRVMsTUFBTTtvQ0FDaEJzQyxXQUFXLEVBQVhBLFdBQVc7b0NBQ1g5SyxZQUFZLEVBQVpBLFlBQVk7Z0NBQ2hCLENBQUM7O3FDQUVEeU8sU0FBUyxDQUFDVSxRQUFROzs7O3FDQUNkVixTQUFTLENBQUNVLFFBQVEsQ0FBQ3BVLFVBQVUsQ0FBQyxDQUFHOzs7O2dDQUMzQjRULGFBQWEsSUFBSSxDQUFDLEVBQUV0Vyx1QkFBdUIsRUFBRXdJLHVCQUF1QixFQUFFLENBQUMsRUFBRWxJLG9CQUFvQixFQUFFNkMsbUJBQW1CLENBQUMxRCxXQUFXLENBQUMyVyxTQUFTLENBQUNVLFFBQVEsSUFBSW5YLFdBQVcsQ0FBQ3lXLFNBQVMsQ0FBQ1UsUUFBUSxJQUFJVixTQUFTLENBQUNVLFFBQVEsUUFBTzdULE9BQU8sRUFBRU4sUUFBUTtnQ0FDbE1tRixHQUFnRCxHQUFoREEsWUFBWSxRQUFPd08sYUFBYSxFQUFFQSxhQUFhLEdBQXZFdEYsTUFBTSxHQUFrQmxKLEdBQWdELENBQTdFN0QsR0FBRyxFQUFlZ04sS0FBSyxHQUFNbkosR0FBZ0QsQ0FBL0RDLEVBQUU7NkRBQ2pCLENBQUM7b0NBQ0o2SyxJQUFJLEVBQUUsQ0FBVTtvQ0FDaEI1QixNQUFNLEVBQU5BLE1BQU07b0NBQ05DLEtBQUssRUFBTEEsS0FBSztnQ0FDVCxDQUFDOzs2REFFRSxDQUFDO29DQUNKMkIsSUFBSSxFQUFFLENBQVU7b0NBQ2hCOUIsV0FBVyxFQUFFc0YsU0FBUyxDQUFDVSxRQUFRO2dDQUNuQyxDQUFDOztzQ0FHRFYsU0FBUyxDQUFDVyxPQUFPLEtBQUtYLFNBQVMsQ0FBQ1ksR0FBRzs7Ozs2REFDNUIsQ0FBQztvQ0FDSnBFLElBQUksRUFBRSxDQUFTO2dDQUNuQixDQUFDOzs2REFFRSxDQUFDO29DQUNKQSxJQUFJLEVBQUUsQ0FBTTtnQ0FDaEIsQ0FBQzs7Ozs7Ozs7Ozs7Z0JBQ0wsQ0FBQzs7OztZQUNEOEQsR0FBaUIsRUFBakJBLENBQWlCO21CQUFqQkEsUUFBUSxDQUFSQSxpQkFBaUIsQ0FBQ3hSLE1BQU0sRUFBRSxDQUFDOztnQkFDdkIsR0FBSyxDQUFHeVIsYUFBYSxHQUF1Q3pSLE1BQU0sQ0FBMUR5UixhQUFhLGlCQUF1Q3pSLE1BQU0sQ0FBMUMwUixXQUFXLEVBQVhBLFdBQVcsNkJBQUUsS0FBSyxpQkFBR2pMLFNBQVMsR0FBTXpHLE1BQU0sQ0FBckJ5RyxTQUFTO2dCQUN0RCxHQUFLLENBQXVCLEdBQTRDLEdBQTVDLEdBQUcsQ0FBQ3RILEdBQUcsQ0FBQ3NTLGFBQWEsRUFBRTNOLE1BQU0sQ0FBQzJCLFFBQVEsQ0FBQ3JFLElBQUksR0FBekRzRSxRQUFRLEdBQU0sR0FBNEMsQ0FBaEV0RSxJQUFJO2dCQUNaLEVBQUUsRUEzdENWLEtBMnRDb0csRUFBRSxFQUU3RjtnQkFDRCxNQUFNLENBQUNzRCxLQUFLLENBQUMrTSxhQUFhLEVBQUUsQ0FBQztvQkFDekJySCxNQUFNLEVBQUUsQ0FBTTtvQkFDZHpGLFdBQVcsRUFBRSxDQUFhO29CQUMxQnFOLE9BQU8sRUFBRSxDQUFDO3dCQUNOLENBQXdCLHlCQUFFLENBQUc7b0JBQ2pDLENBQUM7Z0JBQ0wsQ0FBQyxFQUFFcE4sSUFBSSxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7b0JBQ1osRUFBRSxHQUFHQSxHQUFHLENBQUNDLEVBQUUsRUFBRSxDQUFDO3dCQUNWLEtBQUssQ0FBQyxHQUFHLENBQUMzSCxLQUFLLENBQUUsQ0FBMkI7b0JBQ2hELENBQUM7b0JBQ0QsTUFBTSxDQUFDLENBQUM7d0JBQ0pzUSxLQUFLLEVBQUU1SSxHQUFHLENBQUNtTixPQUFPLENBQUN2VixHQUFHLENBQUMsQ0FBb0I7d0JBQzNDbVYsUUFBUSxFQUFFL00sR0FBRyxDQUFDbU4sT0FBTyxDQUFDdlYsR0FBRyxDQUFDLENBQVU7d0JBQ3BDb1YsT0FBTyxFQUFFaE4sR0FBRyxDQUFDbU4sT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBc0I7d0JBQy9DTixPQUFPLEVBQUU5TSxHQUFHLENBQUNtTixPQUFPLENBQUN2VixHQUFHLENBQUMsQ0FBc0I7d0JBQy9DcVYsR0FBRyxJQUFJak4sR0FBRyxDQUFDbU4sT0FBTyxDQUFDdlYsR0FBRyxDQUFDLENBQWtCO29CQUM3QyxDQUFDO2dCQUNMLENBQUMsRUFBRW1JLElBQUksQ0FBQyxRQUFRLENBQVBLLElBQUksRUFBRyxDQUFDO29CQUNiLEVBQUUsRUFBRXlNLFdBQVcsSUFBSXpNLElBQUksQ0FBQ3dJLEtBQUssS0FBSyxDQUFVLFdBQUUsQ0FBQzs4QkFDdEM1RyxHQUFHLENBQUNuQixRQUFRLElBQUlULElBQUk7b0JBQzdCLENBQUM7b0JBQ0QsTUFBTSxDQUFDQSxJQUFJO2dCQUNmLENBQUMsRUFBRVUsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFHLENBQUM7b0JBQ2IsTUFBTSxPQUFNaUIsR0FBRyxDQUFDbkIsUUFBUTtvQkFDeEIsS0FBSyxDQUFDRSxHQUFHO2dCQUNiLENBQUM7WUFDTCxDQUFDOzs7WUFDRDhJLEdBQWUsRUFBZkEsQ0FBZTttQkFBZkEsUUFBUSxDQUFSQSxlQUFlLENBQUNwSSxTQUFTLEVBQUU0TCxHQUFHLEVBQUUsQ0FBQztnQkFDN0IsR0FBSyxDQUF1QixHQUF3QixHQUF4QixJQUFJLENBQUMzSixVQUFVLENBQUMsQ0FBTyxTQUFoQ25DLEdBQUcsR0FBTSxHQUF3QixDQUE1Q0UsU0FBUztnQkFDakIsR0FBSyxDQUFDNkwsT0FBTyxHQUFHLElBQUksQ0FBQy9JLFFBQVEsQ0FBQ2hELEdBQUc7Z0JBQ2pDOEwsR0FBRyxDQUFDQyxPQUFPLEdBQUdBLE9BQU87Z0JBQ3JCLE1BQU0sRUFBRSxDQUFDLEVBQUU1VyxNQUFNLEVBQUU2VyxtQkFBbUIsQ0FBQ2hNLEdBQUcsRUFBRSxDQUFDO29CQUN6QytMLE9BQU8sRUFBUEEsT0FBTztvQkFDUDdMLFNBQVMsRUFBVEEsU0FBUztvQkFDVG5GLE1BQU0sRUFBRSxJQUFJO29CQUNaK1EsR0FBRyxFQUFIQSxHQUFHO2dCQUNQLENBQUM7WUFDTCxDQUFDOzs7WUFDRHZGLEdBQWtCLEVBQWxCQSxDQUFrQjttQkFBbEJBLFFBQVEsQ0FBUkEsa0JBQWtCLENBQUM5SixFQUFFLEVBQUVpSSxVQUFVLEVBQUUsQ0FBQztnQkFDaEMsRUFBRSxFQUFFLElBQUksQ0FBQzNCLEdBQUcsRUFBRSxDQUFDO29CQUNYckQsTUFBTSxDQUFDZ0QsTUFBTSxDQUFDK0QsSUFBSSxDQUFDLENBQWtCLG1CQUFFNVAsc0JBQXNCLElBQUk0RixFQUFFLEVBQUVpSSxVQUFVO29CQUMvRSxJQUFJLENBQUMzQixHQUFHO29CQUNSLElBQUksQ0FBQ0EsR0FBRyxHQUFHLElBQUk7Z0JBQ25CLENBQUM7WUFDTCxDQUFDOzs7WUFDRzdKLEdBQUssRUFBTEEsQ0FBSztpQkFBVCxRQUFRLE9BQUksQ0FBQztnQkFDVCxNQUFNLENBQUMsSUFBSSxDQUFDMkgsS0FBSyxDQUFDM0gsS0FBSztZQUMzQixDQUFDOzs7WUFDRzdCLEdBQVEsRUFBUkEsQ0FBUTtpQkFBWixRQUFRLE9BQU8sQ0FBQztnQkFDWixNQUFNLENBQUMsSUFBSSxDQUFDd0osS0FBSyxDQUFDeEosUUFBUTtZQUM5QixDQUFDOzs7WUFDRytCLEdBQUssRUFBTEEsQ0FBSztpQkFBVCxRQUFRLE9BQUksQ0FBQztnQkFDVCxNQUFNLENBQUMsSUFBSSxDQUFDeUgsS0FBSyxDQUFDekgsS0FBSztZQUMzQixDQUFDOzs7WUFDRzBDLEdBQU0sRUFBTkEsQ0FBTTtpQkFBVixRQUFRLE9BQUssQ0FBQztnQkFDVixNQUFNLENBQUMsSUFBSSxDQUFDK0UsS0FBSyxDQUFDL0UsTUFBTTtZQUM1QixDQUFDOzs7WUFDR3BFLEdBQU0sRUFBTkEsQ0FBTTtpQkFBVixRQUFRLE9BQUssQ0FBQztnQkFDVixNQUFNLENBQUMsSUFBSSxDQUFDbUosS0FBSyxDQUFDbkosTUFBTTtZQUM1QixDQUFDOzs7WUFDRzBJLEdBQVUsRUFBVkEsQ0FBVTtpQkFBZCxRQUFRLE9BQVMsQ0FBQztnQkFDZCxNQUFNLENBQUMsSUFBSSxDQUFDUyxLQUFLLENBQUNULFVBQVU7WUFDaEMsQ0FBQzs7O1lBQ0dDLEdBQVMsRUFBVEEsQ0FBUztpQkFBYixRQUFRLE9BQVEsQ0FBQztnQkFDYixNQUFNLENBQUMsSUFBSSxDQUFDUSxLQUFLLENBQUNSLFNBQVM7WUFDL0IsQ0FBQzs7Ozs7QUFFTHZNLGtCQUFlLEdBQUc0TCxNQUFNO0FBQ3hCQSxNQUFNLENBQUNnRCxNQUFNLElBQUksQ0FBQyxFQUFFek4sS0FBSyxFQUFFUixPQUFPLEdBRWxDLENBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzPzg2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldERvbWFpbkxvY2FsZSA9IGdldERvbWFpbkxvY2FsZTtcbmV4cG9ydHMuYWRkTG9jYWxlID0gYWRkTG9jYWxlO1xuZXhwb3J0cy5kZWxMb2NhbGUgPSBkZWxMb2NhbGU7XG5leHBvcnRzLmhhc0Jhc2VQYXRoID0gaGFzQmFzZVBhdGg7XG5leHBvcnRzLmFkZEJhc2VQYXRoID0gYWRkQmFzZVBhdGg7XG5leHBvcnRzLmRlbEJhc2VQYXRoID0gZGVsQmFzZVBhdGg7XG5leHBvcnRzLmlzTG9jYWxVUkwgPSBpc0xvY2FsVVJMO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUFzID0gaW50ZXJwb2xhdGVBcztcbmV4cG9ydHMucmVzb2x2ZUhyZWYgPSByZXNvbHZlSHJlZjtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9yb3V0ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xudmFyIF9pc0Vycm9yID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX2Rlbm9ybWFsaXplUGFnZVBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL21pdHRcIikpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBfaXNEeW5hbWljID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcGFyc2VSZWxhdGl2ZVVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi91dGlscy9xdWVyeXN0cmluZ1wiKTtcbnZhciBfcmVzb2x2ZVJld3JpdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLXJld3JpdGVzXCIpKTtcbnZhciBfcm91dGVNYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcbnZhciBfcm91dGVSZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xudmFyIF9nZXRNaWRkbGV3YXJlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbWlkZGxld2FyZS1yZWdleFwiKTtcbnZhciBfZm9ybWF0VXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3T2JqID0ge307XG4gICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG59XG5sZXQgZGV0ZWN0RG9tYWluTG9jYWxlO1xuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBkZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykuZGV0ZWN0RG9tYWluTG9jYWxlO1xufVxuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHBhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGAke3ByZWZpeH0ke3BhdGhuYW1lfWApICsgcGF0aC5zbGljZShwYXRobmFtZS5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGxvY2FsZSA9IGxvY2FsZSB8fCAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbG9jYWxlKTtcbiAgICAgICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICAgICAgICByZXR1cm4gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke2Jhc2VQYXRoIHx8ICcnfSR7bG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bG9jYWxlfWB9JHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRMb2NhbGUocGF0aCwgbG9jYWxlLCBkZWZhdWx0TG9jYWxlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwYXRoTm9RdWVyeUhhc2gocGF0aCk7XG4gICAgICAgIGNvbnN0IHBhdGhMb3dlciA9IHBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsZUxvd2VyID0gbG9jYWxlICYmIGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJiAhcGF0aExvd2VyLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlTG93ZXIgKyAnLycpICYmIHBhdGhMb3dlciAhPT0gJy8nICsgbG9jYWxlTG93ZXIgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSkgOiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGRlbExvY2FsZShwYXRoLCBsb2NhbGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCBwYXRobmFtZSA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKTtcbiAgICAgICAgY29uc3QgcGF0aExvd2VyID0gcGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgJiYgbG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb2NhbGUgJiYgKHBhdGhMb3dlci5zdGFydHNXaXRoKCcvJyArIGxvY2FsZUxvd2VyICsgJy8nKSB8fCBwYXRoTG93ZXIgPT09ICcvJyArIGxvY2FsZUxvd2VyKSA/IChwYXRobmFtZS5sZW5ndGggPT09IGxvY2FsZS5sZW5ndGggKyAxID8gJy8nIDogJycpICsgcGF0aC5zbGljZShsb2NhbGUubGVuZ3RoICsgMSkgOiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIHBhdGhOb1F1ZXJ5SGFzaChwYXRoKSB7XG4gICAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICAgIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICAgIGlmIChxdWVyeUluZGV4ID4gLTEgfHwgaGFzaEluZGV4ID4gLTEpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aE5vUXVlcnlIYXNoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoID09PSBiYXNlUGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgoYmFzZVBhdGggKyAnLycpO1xufVxuZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aCkge1xuICAgIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gICAgcmV0dXJuIGFkZFBhdGhQcmVmaXgocGF0aCwgYmFzZVBhdGgpO1xufVxuZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aCk7XG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkgcGF0aCA9IGAvJHtwYXRofWA7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBpc0xvY2FsVVJMKHVybCkge1xuICAgIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnIycpIHx8IHVybC5zdGFydHNXaXRoKCc/JykpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgICAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSB7XG4gICAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJyc7XG4gICAgY29uc3QgZHluYW1pY1JlZ2V4ID0gKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHJvdXRlKTtcbiAgICBjb25zdCBkeW5hbWljR3JvdXBzID0gZHluYW1pY1JlZ2V4Lmdyb3VwcztcbiAgICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9IC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgOiAnJykgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgJyc7XG4gICAgICAgIGNvbnN0IHsgcmVwZWF0ICwgb3B0aW9uYWwgIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYDtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KVxuICAgICAgICApLmpvaW4oJy8nKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpIHx8ICcvJyk7XG4gICAgfSkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuICAgICAgICA7XG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGVcbiAgICB9O1xufVxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBmaWx0ZXJlZFF1ZXJ5ID0ge307XG4gICAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgaWYgKCFwYXJhbXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgZmlsdGVyZWRRdWVyeVtrZXldID0gcXVlcnlba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZFF1ZXJ5O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUhyZWYocm91dGVyLCBocmVmLCByZXNvbHZlQXMpIHtcbiAgICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICAgIGxldCBiYXNlO1xuICAgIGxldCB1cmxBc1N0cmluZyA9IHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZik7XG4gICAgLy8gcmVwZWF0ZWQgc2xhc2hlcyBhbmQgYmFja3NsYXNoZXMgaW4gdGhlIFVSTCBhcmUgY29uc2lkZXJlZFxuICAgIC8vIGludmFsaWQgYW5kIHdpbGwgbmV2ZXIgbWF0Y2ggYSBOZXh0LmpzIHBhZ2UvZmlsZVxuICAgIGNvbnN0IHVybFByb3RvTWF0Y2ggPSB1cmxBc1N0cmluZy5tYXRjaCgvXlthLXpBLVpdezEsfTpcXC9cXC8vKTtcbiAgICBjb25zdCB1cmxBc1N0cmluZ05vUHJvdG8gPSB1cmxQcm90b01hdGNoID8gdXJsQXNTdHJpbmcuc2xpY2UodXJsUHJvdG9NYXRjaFswXS5sZW5ndGgpIDogdXJsQXNTdHJpbmc7XG4gICAgY29uc3QgdXJsUGFydHMgPSB1cmxBc1N0cmluZ05vUHJvdG8uc3BsaXQoJz8nKTtcbiAgICBpZiAoKHVybFBhcnRzWzBdIHx8ICcnKS5tYXRjaCgvKFxcL1xcL3xcXFxcKS8pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgaHJlZiBwYXNzZWQgdG8gbmV4dC9yb3V0ZXI6ICR7dXJsQXNTdHJpbmd9LCByZXBlYXRlZCBmb3J3YXJkLXNsYXNoZXMgKC8vKSBvciBiYWNrc2xhc2hlcyBcXFxcIGFyZSBub3QgdmFsaWQgaW4gdGhlIGhyZWZgKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9ICgwLCBfdXRpbHMpLm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyh1cmxBc1N0cmluZ05vUHJvdG8pO1xuICAgICAgICB1cmxBc1N0cmluZyA9ICh1cmxQcm90b01hdGNoID8gdXJsUHJvdG9NYXRjaFswXSA6ICcnKSArIG5vcm1hbGl6ZWRVcmw7XG4gICAgfVxuICAgIC8vIFJldHVybiBiZWNhdXNlIGl0IGNhbm5vdCBiZSByb3V0ZWQgYnkgdGhlIE5leHQuanMgcm91dGVyXG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybEFzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiYXNlID0gbmV3IFVSTCh1cmxBc1N0cmluZy5zdGFydHNXaXRoKCcjJykgPyByb3V0ZXIuYXNQYXRoIDogcm91dGVyLnBhdGhuYW1lLCAnaHR0cDovL24nKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIC8gZm9yIGludmFsaWQgYXNQYXRoIHZhbHVlcyBlLmcuIC8vXG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKCcvJywgJ2h0dHA6Ly9uJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSk7XG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSk7XG4gICAgICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnO1xuICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKGZpbmFsVXJsLnBhdGhuYW1lKSAmJiBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiYgcmVzb2x2ZUFzKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9ICgwLCBfcXVlcnlzdHJpbmcpLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0ICwgcGFyYW1zICB9ID0gaW50ZXJwb2xhdGVBcyhmaW5hbFVybC5wYXRobmFtZSwgZmluYWxVcmwucGF0aG5hbWUsIHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRBcyA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGZpbmFsVXJsLmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luIGRpZG4ndCBjaGFuZ2UsIGl0IG1lYW5zIHdlIHJlY2VpdmVkIGEgcmVsYXRpdmUgaHJlZlxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmaW5hbFVybC5vcmlnaW4gPT09IGJhc2Uub3JpZ2luID8gZmluYWxVcmwuaHJlZi5zbGljZShmaW5hbFVybC5vcmlnaW4ubGVuZ3RoKSA6IGZpbmFsVXJsLmhyZWY7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgXSA6IHJlc29sdmVkSHJlZjtcbiAgICB9IGNhdGNoIChfMSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgY29uc3QgaHJlZkhhZE9yaWdpbiA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNIYWRPcmlnaW4gPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlSHJlZihyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNIYWRPcmlnaW4gPyBwcmVwYXJlZEFzIDogYWRkQmFzZVBhdGgocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX2Rlbm9ybWFsaXplUGFnZVBhdGgpLmRlbm9ybWFsaXplUGFnZVBhdGgocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGFnZSkgJiYgKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gJ19fbmV4dCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge31cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJyk7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdHMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gICAgfSkudGhlbigocmVzKT0+e1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzLnRleHQgPyByZXMudGV4dCgpIDogcmVzLmpzb24oKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyLCB0ZXh0LCBpbmZsaWdodENhY2hlLCBwZXJzaXN0Q2FjaGUpIHtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICB0ZXh0XG4gICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgICAgIC8vIGxvb3AuXG4gICAgICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLm1hcmtBc3NldEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn1cbmNsYXNzIFJvdXRlciB7XG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUxLCBxdWVyeTEsIGFzMSwgeyBpbml0aWFsUHJvcHMgLCBwYWdlTG9hZGVyICwgQXBwICwgd3JhcEFwcCAsIENvbXBvbmVudCAsIGVyciAsIHN1YnNjcmlwdGlvbiAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZGVmYXVsdExvY2FsZSAsIGRvbWFpbkxvY2FsZXMgLCBpc1ByZXZpZXcgLCBpc1JzYyAgfSl7XG4gICAgICAgIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gICAgICAgIHRoaXMuc2RjID0ge307XG4gICAgICAgIC8vIEluLWZsaWdodCBTZXJ2ZXIgRGF0YSBSZXF1ZXN0cywgZm9yIGRlZHVwaW5nXG4gICAgICAgIHRoaXMuc2RyID0ge307XG4gICAgICAgIC8vIEluLWZsaWdodCBtaWRkbGV3YXJlIHByZWZsaWdodCByZXF1ZXN0c1xuICAgICAgICB0aGlzLnNkZSA9IHt9O1xuICAgICAgICB0aGlzLl9pZHggPSAwO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgICAgICAgICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdyZXBsYWNlU3RhdGUnLCAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzKS5nZXRVUkwoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2VkU2Nyb2xsO1xuICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBhcyAsIG9wdGlvbnMgLCBpZHggIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAge31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faWR4ID0gaWR4O1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgICAgICAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSBhZGRCYXNlUGF0aCh0aGlzLmFzUGF0aCkgJiYgcGF0aG5hbWUgPT09IGFkZEJhc2VQYXRoKHRoaXMucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZTEpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUxICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgICAgICAgICAgICBfX05fUlNDOiAhIWlzUnNjXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGF0aG5hbWUxKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydDtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISFkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lMSxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeTEsXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUxIDogYXMxLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiAhIWlzUHJldmlldyxcbiAgICAgICAgICAgIGxvY2FsZTogcHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCA/IGxvY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmICghYXMxLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhczEgIT09IHBhdGhuYW1lMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdyZXBsYWNlU3RhdGUnLCAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUxKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5MVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzKS5nZXRVUkwoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVsb2FkKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovIGJhY2soKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2lkeCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRSZXNvbHZlSHJlZiA9IG9wdGlvbnMuX2ggfHwgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgfHwgcGF0aE5vUXVlcnlIYXNoKHVybCkgPT09IHBhdGhOb1F1ZXJ5SGFzaChhcyk7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICBpZiAob3B0aW9ucy5faCkge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyB0aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhcnNlZEFzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKGhhc0Jhc2VQYXRoKHVybCkgPyBkZWxCYXNlUGF0aCh1cmwpIDogdXJsLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKHJlZiA9IHRoaXMubG9jYWxlcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuaW5jbHVkZXMobmV4dFN0YXRlLmxvY2FsZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gZGVsQmFzZVBhdGgoYXMpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHthZGRCYXNlUGF0aChgJHtuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bmV4dFN0YXRlLmxvY2FsZX1gfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJyl9YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5faCkge1xuICAgICAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNoYWxsb3cgPWZhbHNlICwgc2Nyb2xsID10cnVlICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzID0gYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcywgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgbGV0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBpZiAoIW9wdGlvbnMuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldChuZXh0U3RhdGUsIHRoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmVMaXN0KCksIFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkucmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdChhZGRCYXNlUGF0aChhZGRMb2NhbGUoY2xlYW5lZEFzLCBuZXh0U3RhdGUubG9jYWxlKSksIHBhZ2VzLCByZXdyaXRlcywgcXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcylcbiAgICAgICAgICAgICAgICAsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaHJlZjogXCIke3VybH1cIiBhbmQgYXM6IFwiJHthc31cIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXNgICsgYFxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGUgcm91dGUgdXBkYXRlIHdhcyB0cmlnZ2VyZWQgZm9yIGNsaWVudC1zaWRlIGh5ZHJhdGlvbiBhbmRcbiAgICAgKiB0aGUgcmVuZGVyZWQgcm91dGUgaXMgbm90IGR5bmFtaWMgZG8gbm90IGNoZWNrIHRoZSBwcmVmbGlnaHRcbiAgICAgKiByZXF1ZXN0IGFzIGl0IGlzIG5vdCBuZWNlc3NhcnkuXG4gICAgICovIGlmICgoIW9wdGlvbnMuc2hhbGxvdyB8fCBvcHRpb25zLl9oID09PSAxKSAmJiAob3B0aW9ucy5faCAhPT0gMSB8fCAoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUoKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSkpKSkge1xuICAgICAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgY2FjaGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlld1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gZWZmZWN0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IGVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0Lm5ld0FzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgZWZmZWN0Lm5ld1VybCwgZWZmZWN0Lm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdCcgJiYgZWZmZWN0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBlZmZlY3QuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVmZmVjdC50eXBlID09PSAncmVmcmVzaCcgJiYgYXMgIT09IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSk7XG4gICAgICAgICAgICBjb25zdCByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge307XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtzaG91bGRJbnRlcnBvbGF0ZSA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbignLCAnKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVmMSwgcmVmMjtcbiAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcmVzb2x2ZWRBcywgcm91dGVQcm9wcywgbmV4dFN0YXRlLmxvY2FsZSwgbmV4dFN0YXRlLmlzUHJldmlldyk7XG4gICAgICAgICAgICBsZXQgeyBlcnJvciAsIHByb3BzICwgX19OX1NTRyAsIF9fTl9TU1AgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgIGlmICgoX19OX1NTRyB8fCBfX05fU1NQKSAmJiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5wYWdlUHJvcHMgJiYgcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSAmJiBwcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXByb3BzLl9fTl9QUkVWSUVXO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCc7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8obm90Rm91bmRSb3V0ZSwgbm90Rm91bmRSb3V0ZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LCBuZXh0U3RhdGUubG9jYWxlLCBuZXh0U3RhdGUuaXNQcmV2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5faCAmJiBwYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmMSA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKHJlZjIgPSByZWYxLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgcmVmMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMi5zdGF0dXNDb2RlKSA9PT0gNTAwICYmIChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgbmV4dFN0YXRlLnJvdXRlID09PSByb3V0ZTtcbiAgICAgICAgICAgIHZhciBfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9zY3JvbGwgPSBvcHRpb25zLnNjcm9sbCkgIT09IG51bGwgJiYgX3Njcm9sbCAhPT0gdm9pZCAwID8gX3Njcm9sbCA6ICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHtcbiAgICAgICAgICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2VcbiAgICAgICAgICAgIH0sIHJvdXRlSW5mbywgZm9yY2VkU2Nyb2xsICE9PSBudWxsICYmIGZvcmNlZFNjcm9sbCAhPT0gdm9pZCAwID8gZm9yY2VkU2Nyb2xsIDogcmVzZXRTY3JvbGwpLmNhdGNoKChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyMSkge1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIxKSAmJiBlcnIxLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgKDAsIF91dGlscykuZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlkeDogdGhpcy5faWR4ID0gbWV0aG9kICE9PSAncHVzaFN0YXRlJyA/IHRoaXMuX2lkeCA6IHRoaXMuX2lkeCArIDFcbiAgICAgICAgICAgIH0sIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICAgICAnJywgYXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKGVyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIF9yb3V0ZUxvYWRlcikuaXNBc3NldEVycm9yKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IENvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZVNoZWV0cztcbiAgICAgICAgICAgIGxldCBwcm9wcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygc3R5bGVTaGVldHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgKHsgcGFnZTogQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KCcvX2Vycm9yJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpO1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZGVmYXVsdChyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArICcnKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzLCBsb2NhbGUsIGlzUHJldmlldykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZUluZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdO1xuICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ1JvdXRlSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1JvdXRlSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBjYW4gb25seSB1c2Ugbm9uLWluaXRpYWwgcm91dGUgaW5mb1xuICAgICAgICAgICAgLy8gY2Fubm90IHJldXNlIHJvdXRlIGluZm8gaW4gZGV2ZWxvcG1lbnQgc2luY2UgaXQgY2FuIGNoYW5nZSBhZnRlciBITVJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJiBleGlzdGluZ1JvdXRlSW5mbyAmJiAhKCdpbml0aWFsJyBpbiBleGlzdGluZ1JvdXRlSW5mbykpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRSb3V0ZUluZm8gPSBleGlzdGluZ1JvdXRlSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mbyB8fCBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpPT4oe1xuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICAgICAgICAgICAgX19OX1JTQzogISFyZXMubW9kLl9fbmV4dF9yc2NfX1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgeyBDb21wb25lbnQgLCBfX05fU1NHICwgX19OX1NTUCAsIF9fTl9SU0MgIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRhdGFIcmVmO1xuICAgICAgICAgICAgaWYgKF9fTl9TU0cgfHwgX19OX1NTUCB8fCBfX05fUlNDKSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWYgPSB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBzc2c6IF9fTl9TU0csXG4gICAgICAgICAgICAgICAgICAgIHJzYzogX19OX1JTQyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGF3YWl0IHRoaXMuX2dldERhdGEoKCk9Pl9fTl9TU0cgfHwgX19OX1NTUCA/IGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IsIGZhbHNlLCBfX05fU1NHID8gdGhpcy5zZGMgOiB0aGlzLnNkciwgISFfX05fU1NHICYmICFpc1ByZXZpZXcpIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoX19OX1JTQykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJlc2ggLCBkYXRhICB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YSgoKT0+dGhpcy5fZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHByb3BzLnBhZ2VQcm9wcyA9IE9iamVjdC5hc3NpZ24ocHJvcHMucGFnZVByb3BzLCB7XG4gICAgICAgICAgICAgICAgICAgIF9fZmxpZ2h0X3NlcmlhbGl6ZWRfXzogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgX19mbGlnaHRfZnJlc2hfXzogZnJlc2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc0Vycm9yKS5nZXRQcm9wZXJFcnJvcihlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSAnJ10gPSBhcy5zcGxpdCgnIycpO1xuICAgICAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWUgb3IgYCN0b3BgXG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBpZiAoaGFzaCA9PT0gJycgfHwgaGFzaCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICBpZEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXTtcbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsSXNOZXcoYXNQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqLyBhc3luYyBwcmVmZXRjaCh1cmwsIGFzUGF0aCA9IHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9ID0gYXdhaXQgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzUGF0aCwgdGhpcy5sb2NhbGUpKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcylcbiAgICAgICAgICAgICwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZmZlY3RzID0gYXdhaXQgdGhpcy5fcHJlZmxpZ2h0UmVxdWVzdCh7XG4gICAgICAgICAgICBhczogYWRkQmFzZVBhdGgoYXNQYXRoKSxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgIGlzUHJldmlldzogdGhpcy5pc1ByZXZpZXdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlZmZlY3RzLnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZWZmZWN0cy5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGVmZmVjdHMucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZWZmZWN0cy5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBlZmZlY3RzLmFzUGF0aDtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEodGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIHNzZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgOiB0aGlzLmxvY2FsZVxuICAgICAgICAgICAgICAgIH0pLCBmYWxzZSwgZmFsc2UsIHRoaXMuc2RjLCB0cnVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksIFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSB0aGlzLmNsYyA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdHJ1ZSwgdHJ1ZSwgdGhpcy5zZGMsIGZhbHNlKS50aGVuKChzZXJpYWxpemVkKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcmVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBzZXJpYWxpemVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3ByZWZsaWdodFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGF0aE5vUXVlcnlIYXNoKG9wdGlvbnMuYXMpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoaGFzQmFzZVBhdGgoYXNQYXRobmFtZSkgPyBkZWxCYXNlUGF0aChhc1BhdGhuYW1lKSA6IGFzUGF0aG5hbWUsIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgY29uc3QgZm5zID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmVMaXN0KCk7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVzUHJlZmxpZ2h0ID0gZm5zLnNvbWUoKFttaWRkbGV3YXJlLCBpc1NTUl0pPT57XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcigoMCwgX2dldE1pZGRsZXdhcmVSZWdleCkuZ2V0TWlkZGxld2FyZVJlZ2V4KG1pZGRsZXdhcmUsICFpc1NTUikpKGNsZWFuZWRBcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlcXVpcmVzUHJlZmxpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICduZXh0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlZmxpZ2h0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJlZmxpZ2h0ID0gYXdhaXQgdGhpcy5fZ2V0UHJlZmxpZ2h0RGF0YSh7XG4gICAgICAgICAgICAgICAgcHJlZmxpZ2h0SHJlZjogb3B0aW9ucy5hcyxcbiAgICAgICAgICAgICAgICBzaG91bGRDYWNoZTogb3B0aW9ucy5jYWNoZSxcbiAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG9wdGlvbnMuaXNQcmV2aWV3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiBwcmVmbGlnaHQgcmVxdWVzdCBmYWlscywgd2UgbmVlZCB0byBkbyBhIGhhcmQtbmF2aWdhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0JyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogb3B0aW9ucy5hc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZmxpZ2h0LnJld3JpdGUpIHtcbiAgICAgICAgICAgIC8vIGZvciBleHRlcm5hbCByZXdyaXRlcyB3ZSBuZWVkIHRvIGRvIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAvLyB0byB0aGUgcmVzb3VyY2VcbiAgICAgICAgICAgIGlmICghcHJlZmxpZ2h0LnJld3JpdGUuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IG9wdGlvbnMuYXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChoYXNCYXNlUGF0aChwcmVmbGlnaHQucmV3cml0ZSkgPyBkZWxCYXNlUGF0aChwcmVmbGlnaHQucmV3cml0ZSkgOiBwcmVmbGlnaHQucmV3cml0ZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBmc1BhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXJzZWQucGF0aG5hbWUpO1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRQYWdlO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFBhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZiA9IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZiA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgb3B0aW9ucy5wYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkSHJlZiAhPT0gcGFyc2VkLnBhdGhuYW1lICYmIG9wdGlvbnMucGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUGFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmV3cml0ZScsXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBwYXJzZWQucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZCxcbiAgICAgICAgICAgICAgICBtYXRjaGVkUGFnZSxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZsaWdodC5yZWRpcmVjdCkge1xuICAgICAgICAgICAgaWYgKHByZWZsaWdodC5yZWRpcmVjdC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhblJlZGlyZWN0ID0gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5yZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoaGFzQmFzZVBhdGgocHJlZmxpZ2h0LnJlZGlyZWN0KSA/IGRlbEJhc2VQYXRoKHByZWZsaWdodC5yZWRpcmVjdCkgOiBwcmVmbGlnaHQucmVkaXJlY3QsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgY2xlYW5SZWRpcmVjdCwgY2xlYW5SZWRpcmVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgbmV3VXJsLFxuICAgICAgICAgICAgICAgICAgICBuZXdBc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IHByZWZsaWdodC5yZWRpcmVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgU1NSIHJlcXVlc3RzLCB0aGV5IHdpbGwgYmUgaGFuZGxlZCBsaWtlIG5vcm1hbCBwYWdlcy5cbiAgICAgICAgaWYgKHByZWZsaWdodC5yZWZyZXNoICYmICFwcmVmbGlnaHQuc3NyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWZyZXNoJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQcmVmbGlnaHREYXRhKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IHByZWZsaWdodEhyZWYgLCBzaG91bGRDYWNoZSA9ZmFsc2UgLCBpc1ByZXZpZXcgIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKHByZWZsaWdodEhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgIWlzUHJldmlldyAmJiBzaG91bGRDYWNoZSAmJiB0aGlzLnNkZVtjYWNoZUtleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGVbY2FjaGVLZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2gocHJlZmxpZ2h0SHJlZiwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAneC1taWRkbGV3YXJlLXByZWZsaWdodCc6ICcxJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKChyZXMpPT57XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHByZWZsaWdodCByZXF1ZXN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhY2hlOiByZXMuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZXMuaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyksXG4gICAgICAgICAgICAgICAgcmVmcmVzaDogcmVzLmhlYWRlcnMuaGFzKCd4LW1pZGRsZXdhcmUtcmVmcmVzaCcpLFxuICAgICAgICAgICAgICAgIHJld3JpdGU6IHJlcy5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLXJld3JpdGUnKSxcbiAgICAgICAgICAgICAgICBzc3I6ICEhcmVzLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtc3NyJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2FjaGUgJiYgZGF0YS5jYWNoZSAhPT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2RlW2NhY2hlS2V5XSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkZVtjYWNoZUtleV07XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscykubG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFib3J0Q29tcG9uZW50TG9hZChhcywgcm91dGVQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5jbGMpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jbGMoKTtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcm91dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lO1xuICAgIH1cbiAgICBnZXQgcXVlcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5O1xuICAgIH1cbiAgICBnZXQgYXNQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5hc1BhdGg7XG4gICAgfVxuICAgIGdldCBsb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IGlzRmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRmFsbGJhY2s7XG4gICAgfVxuICAgIGdldCBpc1ByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUHJldmlldztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXI7XG5Sb3V0ZXIuZXZlbnRzID0gKDAsIF9taXR0KS5kZWZhdWx0KCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREb21haW5Mb2NhbGUiLCJhZGRMb2NhbGUiLCJkZWxMb2NhbGUiLCJoYXNCYXNlUGF0aCIsImFkZEJhc2VQYXRoIiwiZGVsQmFzZVBhdGgiLCJpc0xvY2FsVVJMIiwiaW50ZXJwb2xhdGVBcyIsInJlc29sdmVIcmVmIiwiZGVmYXVsdCIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwicmVxdWlyZSIsIl9yb3V0ZUxvYWRlciIsIl9pc0Vycm9yIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfZGVub3JtYWxpemVQYWdlUGF0aCIsIl9ub3JtYWxpemVMb2NhbGVQYXRoIiwiX21pdHQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3V0aWxzIiwiX2lzRHluYW1pYyIsIl9wYXJzZVJlbGF0aXZlVXJsIiwiX3F1ZXJ5c3RyaW5nIiwiX3Jlc29sdmVSZXdyaXRlcyIsIl9yb3V0ZU1hdGNoZXIiLCJfcm91dGVSZWdleCIsIl9nZXRNaWRkbGV3YXJlUmVnZXgiLCJfZm9ybWF0VXJsIiwib2JqIiwiX19lc01vZHVsZSIsIm5ld09iaiIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJzZXQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImJhc2VQYXRoIiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsImFkZFBhdGhQcmVmaXgiLCJwYXRoIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicGF0aE5vUXVlcnlIYXNoIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJzbGljZSIsImxlbmd0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsImRldGVjdGVkTG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJ1bmRlZmluZWQiLCJodHRwIiwiZG9tYWluIiwiZGVmYXVsdExvY2FsZSIsInBhdGhMb3dlciIsInRvTG93ZXJDYXNlIiwibG9jYWxlTG93ZXIiLCJxdWVyeUluZGV4IiwiaW5kZXhPZiIsImhhc2hJbmRleCIsInN1YnN0cmluZyIsInVybCIsImxvY2F0aW9uT3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsIlVSTCIsIm9yaWdpbiIsIl8iLCJyb3V0ZSIsImFzUGF0aG5hbWUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInBhcmFtcyIsImtleXMiLCJldmVyeSIsInBhcmFtIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsImZpbHRlcmVkUXVlcnkiLCJmb3JFYWNoIiwiaW5jbHVkZXMiLCJyb3V0ZXIiLCJocmVmIiwicmVzb2x2ZUFzIiwiYmFzZSIsInVybEFzU3RyaW5nIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJ1cmxQcm90b01hdGNoIiwibWF0Y2giLCJ1cmxBc1N0cmluZ05vUHJvdG8iLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImFzUGF0aCIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpc0R5bmFtaWNSb3V0ZSIsInNlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJoYXNoIiwicmVzb2x2ZWRIcmVmIiwiXzEiLCJzdHJpcE9yaWdpbiIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZWRBcyIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJzb21lIiwicGFnZSIsInJlIiwidGVzdCIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJvcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInRoZW4iLCJyZXMiLCJvayIsInN0YXR1cyIsImpzb24iLCJkYXRhIiwibm90Rm91bmQiLCJ0ZXh0IiwiZmV0Y2hOZXh0RGF0YSIsImRhdGFIcmVmIiwiaXNTZXJ2ZXJSZW5kZXIiLCJpbmZsaWdodENhY2hlIiwicGVyc2lzdENhY2hlIiwibG9jYXRpb24iLCJjYWNoZUtleSIsImNhdGNoIiwiZXJyIiwibWFya0Fzc2V0RXJyb3IiLCJSb3V0ZXIiLCJwYXRobmFtZTEiLCJxdWVyeTEiLCJhczEiLCJpbml0aWFsUHJvcHMiLCJwYWdlTG9hZGVyIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsInN1YnNjcmlwdGlvbiIsImlzRmFsbGJhY2siLCJpc1ByZXZpZXciLCJpc1JzYyIsInNkYyIsInNkciIsInNkZSIsIl9pZHgiLCJvblBvcFN0YXRlIiwiZSIsInN0YXRlIiwiY2hhbmdlU3RhdGUiLCJnZXRVUkwiLCJfX04iLCJmb3JjZWRTY3JvbGwiLCJvcHRpb25zIiwiaWR4IiwiSlNPTiIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwicGFyc2UiLCJwYXJzZVJlbGF0aXZlVXJsIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiY29tcG9uZW50cyIsImluaXRpYWwiLCJwcm9wcyIsIl9fTl9TU0ciLCJfX05fU1NQIiwiX19OX1JTQyIsInN0eWxlU2hlZXRzIiwiZXZlbnRzIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJfX05FWFRfREFUQV9fIiwiYXV0b0V4cG9ydCIsInN1YiIsImNsYyIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJob3N0bmFtZSIsIl9zaG91bGRSZXNvbHZlSHJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxSZXN0b3JhdGlvbiIsInJlbG9hZCIsImJhY2siLCJwdXNoIiwibWV0aG9kIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJwcmV2TG9jYWxlIiwicGFyc2VkQXMiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGlkTmF2aWdhdGUiLCJyZWYiLCJhc05vQmFzZVBhdGgiLCJzY3JvbGwiLCJyb3V0ZVByb3BzIiwiY2xlYW5lZEFzIiwibG9jYWxlQ2hhbmdlIiwicGFyc2VkIiwicmV3cml0ZXMiLCJyZXdyaXRlc1Jlc3VsdCIsImVmZmVjdCIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwic2hvdWxkSW50ZXJwb2xhdGUiLCJtaXNzaW5nUGFyYW1zIiwicmVmMSIsInJlZjIiLCJyb3V0ZUluZm8iLCJkZXN0aW5hdGlvbiIsInBhcnNlZEhyZWYiLCJuZXdVcmwiLCJuZXdBcyIsIm5vdEZvdW5kUm91dGUiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiX3Njcm9sbCIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwiX2giLCJQcm9taXNlIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJfaW5GbGlnaHRSb3V0ZSIsImFib3J0Q29tcG9uZW50TG9hZCIsIm9ubHlBSGFzaENoYW5nZSIsImVtaXQiLCJzY3JvbGxUb0hhc2giLCJhbGwiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJnZXRNaWRkbGV3YXJlTGlzdCIsIl9fcmV3cml0ZXMiLCJ1cmxJc05ldyIsInAiLCJleHRlcm5hbERlc3QiLCJtYXRjaGVkUGFnZSIsIl9wcmVmbGlnaHRSZXF1ZXN0IiwiY2FjaGUiLCJ0eXBlIiwiZmlsdGVyIiwid2FybiIsImdldFJvdXRlSW5mbyIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJfX05fUFJFVklFVyIsImZldGNoQ29tcG9uZW50Iiwic3RhdHVzQ29kZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsImV4aXN0aW5nUm91dGVJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZnJlc2giLCJtb2QiLCJfX25leHRfcnNjX18iLCJnZXREYXRhSHJlZiIsInNzZyIsInJzYyIsIl9nZXREYXRhIiwiX2dldEZsaWdodERhdGEiLCJfX2ZsaWdodF9zZXJpYWxpemVkX18iLCJfX2ZsaWdodF9mcmVzaF9fIiwiZ2V0UHJvcGVyRXJyb3IiLCJiZWZvcmVQb3BTdGF0ZSIsImNiIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJzY3JvbGxUbyIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJwcmVmZXRjaCIsImVmZmVjdHMiLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiY2FuY2VsIiwiaGFuZGxlQ2FuY2VsbGVkIiwiY29tcG9uZW50UmVzdWx0IiwibG9hZFBhZ2UiLCJmbiIsInNlcmlhbGl6ZWQiLCJmbnMiLCJyZXF1aXJlc1ByZWZsaWdodCIsInByZWZsaWdodCIsImZzUGF0aG5hbWUiLCJjbGVhblJlZGlyZWN0IiwibWlkZGxld2FyZSIsImlzU1NSIiwiZ2V0TWlkZGxld2FyZVJlZ2V4IiwiX2dldFByZWZsaWdodERhdGEiLCJwcmVmbGlnaHRIcmVmIiwic2hvdWxkQ2FjaGUiLCJyZXdyaXRlIiwicmVkaXJlY3QiLCJyZWZyZXNoIiwic3NyIiwicmVzb2x2ZSIsImhlYWRlcnMiLCJoYXMiLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.formatUrl = formatUrl;\nexports.formatWithValidation = formatWithValidation;\nexports.urlObjectKeys = void 0;\nvar querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {};\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nvar slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    var auth = urlObj.auth, hostname = urlObj.hostname;\n    var protocol = urlObj.protocol || '';\n    var pathname = urlObj.pathname || '';\n    var hash = urlObj.hash || '';\n    var query = urlObj.query || '';\n    var host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\".concat(hostname, \"]\") : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(querystring.urlQueryToSearchParams(query));\n    }\n    var search = urlObj.search || query && \"?\".concat(query) || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);\n}\nvar urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes', \n];\nexports.urlObjectKeys = urlObjectKeys;\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach(function(key) {\n                if (urlObjectKeys.indexOf(key) === -1) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \".concat(key));\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHRSxTQUFTO0FBQzdCRiw0QkFBNEIsR0FBR0csb0JBQW9CO0FBQ25ESCxxQkFBcUIsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUM5QixHQUFHLENBQUNLLFdBQVcsR0FBR0MsdUJBQXVCLENBQUNDLG1CQUFPLENBQUMsc0ZBQWU7U0FDeERELHVCQUF1QixDQUFDRSxHQUFHLEVBQUUsQ0FBQztJQUNuQyxFQUFFLEVBQUVBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEVBQUUsQ0FBQztRQUN4QixNQUFNLENBQUNELEdBQUc7SUFDZCxDQUFDLE1BQU0sQ0FBQztRQUNKLEdBQUcsQ0FBQ0UsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNmLEVBQUUsRUFBRUYsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ2QsR0FBRyxDQUFDLEdBQUcsQ0FBQ0csR0FBRyxJQUFJSCxHQUFHLENBQUMsQ0FBQztnQkFDaEIsRUFBRSxFQUFFVixNQUFNLENBQUNjLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNOLEdBQUcsRUFBRUcsR0FBRyxHQUFHLENBQUM7b0JBQ2pELEdBQUcsQ0FBQ0ksSUFBSSxHQUFHakIsTUFBTSxDQUFDQyxjQUFjLElBQUlELE1BQU0sQ0FBQ2tCLHdCQUF3QixHQUFHbEIsTUFBTSxDQUFDa0Isd0JBQXdCLENBQUNSLEdBQUcsRUFBRUcsR0FBRyxJQUFJLENBQUMsQ0FBQztvQkFDcEgsRUFBRSxFQUFFSSxJQUFJLENBQUNFLEdBQUcsSUFBSUYsSUFBSSxDQUFDRyxHQUFHLEVBQUUsQ0FBQzt3QkFDdkJwQixNQUFNLENBQUNDLGNBQWMsQ0FBQ1csTUFBTSxFQUFFQyxHQUFHLEVBQUVJLElBQUk7b0JBQzNDLENBQUMsTUFBTSxDQUFDO3dCQUNKTCxNQUFNLENBQUNDLEdBQUcsSUFBSUgsR0FBRyxDQUFDRyxHQUFHO29CQUN6QixDQUFDO2dCQUNMLENBQUM7WUFDTCxDQUFDO1FBQ0wsQ0FBQztRQUNERCxNQUFNLENBQUNTLE9BQU8sR0FBR1gsR0FBRztRQUNwQixNQUFNLENBQUNFLE1BQU07SUFDakIsQ0FBQztBQUNMLENBQUM7QUFDRCxHQUFLLENBQUNVLGdCQUFnQjtTQUNibEIsU0FBUyxDQUFDbUIsTUFBTSxFQUFFLENBQUM7SUFDeEIsR0FBRyxDQUFHQyxJQUFJLEdBQWlCRCxNQUFNLENBQTNCQyxJQUFJLEVBQUdDLFFBQVEsR0FBTUYsTUFBTSxDQUFwQkUsUUFBUTtJQUNyQixHQUFHLENBQUNDLFFBQVEsR0FBR0gsTUFBTSxDQUFDRyxRQUFRLElBQUksQ0FBRTtJQUNwQyxHQUFHLENBQUNDLFFBQVEsR0FBR0osTUFBTSxDQUFDSSxRQUFRLElBQUksQ0FBRTtJQUNwQyxHQUFHLENBQUNDLElBQUksR0FBR0wsTUFBTSxDQUFDSyxJQUFJLElBQUksQ0FBRTtJQUM1QixHQUFHLENBQUNDLEtBQUssR0FBR04sTUFBTSxDQUFDTSxLQUFLLElBQUksQ0FBRTtJQUM5QixHQUFHLENBQUNDLElBQUksR0FBRyxLQUFLO0lBQ2hCTixJQUFJLEdBQUdBLElBQUksR0FBR08sa0JBQWtCLENBQUNQLElBQUksRUFBRVEsT0FBTyxTQUFTLENBQUcsTUFBSSxDQUFHLEtBQUcsQ0FBRTtJQUN0RSxFQUFFLEVBQUVULE1BQU0sQ0FBQ08sSUFBSSxFQUFFLENBQUM7UUFDZEEsSUFBSSxHQUFHTixJQUFJLEdBQUdELE1BQU0sQ0FBQ08sSUFBSTtJQUM3QixDQUFDLE1BQU0sRUFBRSxFQUFFTCxRQUFRLEVBQUUsQ0FBQztRQUNsQkssSUFBSSxHQUFHTixJQUFJLEtBQUtDLFFBQVEsQ0FBQ1EsT0FBTyxDQUFDLENBQUcsTUFBSyxDQUFDLEdBQVcsTUFBQyxDQUFWUixRQUFRLEVBQUMsQ0FBQyxNQUFJQSxRQUFRO1FBQ2xFLEVBQUUsRUFBRUYsTUFBTSxDQUFDVyxJQUFJLEVBQUUsQ0FBQztZQUNkSixJQUFJLElBQUksQ0FBRyxLQUFHUCxNQUFNLENBQUNXLElBQUk7UUFDN0IsQ0FBQztJQUNMLENBQUM7SUFDRCxFQUFFLEVBQUVMLEtBQUssSUFBSSxNQUFNLENBQUNBLEtBQUssS0FBSyxDQUFRLFNBQUUsQ0FBQztRQUNyQ0EsS0FBSyxHQUFHTSxNQUFNLENBQUM1QixXQUFXLENBQUM2QixzQkFBc0IsQ0FBQ1AsS0FBSztJQUMzRCxDQUFDO0lBQ0QsR0FBRyxDQUFDUSxNQUFNLEdBQUdkLE1BQU0sQ0FBQ2MsTUFBTSxJQUFJUixLQUFLLElBQUssQ0FBQyxHQUFRLE9BQU5BLEtBQUssS0FBTSxDQUFFO0lBQ3hELEVBQUUsRUFBRUgsUUFBUSxLQUFLQSxRQUFRLENBQUNZLFFBQVEsQ0FBQyxDQUFHLEtBQUdaLFFBQVEsSUFBSSxDQUFHO0lBQ3hELEVBQUUsRUFBRUgsTUFBTSxDQUFDZ0IsT0FBTyxNQUFNYixRQUFRLElBQUlKLGdCQUFnQixDQUFDa0IsSUFBSSxDQUFDZCxRQUFRLE1BQU1JLElBQUksS0FBSyxLQUFLLEVBQUUsQ0FBQztRQUNyRkEsSUFBSSxHQUFHLENBQUksT0FBSUEsSUFBSSxJQUFJLENBQUU7UUFDekIsRUFBRSxFQUFFSCxRQUFRLElBQUlBLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBRyxJQUFFQSxRQUFRLEdBQUcsQ0FBRyxLQUFHQSxRQUFRO0lBQ2xFLENBQUMsTUFBTSxFQUFFLEdBQUdHLElBQUksRUFBRSxDQUFDO1FBQ2ZBLElBQUksR0FBRyxDQUFFO0lBQ2IsQ0FBQztJQUNELEVBQUUsRUFBRUYsSUFBSSxJQUFJQSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUcsSUFBRUEsSUFBSSxHQUFHLENBQUcsS0FBR0EsSUFBSTtJQUM5QyxFQUFFLEVBQUVTLE1BQU0sSUFBSUEsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFHLElBQUVBLE1BQU0sR0FBRyxDQUFHLEtBQUdBLE1BQU07SUFDdERWLFFBQVEsR0FBR0EsUUFBUSxDQUFDSyxPQUFPLFVBQVVELGtCQUFrQjtJQUN2RE0sTUFBTSxHQUFHQSxNQUFNLENBQUNMLE9BQU8sQ0FBQyxDQUFHLElBQUUsQ0FBSztJQUNsQyxNQUFNLENBQUUsR0FBYUYsTUFBSSxDQUFmSixRQUFRLEVBQVVDLE1BQVEsQ0FBZkcsSUFBSSxFQUFjTyxNQUFNLENBQWpCVixRQUFRLEVBQVlDLE1BQUksQ0FBYlMsTUFBTSxFQUFRLE9BQUxULElBQUk7QUFDeEQsQ0FBQztBQUNELEdBQUssQ0FBQ3RCLGFBQWEsR0FBRyxDQUFDO0lBQ25CLENBQU07SUFDTixDQUFNO0lBQ04sQ0FBTTtJQUNOLENBQVU7SUFDVixDQUFNO0lBQ04sQ0FBTTtJQUNOLENBQVU7SUFDVixDQUFNO0lBQ04sQ0FBVTtJQUNWLENBQU87SUFDUCxDQUFRO0lBQ1IsQ0FBUztBQUNiLENBQUM7QUFDREoscUJBQXFCLEdBQUdJLGFBQWE7U0FDNUJELG9CQUFvQixDQUFDb0MsR0FBRyxFQUFFLENBQUM7SUFDaEMsRUFBRSxFQS9FTixJQStFOEMsRUFBRSxDQUFDO1FBQ3pDLEVBQUUsRUFBRUEsR0FBRyxLQUFLLElBQUksSUFBSSxNQUFNLENBQUNBLEdBQUcsS0FBSyxDQUFRLFNBQUUsQ0FBQztZQUMxQ3pDLE1BQU0sQ0FBQzBDLElBQUksQ0FBQ0QsR0FBRyxFQUFFRSxPQUFPLENBQUMsUUFBUSxDQUFQOUIsR0FBRyxFQUFHLENBQUM7Z0JBQzdCLEVBQUUsRUFBRVAsYUFBYSxDQUFDMkIsT0FBTyxDQUFDcEIsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDO29CQUNwQytCLE9BQU8sQ0FBQ0MsSUFBSSxDQUFFLENBQWtELG9EQUFNLE9BQUpoQyxHQUFHO2dCQUN6RSxDQUFDO1lBQ0wsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxDQUFDVCxTQUFTLENBQUNxQyxHQUFHO0FBQ3hCLENBQUMsQ0FFcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzPzdiNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZvcm1hdFVybCA9IGZvcm1hdFVybDtcbmV4cG9ydHMuZm9ybWF0V2l0aFZhbGlkYXRpb24gPSBmb3JtYXRXaXRoVmFsaWRhdGlvbjtcbmV4cG9ydHMudXJsT2JqZWN0S2V5cyA9IHZvaWQgMDtcbnZhciBxdWVyeXN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3T2JqID0ge307XG4gICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG59XG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvO1xuZnVuY3Rpb24gZm9ybWF0VXJsKHVybE9iaikge1xuICAgIGxldCB7IGF1dGggLCBob3N0bmFtZSAgfSA9IHVybE9iajtcbiAgICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJyc7XG4gICAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnO1xuICAgIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJyc7XG4gICAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnO1xuICAgIGxldCBob3N0ID0gZmFsc2U7XG4gICAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJztcbiAgICBpZiAodXJsT2JqLmhvc3QpIHtcbiAgICAgICAgaG9zdCA9IGF1dGggKyB1cmxPYmouaG9zdDtcbiAgICB9IGVsc2UgaWYgKGhvc3RuYW1lKSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSk7XG4gICAgICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgICAgICAgaG9zdCArPSAnOicgKyB1cmxPYmoucG9ydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBxdWVyeSA9IFN0cmluZyhxdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5KSk7XG4gICAgfVxuICAgIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IHF1ZXJ5ICYmIGA/JHtxdWVyeX1gIHx8ICcnO1xuICAgIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoJzonKSkgcHJvdG9jb2wgKz0gJzonO1xuICAgIGlmICh1cmxPYmouc2xhc2hlcyB8fCAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgICAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgIGhvc3QgPSAnJztcbiAgICB9XG4gICAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gO1xufVxuY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgICAnYXV0aCcsXG4gICAgJ2hhc2gnLFxuICAgICdob3N0JyxcbiAgICAnaG9zdG5hbWUnLFxuICAgICdocmVmJyxcbiAgICAncGF0aCcsXG4gICAgJ3BhdGhuYW1lJyxcbiAgICAncG9ydCcsXG4gICAgJ3Byb3RvY29sJyxcbiAgICAncXVlcnknLFxuICAgICdzZWFyY2gnLFxuICAgICdzbGFzaGVzJywgXG5dO1xuZXhwb3J0cy51cmxPYmplY3RLZXlzID0gdXJsT2JqZWN0S2V5cztcbmZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICBpZiAodXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0VXJsKHVybCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC11cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZm9ybWF0VXJsIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJ1cmxPYmplY3RLZXlzIiwicXVlcnlzdHJpbmciLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJvYmoiLCJfX2VzTW9kdWxlIiwibmV3T2JqIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsInNldCIsImRlZmF1bHQiLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsImtleXMiLCJmb3JFYWNoIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/format-url.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js ***!
  \********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getMiddlewareRegex = getMiddlewareRegex;\nvar _routeRegex = __webpack_require__(/*! ./route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction getMiddlewareRegex(normalizedRoute) {\n    var catchAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    var result = (0, _routeRegex).getParametrizedRoute(normalizedRoute);\n    var catchAllRegex = catchAll ? '(?!_next).*' : '';\n    var catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n    if ('routeKeys' in result) {\n        if (result.parameterizedRoute === '/') {\n            return {\n                groups: {},\n                namedRegex: \"^/\".concat(catchAllRegex, \"$\"),\n                re: new RegExp(\"^/\".concat(catchAllRegex, \"$\")),\n                routeKeys: {}\n            };\n        }\n        return {\n            groups: result.groups,\n            namedRegex: \"^\".concat(result.namedParameterizedRoute).concat(catchAllGroupedRegex, \"$\"),\n            re: new RegExp(\"^\".concat(result.parameterizedRoute).concat(catchAllGroupedRegex, \"$\")),\n            routeKeys: result.routeKeys\n        };\n    }\n    if (result.parameterizedRoute === '/') {\n        return {\n            groups: {},\n            re: new RegExp(\"^/\".concat(catchAllRegex, \"$\"))\n        };\n    }\n    return {\n        groups: {},\n        re: new RegExp(\"^\".concat(result.parameterizedRoute).concat(catchAllGroupedRegex, \"$\"))\n    };\n} //# sourceMappingURL=get-middleware-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1taWRkbGV3YXJlLXJlZ2V4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBR0Usa0JBQWtCO0FBQy9DLEdBQUcsQ0FBQ0MsV0FBVyxHQUFHQyxtQkFBTyxDQUFDLHNGQUFlO1NBQ2hDRixrQkFBa0IsQ0FBQ0csZUFBZSxFQUFtQixDQUFDO1FBQWxCQyxRQUFRLG9FQUFHLElBQUk7SUFDeEQsR0FBSyxDQUFDQyxNQUFNLElBQUksQ0FBQyxFQUFFSixXQUFXLEVBQUVLLG9CQUFvQixDQUFDSCxlQUFlO0lBQ3BFLEdBQUcsQ0FBQ0ksYUFBYSxHQUFHSCxRQUFRLEdBQUcsQ0FBYSxlQUFHLENBQUU7SUFDakQsR0FBRyxDQUFDSSxvQkFBb0IsR0FBR0osUUFBUSxHQUFHLENBQVksY0FBRyxDQUFFO0lBQ3ZELEVBQUUsRUFBRSxDQUFXLGNBQUlDLE1BQU0sRUFBRSxDQUFDO1FBQ3hCLEVBQUUsRUFBRUEsTUFBTSxDQUFDSSxrQkFBa0IsS0FBSyxDQUFHLElBQUUsQ0FBQztZQUNwQyxNQUFNLENBQUMsQ0FBQztnQkFDSkMsTUFBTSxFQUFFLENBQUMsQ0FBQztnQkFDVkMsVUFBVSxFQUFHLENBQUUsSUFBZ0IsTUFBQyxDQUFmSixhQUFhLEVBQUMsQ0FBQztnQkFDaENLLEVBQUUsRUFBRSxHQUFHLENBQUNDLE1BQU0sQ0FBRSxDQUFFLElBQWdCLE1BQUMsQ0FBZk4sYUFBYSxFQUFDLENBQUM7Z0JBQ25DTyxTQUFTLEVBQUUsQ0FBQyxDQUFDO1lBQ2pCLENBQUM7UUFDTCxDQUFDO1FBQ0QsTUFBTSxDQUFDLENBQUM7WUFDSkosTUFBTSxFQUFFTCxNQUFNLENBQUNLLE1BQU07WUFDckJDLFVBQVUsRUFBRyxDQUFDLEdBQW1DSCxNQUFvQixDQUFyREgsTUFBTSxDQUFDVSx1QkFBdUIsRUFBd0IsTUFBQyxDQUF0QlAsb0JBQW9CLEVBQUMsQ0FBQztZQUN2RUksRUFBRSxFQUFFLEdBQUcsQ0FBQ0MsTUFBTSxDQUFFLENBQUMsR0FBOEJMLE1BQW9CLENBQWhESCxNQUFNLENBQUNJLGtCQUFrQixFQUF3QixNQUFDLENBQXRCRCxvQkFBb0IsRUFBQyxDQUFDO1lBQ3JFTSxTQUFTLEVBQUVULE1BQU0sQ0FBQ1MsU0FBUztRQUMvQixDQUFDO0lBQ0wsQ0FBQztJQUNELEVBQUUsRUFBRVQsTUFBTSxDQUFDSSxrQkFBa0IsS0FBSyxDQUFHLElBQUUsQ0FBQztRQUNwQyxNQUFNLENBQUMsQ0FBQztZQUNKQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQ1ZFLEVBQUUsRUFBRSxHQUFHLENBQUNDLE1BQU0sQ0FBRSxDQUFFLElBQWdCLE1BQUMsQ0FBZk4sYUFBYSxFQUFDLENBQUM7UUFDdkMsQ0FBQztJQUNMLENBQUM7SUFDRCxNQUFNLENBQUMsQ0FBQztRQUNKRyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ1ZFLEVBQUUsRUFBRSxHQUFHLENBQUNDLE1BQU0sQ0FBRSxDQUFDLEdBQThCTCxNQUFvQixDQUFoREgsTUFBTSxDQUFDSSxrQkFBa0IsRUFBd0IsTUFBQyxDQUF0QkQsb0JBQW9CLEVBQUMsQ0FBQztJQUN6RSxDQUFDO0FBQ0wsQ0FBQyxDQUUrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1taWRkbGV3YXJlLXJlZ2V4LmpzPzA0NTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldE1pZGRsZXdhcmVSZWdleCA9IGdldE1pZGRsZXdhcmVSZWdleDtcbnZhciBfcm91dGVSZWdleCA9IHJlcXVpcmUoXCIuL3JvdXRlLXJlZ2V4XCIpO1xuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgY2F0Y2hBbGwgPSB0cnVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yb3V0ZVJlZ2V4KS5nZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIGxldCBjYXRjaEFsbFJlZ2V4ID0gY2F0Y2hBbGwgPyAnKD8hX25leHQpLionIDogJyc7XG4gICAgbGV0IGNhdGNoQWxsR3JvdXBlZFJlZ2V4ID0gY2F0Y2hBbGwgPyAnKD86KC8uKik/KScgOiAnJztcbiAgICBpZiAoJ3JvdXRlS2V5cycgaW4gcmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQucGFyYW1ldGVyaXplZFJvdXRlID09PSAnLycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzOiB7fSxcbiAgICAgICAgICAgICAgICBuYW1lZFJlZ2V4OiBgXi8ke2NhdGNoQWxsUmVnZXh9JGAsXG4gICAgICAgICAgICAgICAgcmU6IG5ldyBSZWdFeHAoYF4vJHtjYXRjaEFsbFJlZ2V4fSRgKSxcbiAgICAgICAgICAgICAgICByb3V0ZUtleXM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cHM6IHJlc3VsdC5ncm91cHMsXG4gICAgICAgICAgICBuYW1lZFJlZ2V4OiBgXiR7cmVzdWx0Lm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlfSR7Y2F0Y2hBbGxHcm91cGVkUmVnZXh9JGAsXG4gICAgICAgICAgICByZTogbmV3IFJlZ0V4cChgXiR7cmVzdWx0LnBhcmFtZXRlcml6ZWRSb3V0ZX0ke2NhdGNoQWxsR3JvdXBlZFJlZ2V4fSRgKSxcbiAgICAgICAgICAgIHJvdXRlS2V5czogcmVzdWx0LnJvdXRlS2V5c1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBhcmFtZXRlcml6ZWRSb3V0ZSA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cHM6IHt9LFxuICAgICAgICAgICAgcmU6IG5ldyBSZWdFeHAoYF4vJHtjYXRjaEFsbFJlZ2V4fSRgKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBncm91cHM6IHt9LFxuICAgICAgICByZTogbmV3IFJlZ0V4cChgXiR7cmVzdWx0LnBhcmFtZXRlcml6ZWRSb3V0ZX0ke2NhdGNoQWxsR3JvdXBlZFJlZ2V4fSRgKVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1taWRkbGV3YXJlLXJlZ2V4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldE1pZGRsZXdhcmVSZWdleCIsIl9yb3V0ZVJlZ2V4IiwicmVxdWlyZSIsIm5vcm1hbGl6ZWRSb3V0ZSIsImNhdGNoQWxsIiwicmVzdWx0IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJncm91cHMiLCJuYW1lZFJlZ2V4IiwicmUiLCJSZWdFeHAiLCJyb3V0ZUtleXMiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/get-middleware-regex.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports) {

eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.searchParamsToUrlQuery = searchParamsToUrlQuery;\nexports.urlQueryToSearchParams = urlQueryToSearchParams;\nexports.assign = assign;\nfunction searchParamsToUrlQuery(searchParams) {\n    var query = {};\n    searchParams.forEach(function(value, key) {\n        if (typeof query[key] === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    var result = new URLSearchParams();\n    Object.entries(urlQuery).forEach(function(param) {\n        var _param = _slicedToArray(param, 2), key = _param[0], value = _param[1];\n        if (Array.isArray(value)) {\n            value.forEach(function(item) {\n                return result.append(key, stringifyUrlQueryParam(item));\n            });\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach(function(searchParams) {\n        Array.from(searchParams.keys()).forEach(function(key) {\n            return target.delete(key);\n        });\n        searchParams.forEach(function(value, key) {\n            return target.append(key, value);\n        });\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsOEJBQThCLEdBQUdFLHNCQUFzQjtBQUN2REYsOEJBQThCLEdBQUdHLHNCQUFzQjtBQUN2REgsY0FBYyxHQUFHSSxNQUFNO1NBQ2RGLHNCQUFzQixDQUFDRyxZQUFZLEVBQUUsQ0FBQztJQUMzQyxHQUFLLENBQUNDLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDaEJELFlBQVksQ0FBQ0UsT0FBTyxDQUFDLFFBQVFDLENBQVBQLEtBQUssRUFBRU8sR0FBRyxFQUFHLENBQUM7UUFDaEMsRUFBRSxFQUFFLE1BQU0sQ0FBQ0YsS0FBSyxDQUFDRSxHQUFHLE1BQU0sQ0FBVyxZQUFFLENBQUM7WUFDcENGLEtBQUssQ0FBQ0UsR0FBRyxJQUFJUCxLQUFLO1FBQ3RCLENBQUMsTUFBTSxFQUFFLEVBQUVRLEtBQUssQ0FBQ0MsT0FBTyxDQUFDSixLQUFLLENBQUNFLEdBQUcsSUFBSSxDQUFDO1lBQ25DRixLQUFLLENBQUNFLEdBQUcsRUFBRUcsSUFBSSxDQUFDVixLQUFLO1FBQ3pCLENBQUMsTUFBTSxDQUFDO1lBQ0pLLEtBQUssQ0FBQ0UsR0FBRyxJQUFJLENBQUM7Z0JBQ1ZGLEtBQUssQ0FBQ0UsR0FBRztnQkFDVFAsS0FBSztZQUNULENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQztJQUNELE1BQU0sQ0FBQ0ssS0FBSztBQUNoQixDQUFDO1NBQ1FNLHNCQUFzQixDQUFDQyxLQUFLLEVBQUUsQ0FBQztJQUNwQyxFQUFFLEVBQUUsTUFBTSxDQUFDQSxLQUFLLEtBQUssQ0FBUSxXQUFJLE1BQU0sQ0FBQ0EsS0FBSyxLQUFLLENBQVEsWUFBS0MsS0FBSyxDQUFDRCxLQUFLLEtBQUssTUFBTSxDQUFDQSxLQUFLLEtBQUssQ0FBUyxVQUFFLENBQUM7UUFDeEcsTUFBTSxDQUFDRSxNQUFNLENBQUNGLEtBQUs7SUFDdkIsQ0FBQyxNQUFNLENBQUM7UUFDSixNQUFNLENBQUMsQ0FBRTtJQUNiLENBQUM7QUFDTCxDQUFDO1NBQ1FWLHNCQUFzQixDQUFDYSxRQUFRLEVBQUUsQ0FBQztJQUN2QyxHQUFLLENBQUNDLE1BQU0sR0FBRyxHQUFHLENBQUNDLGVBQWU7SUFDbENwQixNQUFNLENBQUNxQixPQUFPLENBQUNILFFBQVEsRUFBRVQsT0FBTyxDQUFDLFFBQVEsUUFBUSxDQUFDOytDQUFmQyxHQUFHLGNBQUVQLEtBQUs7UUFDekMsRUFBRSxFQUFFUSxLQUFLLENBQUNDLE9BQU8sQ0FBQ1QsS0FBSyxHQUFHLENBQUM7WUFDdkJBLEtBQUssQ0FBQ00sT0FBTyxDQUFDLFFBQVFVLENBQVBHLElBQUk7Z0JBQUdILE1BQU0sQ0FBTkEsTUFBTSxDQUFDSSxNQUFNLENBQUNiLEdBQUcsRUFBRUksc0JBQXNCLENBQUNRLElBQUk7O1FBRXhFLENBQUMsTUFBTSxDQUFDO1lBQ0pILE1BQU0sQ0FBQ0ssR0FBRyxDQUFDZCxHQUFHLEVBQUVJLHNCQUFzQixDQUFDWCxLQUFLO1FBQ2hELENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxDQUFDZ0IsTUFBTTtBQUNqQixDQUFDO1NBQ1FiLE1BQU0sQ0FBQ21CLE1BQU0sRUFBdUIsQ0FBQztJQUF0QixHQUFHQyxDQUFILEdBQW1CLENBQW5CLElBQW1CLEdBQW5CLFNBQW1CLENBQW5CLE1BQW1CLEVBQWhCQSxnQkFBZ0IsR0FBbkIsR0FBbUIsT0FBbkIsSUFBbUIsR0FBbkIsQ0FBbUIsR0FBbkIsSUFBbUIsR0FBbkIsQ0FBbUIsT0FBbkIsSUFBbUIsR0FBbkIsQ0FBbUIsRUFBbkIsSUFBbUIsR0FBbkIsSUFBbUIsRUFBbkIsSUFBbUIsR0FBbkIsQ0FBQztRQUFFQSxnQkFBZ0IsQ0FBbkIsSUFBbUIsR0FBbkIsQ0FBbUIsSUFBbkIsU0FBbUIsQ0FBbkIsSUFBbUI7SUFBRCxDQUFDO0lBQ3ZDQSxnQkFBZ0IsQ0FBQ2pCLE9BQU8sQ0FBQyxRQUFRLENBQVBGLFlBQVksRUFBRyxDQUFDO1FBQ3RDSSxLQUFLLENBQUNnQixJQUFJLENBQUNwQixZQUFZLENBQUNxQixJQUFJLElBQUluQixPQUFPLENBQUMsUUFBUSxDQUFQQyxHQUFHO1lBQUdlLE1BQU0sQ0FBTkEsTUFBTSxDQUFDSSxNQUFNLENBQUNuQixHQUFHOztRQUVoRUgsWUFBWSxDQUFDRSxPQUFPLENBQUMsUUFBUUMsQ0FBUFAsS0FBSyxFQUFFTyxHQUFHO1lBQUdlLE1BQU0sQ0FBTkEsTUFBTSxDQUFDRixNQUFNLENBQUNiLEdBQUcsRUFBRVAsS0FBSzs7SUFFL0QsQ0FBQztJQUNELE1BQU0sQ0FBQ3NCLE1BQU07QUFDakIsQ0FBQyxDQUVzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzPzAxNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5O1xuZXhwb3J0cy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zID0gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcztcbmV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuZnVuY3Rpb24gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBxdWVyeSA9IHt9O1xuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG4gICAgICAgICAgICAgICAgcXVlcnlba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkgfHwgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXModXJsUXVlcnkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSk9PntcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKT0+cmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0odmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCAuLi5zZWFyY2hQYXJhbXNMaXN0KSB7XG4gICAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpPT57XG4gICAgICAgIEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmtleXMoKSkuZm9yRWFjaCgoa2V5KT0+dGFyZ2V0LmRlbGV0ZShrZXkpXG4gICAgICAgICk7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+dGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiYXNzaWduIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmb3JFYWNoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsInRhcmdldCIsInNlYXJjaFBhcmFtc0xpc3QiLCJmcm9tIiwia2V5cyIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/querystring.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getRouteMatcher = getRouteMatcher;\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(routeRegex) {\n    var re = routeRegex.re, groups = routeRegex.groups;\n    return function(pathname) {\n        var routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        var decode = function(param) {\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError('failed to decode param');\n            }\n        };\n        var params = {};\n        Object.keys(groups).forEach(function(slugName) {\n            var g = groups[slugName];\n            var m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf('/') ? m.split('/').map(function(entry) {\n                    return decode(entry);\n                }) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRSxlQUFlO0FBQ3pDLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHQyxtQkFBTyxDQUFDLGlFQUFhO1NBQ3pCRixlQUFlLENBQUNHLFVBQVUsRUFBRSxDQUFDO0lBQ2xDLEdBQUssQ0FBR0MsRUFBRSxHQUFlRCxVQUFVLENBQTNCQyxFQUFFLEVBQUdDLE1BQU0sR0FBTUYsVUFBVSxDQUF0QkUsTUFBTTtJQUNuQixNQUFNLENBQUMsUUFBUSxDQUFQQyxRQUFRLEVBQUcsQ0FBQztRQUNoQixHQUFLLENBQUNDLFVBQVUsR0FBR0gsRUFBRSxDQUFDSSxJQUFJLENBQUNGLFFBQVE7UUFDbkMsRUFBRSxHQUFHQyxVQUFVLEVBQUUsQ0FBQztZQUNkLE1BQU0sQ0FBQyxLQUFLO1FBQ2hCLENBQUM7UUFDRCxHQUFLLENBQUNFLE1BQU0sR0FBRyxRQUFRLENBQVBDLEtBQUssRUFBRyxDQUFDO1lBQ3JCLEdBQUcsQ0FBQyxDQUFDO2dCQUNELE1BQU0sQ0FBQ0Msa0JBQWtCLENBQUNELEtBQUs7WUFDbkMsQ0FBQyxDQUFDLEtBQUssRUFBRUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ1QsS0FBSyxDQUFDLEdBQUcsQ0FBQ1gsTUFBTSxDQUFDWSxXQUFXLENBQUMsQ0FBd0I7WUFDekQsQ0FBQztRQUNMLENBQUM7UUFDRCxHQUFLLENBQUNDLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDakJsQixNQUFNLENBQUNtQixJQUFJLENBQUNWLE1BQU0sRUFBRVcsT0FBTyxDQUFDLFFBQVEsQ0FBUEMsUUFBUSxFQUFHLENBQUM7WUFDckMsR0FBSyxDQUFDQyxDQUFDLEdBQUdiLE1BQU0sQ0FBQ1ksUUFBUTtZQUN6QixHQUFLLENBQUNFLENBQUMsR0FBR1osVUFBVSxDQUFDVyxDQUFDLENBQUNFLEdBQUc7WUFDMUIsRUFBRSxFQUFFRCxDQUFDLEtBQUtFLFNBQVMsRUFBRSxDQUFDO2dCQUNsQlAsTUFBTSxDQUFDRyxRQUFRLEtBQUtFLENBQUMsQ0FBQ0csT0FBTyxDQUFDLENBQUcsTUFBSUgsQ0FBQyxDQUFDSSxLQUFLLENBQUMsQ0FBRyxJQUFFQyxHQUFHLENBQUMsUUFBUSxDQUFQQyxLQUFLO29CQUFHaEIsTUFBTSxDQUFOQSxNQUFNLENBQUNnQixLQUFLO3FCQUN2RVAsQ0FBQyxDQUFDUSxNQUFNLEdBQUcsQ0FBQztvQkFDWmpCLE1BQU0sQ0FBQ1UsQ0FBQztnQkFDWixDQUFDLEdBQUdWLE1BQU0sQ0FBQ1UsQ0FBQztZQUNoQixDQUFDO1FBQ0wsQ0FBQztRQUNELE1BQU0sQ0FBQ0wsTUFBTTtJQUNqQixDQUFDO0FBQ0wsQ0FBQyxDQUV3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIuanM/Yzg2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0Um91dGVNYXRjaGVyID0gZ2V0Um91dGVNYXRjaGVyO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KSB7XG4gICAgY29uc3QgeyByZSAsIGdyb3VwcyAgfSA9IHJvdXRlUmVnZXg7XG4gICAgcmV0dXJuIChwYXRobmFtZSk9PntcbiAgICAgICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuICAgICAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGUgPSAocGFyYW0pPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBfdXRpbHMuRGVjb2RlRXJyb3IoJ2ZhaWxlZCB0byBkZWNvZGUgcGFyYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZignLycpID8gbS5zcGxpdCgnLycpLm1hcCgoZW50cnkpPT5kZWNvZGUoZW50cnkpXG4gICAgICAgICAgICAgICAgKSA6IGcucmVwZWF0ID8gW1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGUobSlcbiAgICAgICAgICAgICAgICBdIDogZGVjb2RlKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1tYXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFJvdXRlTWF0Y2hlciIsIl91dGlscyIsInJlcXVpcmUiLCJyb3V0ZVJlZ2V4IiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwicGFyYW0iLCJkZWNvZGVVUklDb21wb25lbnQiLCJfIiwiRGVjb2RlRXJyb3IiLCJwYXJhbXMiLCJrZXlzIiwiZm9yRWFjaCIsInNsdWdOYW1lIiwiZyIsIm0iLCJwb3MiLCJ1bmRlZmluZWQiLCJpbmRleE9mIiwic3BsaXQiLCJtYXAiLCJlbnRyeSIsInJlcGVhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getParametrizedRoute = getParametrizedRoute;\nexports.getRouteRegex = getRouteRegex;\nvar _escapeRegexp = __webpack_require__(/*! ../../escape-regexp */ \"./node_modules/next/dist/shared/lib/escape-regexp.js\");\nfunction parseParameter(param) {\n    var optional = param.startsWith('[') && param.endsWith(']');\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    var repeat = param.startsWith('...');\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat: repeat,\n        optional: optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    var segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/');\n    var groups = {};\n    var groupIndex = 1;\n    var parameterizedRoute = segments.map(function(segment) {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n            var ref = parseParameter(segment.slice(1, -1)), key = ref.key, optional = ref.optional, repeat = ref.repeat;\n            groups[key] = {\n                pos: groupIndex++,\n                repeat: repeat,\n                optional: optional\n            };\n            return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n        } else {\n            return \"/\".concat((0, _escapeRegexp).escapeStringRegexp(segment));\n        }\n    }).join('');\n    // dead code eliminate for browser since it's only needed\n    // while generating routes-manifest\n    if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }\n    return {\n        parameterizedRoute: parameterizedRoute,\n        groups: groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    var result = getParametrizedRoute(normalizedRoute);\n    if ('routeKeys' in result) {\n        return {\n            re: new RegExp(\"^\".concat(result.parameterizedRoute, \"(?:/)?$\")),\n            groups: result.groups,\n            routeKeys: result.routeKeys,\n            namedRegex: \"^\".concat(result.namedParameterizedRoute, \"(?:/)?$\")\n        };\n    }\n    return {\n        re: new RegExp(\"^\".concat(result.parameterizedRoute, \"(?:/)?$\")),\n        groups: result.groups\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCw0QkFBNEIsR0FBR0Usb0JBQW9CO0FBQ25ERixxQkFBcUIsR0FBR0csYUFBYTtBQUNyQyxHQUFHLENBQUNDLGFBQWEsR0FBR0MsbUJBQU8sQ0FBQyxpRkFBcUI7U0FDeENDLGNBQWMsQ0FBQ0MsS0FBSyxFQUFFLENBQUM7SUFDNUIsR0FBSyxDQUFDQyxRQUFRLEdBQUdELEtBQUssQ0FBQ0UsVUFBVSxDQUFDLENBQUcsT0FBS0YsS0FBSyxDQUFDRyxRQUFRLENBQUMsQ0FBRztJQUM1RCxFQUFFLEVBQUVGLFFBQVEsRUFBRSxDQUFDO1FBQ1hELEtBQUssR0FBR0EsS0FBSyxDQUFDSSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDN0IsQ0FBQztJQUNELEdBQUssQ0FBQ0MsTUFBTSxHQUFHTCxLQUFLLENBQUNFLFVBQVUsQ0FBQyxDQUFLO0lBQ3JDLEVBQUUsRUFBRUcsTUFBTSxFQUFFLENBQUM7UUFDVEwsS0FBSyxHQUFHQSxLQUFLLENBQUNJLEtBQUssQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFDRCxNQUFNLENBQUMsQ0FBQztRQUNKRSxHQUFHLEVBQUVOLEtBQUs7UUFDVkssTUFBTSxFQUFOQSxNQUFNO1FBQ05KLFFBQVEsRUFBUkEsUUFBUTtJQUNaLENBQUM7QUFDTCxDQUFDO1NBQ1FOLG9CQUFvQixDQUFDWSxLQUFLLEVBQUUsQ0FBQztJQUNsQyxHQUFLLENBQUNDLFFBQVEsSUFBSUQsS0FBSyxDQUFDRSxPQUFPLFFBQVEsQ0FBRSxNQUFLLENBQUcsSUFBRUwsS0FBSyxDQUFDLENBQUMsRUFBRU0sS0FBSyxDQUFDLENBQUc7SUFDckUsR0FBSyxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHLENBQUM7SUFDbEIsR0FBSyxDQUFDQyxrQkFBa0IsR0FBR0wsUUFBUSxDQUFDTSxHQUFHLENBQUMsUUFBUSxDQUFQQyxPQUFPLEVBQUcsQ0FBQztRQUNoRCxFQUFFLEVBQUVBLE9BQU8sQ0FBQ2IsVUFBVSxDQUFDLENBQUcsT0FBS2EsT0FBTyxDQUFDWixRQUFRLENBQUMsQ0FBRyxLQUFHLENBQUM7WUFDbkQsR0FBSyxDQUFnQ0osR0FBb0MsR0FBcENBLGNBQWMsQ0FBQ2dCLE9BQU8sQ0FBQ1gsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQS9ERSxHQUFHLEdBQTBCUCxHQUFvQyxDQUFqRU8sR0FBRyxFQUFHTCxRQUFRLEdBQWVGLEdBQW9DLENBQTNERSxRQUFRLEVBQUdJLE1BQU0sR0FBTU4sR0FBb0MsQ0FBaERNLE1BQU07WUFDL0JNLE1BQU0sQ0FBQ0wsR0FBRyxJQUFJLENBQUM7Z0JBQ1hVLEdBQUcsRUFBRUosVUFBVTtnQkFDZlAsTUFBTSxFQUFOQSxNQUFNO2dCQUNOSixRQUFRLEVBQVJBLFFBQVE7WUFDWixDQUFDO1lBQ0QsTUFBTSxDQUFDSSxNQUFNLEdBQUdKLFFBQVEsR0FBRyxDQUFhLGVBQUcsQ0FBUSxVQUFHLENBQVc7UUFDckUsQ0FBQyxNQUFNLENBQUM7WUFDSixNQUFNLENBQUUsQ0FBQyxHQUFpRCxRQUE5QyxDQUFDLEVBQUVKLGFBQWEsRUFBRW9CLGtCQUFrQixDQUFDRixPQUFPO1FBQzVELENBQUM7SUFDTCxDQUFDLEVBQUVHLElBQUksQ0FBQyxDQUFFO0lBQ1YsRUFBeUQ7SUFDekQsRUFBbUM7SUFDbkMsRUFBRSxFQUFFLEtBQTZCLEVBQUUsa0dBK0NsQztJQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ0pMLGtCQUFrQixFQUFsQkEsa0JBQWtCO1FBQ2xCRixNQUFNLEVBQU5BLE1BQU07SUFDVixDQUFDO0FBQ0wsQ0FBQztTQUNRZixhQUFhLENBQUNxQyxlQUFlLEVBQUUsQ0FBQztJQUNyQyxHQUFLLENBQUNDLE1BQU0sR0FBR3ZDLG9CQUFvQixDQUFDc0MsZUFBZTtJQUNuRCxFQUFFLEVBQUUsQ0FBVyxjQUFJQyxNQUFNLEVBQUUsQ0FBQztRQUN4QixNQUFNLENBQUMsQ0FBQztZQUNKQyxFQUFFLEVBQUUsR0FBRyxDQUFDQyxNQUFNLENBQUUsQ0FBQyxHQUE0QixNQUFPLENBQWpDRixNQUFNLENBQUNyQixrQkFBa0IsRUFBQyxDQUFPO1lBQ3BERixNQUFNLEVBQUV1QixNQUFNLENBQUN2QixNQUFNO1lBQ3JCZSxTQUFTLEVBQUVRLE1BQU0sQ0FBQ1IsU0FBUztZQUMzQlcsVUFBVSxFQUFHLENBQUMsR0FBaUMsTUFBTyxDQUF0Q0gsTUFBTSxDQUFDUCx1QkFBdUIsRUFBQyxDQUFPO1FBQzFELENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxDQUFDLENBQUM7UUFDSlEsRUFBRSxFQUFFLEdBQUcsQ0FBQ0MsTUFBTSxDQUFFLENBQUMsR0FBNEIsTUFBTyxDQUFqQ0YsTUFBTSxDQUFDckIsa0JBQWtCLEVBQUMsQ0FBTztRQUNwREYsTUFBTSxFQUFFdUIsTUFBTSxDQUFDdkIsTUFBTTtJQUN6QixDQUFDO0FBQ0wsQ0FBQyxDQUVzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzP2VhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFBhcmFtZXRyaXplZFJvdXRlID0gZ2V0UGFyYW1ldHJpemVkUm91dGU7XG5leHBvcnRzLmdldFJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4O1xudmFyIF9lc2NhcGVSZWdleHAgPSByZXF1aXJlKFwiLi4vLi4vZXNjYXBlLXJlZ2V4cFwiKTtcbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKTtcbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpO1xuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBwYXJhbSxcbiAgICAgICAgcmVwZWF0LFxuICAgICAgICBvcHRpb25hbFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0cml6ZWRSb3V0ZShyb3V0ZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKHJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKS5zbGljZSgxKS5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGxldCBncm91cEluZGV4ID0gMTtcbiAgICBjb25zdCBwYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50cy5tYXAoKHNlZ21lbnQpPT57XG4gICAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5ICwgb3B0aW9uYWwgLCByZXBlYXQgIH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSk7XG4gICAgICAgICAgICBncm91cHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICByZXBlYXQsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyAnKD86LyguKz8pKT8nIDogJy8oLis/KScgOiAnLyhbXi9dKz8pJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgLyR7KDAsIF9lc2NhcGVSZWdleHApLmVzY2FwZVN0cmluZ1JlZ2V4cChzZWdtZW50KX1gO1xuICAgICAgICB9XG4gICAgfSkuam9pbignJyk7XG4gICAgLy8gZGVhZCBjb2RlIGVsaW1pbmF0ZSBmb3IgYnJvd3NlciBzaW5jZSBpdCdzIG9ubHkgbmVlZGVkXG4gICAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5NztcbiAgICAgICAgbGV0IHJvdXRlS2V5Q2hhckxlbmd0aCA9IDE7XG4gICAgICAgIC8vIGJ1aWxkcyBhIG1pbmltYWwgcm91dGVLZXkgdXNpbmcgb25seSBhLXogYW5kIG1pbmltYWwgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCk9PntcbiAgICAgICAgICAgIGxldCByb3V0ZUtleSA9ICcnO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJvdXRlS2V5Q2hhckxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpO1xuICAgICAgICAgICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrKztcbiAgICAgICAgICAgICAgICBpZiAocm91dGVLZXlDaGFyQ29kZSA+IDEyMikge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUtleUNoYXJMZW5ndGgrKztcbiAgICAgICAgICAgICAgICAgICAgcm91dGVLZXlDaGFyQ29kZSA9IDk3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUtleTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm91dGVLZXlzID0ge307XG4gICAgICAgIGxldCBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSA9IHNlZ21lbnRzLm1hcCgoc2VnbWVudCk9PntcbiAgICAgICAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleSAsIG9wdGlvbmFsICwgcmVwZWF0ICB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgYW55IG5vbi13b3JkIGNoYXJhY3RlcnMgc2luY2UgdGhleSBjYW4gYnJlYWtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbmFtZWQgcmVnZXhcbiAgICAgICAgICAgICAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgJycpO1xuICAgICAgICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbnZhbGlkIGFuZCBmYWxsYmFjayB0byB1c2luZyBhIGtub3duXG4gICAgICAgICAgICAgICAgLy8gc2FmZSBrZXlcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5lZEtleS5sZW5ndGggPT09IDAgfHwgY2xlYW5lZEtleS5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChjbGVhbmVkS2V5LnNsaWNlKDAsIDEpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWRLZXkgPSBnZXRTYWZlUm91dGVLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBlYXQgPyBvcHRpb25hbCA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgIDogYC8oPzwke2NsZWFuZWRLZXl9PlteL10rPylgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYC8keygwLCBfZXNjYXBlUmVnZXhwKS5lc2NhcGVTdHJpbmdSZWdleHAoc2VnbWVudCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJpemVkUm91dGUsXG4gICAgICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSxcbiAgICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICAgIHJvdXRlS2V5c1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbWV0ZXJpemVkUm91dGUsXG4gICAgICAgIGdyb3Vwc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgaWYgKCdyb3V0ZUtleXMnIGluIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3Jlc3VsdC5wYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgICAgICAgICAgZ3JvdXBzOiByZXN1bHQuZ3JvdXBzLFxuICAgICAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzLFxuICAgICAgICAgICAgbmFtZWRSZWdleDogYF4ke3Jlc3VsdC5uYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZTogbmV3IFJlZ0V4cChgXiR7cmVzdWx0LnBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICAgIGdyb3VwczogcmVzdWx0Lmdyb3Vwc1xuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLXJlZ2V4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFBhcmFtZXRyaXplZFJvdXRlIiwiZ2V0Um91dGVSZWdleCIsIl9lc2NhcGVSZWdleHAiLCJyZXF1aXJlIiwicGFyc2VQYXJhbWV0ZXIiLCJwYXJhbSIsIm9wdGlvbmFsIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJyZXBlYXQiLCJrZXkiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVwbGFjZSIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJwb3MiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJqb2luIiwicm91dGVLZXlDaGFyQ29kZSIsInJvdXRlS2V5Q2hhckxlbmd0aCIsImdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5IiwiaSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJvdXRlS2V5cyIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwiY2xlYW5lZEtleSIsImludmFsaWRLZXkiLCJsZW5ndGgiLCJpc05hTiIsInBhcnNlSW50Iiwibm9ybWFsaXplZFJvdXRlIiwicmVzdWx0IiwicmUiLCJSZWdFeHAiLCJuYW1lZFJlZ2V4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n");

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\"));\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nvar _typeof = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.ST = exports.SP = exports.warnOnce = void 0;\nfunction execOnce(fn) {\n    var used = false;\n    var result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn.apply(void 0, _toConsumableArray(args));\n        }\n        return result;\n    };\n}\nfunction getLocationOrigin() {\n    var _location = window.location, protocol = _location.protocol, hostname = _location.hostname, port = _location.port;\n    return \"\".concat(protocol, \"//\").concat(hostname).concat(port ? ':' + port : '');\n}\nfunction getURL() {\n    var href = window.location.href;\n    var origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    var urlParts = url.split('?');\n    var urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\".concat(urlParts.slice(1).join('?')) : '');\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _asyncToGenerator(_runtimeJs.default.mark(function _callee(App, ctx) {\n        var ref, message, res, props, message1;\n        return _runtimeJs.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    if (false) {}\n                    ;\n                    if (!((ref = App.prototype) === null || ref === void 0 ? void 0 : ref.getInitialProps)) {\n                        _ctx.next = 5;\n                        break;\n                    }\n                    message = \"\\\"\".concat(getDisplayName(App), \".getInitialProps()\\\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.\");\n                    throw new Error(message);\n                case 5:\n                    res = ctx.res || ctx.ctx && ctx.ctx.res;\n                    if (App.getInitialProps) {\n                        _ctx.next = 13;\n                        break;\n                    }\n                    if (!(ctx.ctx && ctx.Component)) {\n                        _ctx.next = 12;\n                        break;\n                    }\n                    _ctx.next = 10;\n                    return loadGetInitialProps(ctx.Component, ctx.ctx);\n                case 10:\n                    _ctx.t0 = _ctx.sent;\n                    return _ctx.abrupt(\"return\", {\n                        pageProps: _ctx.t0\n                    });\n                case 12:\n                    return _ctx.abrupt(\"return\", {});\n                case 13:\n                    _ctx.next = 15;\n                    return App.getInitialProps(ctx);\n                case 15:\n                    props = _ctx.sent;\n                    if (!(res && isResSent(res))) {\n                        _ctx.next = 18;\n                        break;\n                    }\n                    return _ctx.abrupt(\"return\", props);\n                case 18:\n                    if (props) {\n                        _ctx.next = 21;\n                        break;\n                    }\n                    message1 = \"\\\"\".concat(getDisplayName(App), \".getInitialProps()\\\" should resolve to an object. But found \\\"\").concat(props, \"\\\" instead.\");\n                    throw new Error(message1);\n                case 21:\n                    if (true) {\n                        if (Object.keys(props).length === 0 && !ctx.ctx) {\n                            console.warn(\"\".concat(getDisplayName(App), \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\"));\n                        }\n                    }\n                    return _ctx.abrupt(\"return\", props);\n                case 23:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return _loadGetInitialProps.apply(this, arguments);\n}\nvar warnOnce = function(_) {};\nexports.warnOnce = warnOnce;\nif (true) {\n    var warnings = new Set();\n    exports.warnOnce = warnOnce = function(msg) {\n        if (!warnings.has(msg)) {\n            console.warn(msg);\n        }\n        warnings.add(msg);\n    };\n}\nvar SP = typeof performance !== 'undefined';\nexports.SP = SP;\nvar ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';\nexports.ST = ST;\nvar DecodeError = /*#__PURE__*/ function(Error) {\n    _inherits(DecodeError, Error);\n    var _super = _createSuper(DecodeError);\n    function DecodeError() {\n        _classCallCheck(this, DecodeError);\n        return _super.apply(this, arguments);\n    }\n    return DecodeError;\n}(_wrapNativeSuper(Error));\nexports.DecodeError = DecodeError; //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFLFFBQVE7QUFDM0JGLHlCQUF5QixHQUFHRyxpQkFBaUI7QUFDN0NILGNBQWMsR0FBR0ksTUFBTTtBQUN2Qkosc0JBQXNCLEdBQUdLLGNBQWM7QUFDdkNMLGlCQUFpQixHQUFHTSxTQUFTO0FBQzdCTixnQ0FBZ0MsR0FBR08sd0JBQXdCO0FBQzNEUCwyQkFBMkIsR0FBR1EsbUJBQW1CO0FBQ2pEUixVQUFVLEdBQUdBLFVBQVUsR0FBR0EsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLENBQUM7U0FDMUNFLFFBQVEsQ0FBQ1UsRUFBRSxFQUFFLENBQUM7SUFDbkIsR0FBRyxDQUFDQyxJQUFJLEdBQUcsS0FBSztJQUNoQixHQUFHLENBQUNDLE1BQU07SUFDVixNQUFNLENBQUMsUUFBUSxHQUFHLENBQUM7eUNBQVJDLElBQUk7WUFBSkEsSUFBSTs7UUFDWCxFQUFFLEdBQUdGLElBQUksRUFBRSxDQUFDO1lBQ1JBLElBQUksR0FBRyxJQUFJO1lBQ1hDLE1BQU0sR0FBR0YsRUFBRSxDQUFGQSxLQUFXLENBQVhBLElBQUksQ0FBSkEsQ0FBRSxxQkFBSUcsSUFBSTtRQUN2QixDQUFDO1FBQ0QsTUFBTSxDQUFDRCxNQUFNO0lBQ2pCLENBQUM7QUFDTCxDQUFDO1NBQ1FYLGlCQUFpQixHQUFHLENBQUM7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QUFFLEdBQUcsTUFBTSxDQUFDOEMsV0FBVyxLQUFLLENBQVc7QUFDN0N4RCxVQUFVLEdBQUdVLEVBQUU7QUFDZixHQUFLLENBQUNELEVBQUUsR0FBR0MsRUFBRSxJQUFJLE1BQU0sQ0FBQzhDLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLLENBQVUsYUFBSSxNQUFNLENBQUNELFdBQVcsQ0FBQ0UsT0FBTyxLQUFLLENBQVU7QUFDcEcxRCxVQUFVLEdBQUdTLEVBQUU7SUFDVGtELFdBQVcsaUJBQWpCLFFBQVE7OzthQUFGQSxXQUFXOzs7OzttQkFBU2QsS0FBSztBQUUvQjdDLG1CQUFtQixHQUFHMkQsV0FBVyxDQUVqQyxDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanM/ZTdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXhlY09uY2UgPSBleGVjT25jZTtcbmV4cG9ydHMuZ2V0TG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbjtcbmV4cG9ydHMuZ2V0VVJMID0gZ2V0VVJMO1xuZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lO1xuZXhwb3J0cy5pc1Jlc1NlbnQgPSBpc1Jlc1NlbnQ7XG5leHBvcnRzLm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyA9IG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcztcbmV4cG9ydHMubG9hZEdldEluaXRpYWxQcm9wcyA9IGxvYWRHZXRJbml0aWFsUHJvcHM7XG5leHBvcnRzLlNUID0gZXhwb3J0cy5TUCA9IGV4cG9ydHMud2Fybk9uY2UgPSB2b2lkIDA7XG5mdW5jdGlvbiBleGVjT25jZShmbikge1xuICAgIGxldCB1c2VkID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpPT57XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgICBjb25zdCB7IHByb3RvY29sICwgaG9zdG5hbWUgLCBwb3J0ICB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWA7XG59XG5mdW5jdGlvbiBnZXRVUkwoKSB7XG4gICAgY29uc3QgeyBocmVmICB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbn1cbmZ1bmN0aW9uIGlzUmVzU2VudChyZXMpIHtcbiAgICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyh1cmwpIHtcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5zcGxpdCgnPycpO1xuICAgIGNvbnN0IHVybE5vUXVlcnkgPSB1cmxQYXJ0c1swXTtcbiAgICByZXR1cm4gdXJsTm9RdWVyeS8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuICAgIC8vIHRoZW4gbm9ybWFsaXplIHJlcGVhdGVkIGZvcndhcmQgc2xhc2hlc1xuICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvXFwvKy9nLCAnLycpICsgKHVybFBhcnRzWzFdID8gYD8ke3VybFBhcnRzLnNsaWNlKDEpLmpvaW4oJz8nKX1gIDogJycpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGN0eCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGlmICgocmVmID0gQXBwLnByb3RvdHlwZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShBcHApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICAgIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgY3R4LmN0eCAmJiBjdHguY3R4LnJlcztcbiAgICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KTtcbiAgICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShBcHApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtnZXREaXNwbGF5TmFtZShBcHApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cbmxldCB3YXJuT25jZSA9IChfKT0+e307XG5leHBvcnRzLndhcm5PbmNlID0gd2Fybk9uY2U7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHdhcm5pbmdzID0gbmV3IFNldCgpO1xuICAgIGV4cG9ydHMud2Fybk9uY2UgPSB3YXJuT25jZSA9IChtc2cpPT57XG4gICAgICAgIGlmICghd2FybmluZ3MuaGFzKG1zZykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdzLmFkZChtc2cpO1xuICAgIH07XG59XG5jb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCc7XG5leHBvcnRzLlNQID0gU1A7XG5jb25zdCBTVCA9IFNQICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5TVCA9IFNUO1xuY2xhc3MgRGVjb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnRzLkRlY29kZUVycm9yID0gRGVjb2RlRXJyb3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV4ZWNPbmNlIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJTVCIsIlNQIiwid2Fybk9uY2UiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJyZXMiLCJmaW5pc2hlZCIsImhlYWRlcnNTZW50IiwidXJsIiwidXJsUGFydHMiLCJzcGxpdCIsInVybE5vUXVlcnkiLCJyZXBsYWNlIiwic2xpY2UiLCJqb2luIiwiQXBwIiwiY3R4IiwicmVmIiwibWVzc2FnZSIsInByb3BzIiwicHJvdG90eXBlIiwiZ2V0SW5pdGlhbFByb3BzIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJrZXlzIiwiY29uc29sZSIsIndhcm4iLCJfIiwid2FybmluZ3MiLCJTZXQiLCJtc2ciLCJoYXMiLCJhZGQiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJtZWFzdXJlIiwiRGVjb2RlRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/utils.js\n");

/***/ })

});