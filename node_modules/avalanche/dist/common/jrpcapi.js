"use strict";
/**
 * @packageDocumentation
 * @module Common-JRPCAPI
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JRPCAPI = void 0;
const utils_1 = require("../utils");
const apibase_1 = require("./apibase");
class JRPCAPI extends apibase_1.APIBase {
    /**
     *
     * @param core Reference to the Avalanche instance using this endpoint
     * @param baseURL Path of the APIs baseURL - ex: "/ext/bc/avm"
     * @param jrpcVersion The jrpc version to use, default "2.0".
     */
    constructor(core, baseURL, jrpcVersion = "2.0") {
        super(core, baseURL);
        this.jrpcVersion = "2.0";
        this.rpcID = 1;
        this.callMethod = (method, params, baseURL, headers) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseURL || this.baseURL;
            const rpc = {};
            rpc.id = this.rpcID;
            rpc.method = method;
            // Set parameters if exists
            if (params) {
                rpc.params = params;
            }
            else if (this.jrpcVersion === "1.0") {
                rpc.params = [];
            }
            if (this.jrpcVersion !== "1.0") {
                rpc.jsonrpc = this.jrpcVersion;
            }
            let headrs = { "Content-Type": "application/json;charset=UTF-8" };
            if (headers) {
                headrs = Object.assign(Object.assign({}, headrs), headers);
            }
            baseURL = `${this.core.getProtocol()}://${this.core.getHost()}`;
            const port = this.core.getPort();
            if (port != undefined && typeof port === "number" && port >= 0) {
                baseURL = `${baseURL}:${port}`;
            }
            const axConf = {
                baseURL: baseURL,
                responseType: "json",
                // use the fetch adapter if fetch is available e.g. non Node<17 env
                adapter: typeof fetch !== "undefined" ? utils_1.fetchAdapter : undefined
            };
            const resp = yield this.core.post(ep, {}, JSON.stringify(rpc), headrs, axConf);
            if (resp.status >= 200 && resp.status < 300) {
                this.rpcID += 1;
                if (typeof resp.data === "string") {
                    resp.data = JSON.parse(resp.data);
                }
                if (typeof resp.data === "object" &&
                    (resp.data === null || "error" in resp.data)) {
                    throw new Error(resp.data.error.message);
                }
            }
            return resp;
        });
        /**
         * Returns the rpcid, a strictly-increasing number, starting from 1, indicating the next
         * request ID that will be sent.
         */
        this.getRPCID = () => this.rpcID;
        this.jrpcVersion = jrpcVersion;
        this.rpcID = 1;
    }
}
exports.JRPCAPI = JRPCAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianJwY2FwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vanJwY2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7QUFHSCxvQ0FBdUM7QUFFdkMsdUNBQXdEO0FBRXhELE1BQWEsT0FBUSxTQUFRLGlCQUFPO0lBd0VsQzs7Ozs7T0FLRztJQUNILFlBQ0UsSUFBbUIsRUFDbkIsT0FBZSxFQUNmLGNBQXNCLEtBQUs7UUFFM0IsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQTtRQWxGWixnQkFBVyxHQUFXLEtBQUssQ0FBQTtRQUMzQixVQUFLLEdBQUcsQ0FBQyxDQUFBO1FBRW5CLGVBQVUsR0FBRyxDQUNYLE1BQWMsRUFDZCxNQUEwQixFQUMxQixPQUFnQixFQUNoQixPQUFnQixFQUNjLEVBQUU7WUFDaEMsTUFBTSxFQUFFLEdBQVcsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUE7WUFDMUMsTUFBTSxHQUFHLEdBQVEsRUFBRSxDQUFBO1lBQ25CLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQTtZQUNuQixHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQTtZQUVuQiwyQkFBMkI7WUFDM0IsSUFBSSxNQUFNLEVBQUU7Z0JBQ1YsR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7YUFDcEI7aUJBQU0sSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLEtBQUssRUFBRTtnQkFDckMsR0FBRyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUE7YUFDaEI7WUFFRCxJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssS0FBSyxFQUFFO2dCQUM5QixHQUFHLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUE7YUFDL0I7WUFFRCxJQUFJLE1BQU0sR0FBVyxFQUFFLGNBQWMsRUFBRSxnQ0FBZ0MsRUFBRSxDQUFBO1lBQ3pFLElBQUksT0FBTyxFQUFFO2dCQUNYLE1BQU0sbUNBQVEsTUFBTSxHQUFLLE9BQU8sQ0FBRSxDQUFBO2FBQ25DO1lBRUQsT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUE7WUFDL0QsTUFBTSxJQUFJLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQTtZQUN4QyxJQUFJLElBQUksSUFBSSxTQUFTLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUU7Z0JBQzlELE9BQU8sR0FBRyxHQUFHLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQTthQUMvQjtZQUVELE1BQU0sTUFBTSxHQUF1QjtnQkFDakMsT0FBTyxFQUFFLE9BQU87Z0JBQ2hCLFlBQVksRUFBRSxNQUFNO2dCQUNwQixtRUFBbUU7Z0JBQ25FLE9BQU8sRUFBRSxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLG9CQUFZLENBQUMsQ0FBQyxDQUFDLFNBQVM7YUFDakUsQ0FBQTtZQUVELE1BQU0sSUFBSSxHQUF3QixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNwRCxFQUFFLEVBQ0YsRUFBRSxFQUNGLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQ25CLE1BQU0sRUFDTixNQUFNLENBQ1AsQ0FBQTtZQUNELElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUU7Z0JBQzNDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFBO2dCQUNmLElBQUksT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtvQkFDakMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtpQkFDbEM7Z0JBQ0QsSUFDRSxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUTtvQkFDN0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUM1QztvQkFDQSxNQUFNLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFBO2lCQUN6QzthQUNGO1lBQ0QsT0FBTyxJQUFJLENBQUE7UUFDYixDQUFDLENBQUEsQ0FBQTtRQUVEOzs7V0FHRztRQUNILGFBQVEsR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFBO1FBY2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFBO1FBQzlCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFBO0lBQ2hCLENBQUM7Q0FDRjtBQXZGRCwwQkF1RkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBDb21tb24tSlJQQ0FQSVxuICovXG5cbmltcG9ydCB7IEF4aW9zUmVxdWVzdENvbmZpZyB9IGZyb20gXCJheGlvc1wiXG5pbXBvcnQgeyBmZXRjaEFkYXB0ZXIgfSBmcm9tIFwiLi4vdXRpbHNcIlxuaW1wb3J0IEF2YWxhbmNoZUNvcmUgZnJvbSBcIi4uL2F2YWxhbmNoZVwiXG5pbXBvcnQgeyBBUElCYXNlLCBSZXF1ZXN0UmVzcG9uc2VEYXRhIH0gZnJvbSBcIi4vYXBpYmFzZVwiXG5cbmV4cG9ydCBjbGFzcyBKUlBDQVBJIGV4dGVuZHMgQVBJQmFzZSB7XG4gIHByb3RlY3RlZCBqcnBjVmVyc2lvbjogc3RyaW5nID0gXCIyLjBcIlxuICBwcm90ZWN0ZWQgcnBjSUQgPSAxXG5cbiAgY2FsbE1ldGhvZCA9IGFzeW5jIChcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBwYXJhbXM/OiBvYmplY3RbXSB8IG9iamVjdCxcbiAgICBiYXNlVVJMPzogc3RyaW5nLFxuICAgIGhlYWRlcnM/OiBvYmplY3RcbiAgKTogUHJvbWlzZTxSZXF1ZXN0UmVzcG9uc2VEYXRhPiA9PiB7XG4gICAgY29uc3QgZXA6IHN0cmluZyA9IGJhc2VVUkwgfHwgdGhpcy5iYXNlVVJMXG4gICAgY29uc3QgcnBjOiBhbnkgPSB7fVxuICAgIHJwYy5pZCA9IHRoaXMucnBjSURcbiAgICBycGMubWV0aG9kID0gbWV0aG9kXG5cbiAgICAvLyBTZXQgcGFyYW1ldGVycyBpZiBleGlzdHNcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBycGMucGFyYW1zID0gcGFyYW1zXG4gICAgfSBlbHNlIGlmICh0aGlzLmpycGNWZXJzaW9uID09PSBcIjEuMFwiKSB7XG4gICAgICBycGMucGFyYW1zID0gW11cbiAgICB9XG5cbiAgICBpZiAodGhpcy5qcnBjVmVyc2lvbiAhPT0gXCIxLjBcIikge1xuICAgICAgcnBjLmpzb25ycGMgPSB0aGlzLmpycGNWZXJzaW9uXG4gICAgfVxuXG4gICAgbGV0IGhlYWRyczogb2JqZWN0ID0geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOFwiIH1cbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgaGVhZHJzID0geyAuLi5oZWFkcnMsIC4uLmhlYWRlcnMgfVxuICAgIH1cblxuICAgIGJhc2VVUkwgPSBgJHt0aGlzLmNvcmUuZ2V0UHJvdG9jb2woKX06Ly8ke3RoaXMuY29yZS5nZXRIb3N0KCl9YFxuICAgIGNvbnN0IHBvcnQ6IG51bWJlciA9IHRoaXMuY29yZS5nZXRQb3J0KClcbiAgICBpZiAocG9ydCAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIHBvcnQgPT09IFwibnVtYmVyXCIgJiYgcG9ydCA+PSAwKSB7XG4gICAgICBiYXNlVVJMID0gYCR7YmFzZVVSTH06JHtwb3J0fWBcbiAgICB9XG5cbiAgICBjb25zdCBheENvbmY6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGJhc2VVUkw6IGJhc2VVUkwsXG4gICAgICByZXNwb25zZVR5cGU6IFwianNvblwiLFxuICAgICAgLy8gdXNlIHRoZSBmZXRjaCBhZGFwdGVyIGlmIGZldGNoIGlzIGF2YWlsYWJsZSBlLmcuIG5vbiBOb2RlPDE3IGVudlxuICAgICAgYWRhcHRlcjogdHlwZW9mIGZldGNoICE9PSBcInVuZGVmaW5lZFwiID8gZmV0Y2hBZGFwdGVyIDogdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcDogUmVxdWVzdFJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuY29yZS5wb3N0KFxuICAgICAgZXAsXG4gICAgICB7fSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHJwYyksXG4gICAgICBoZWFkcnMsXG4gICAgICBheENvbmZcbiAgICApXG4gICAgaWYgKHJlc3Auc3RhdHVzID49IDIwMCAmJiByZXNwLnN0YXR1cyA8IDMwMCkge1xuICAgICAgdGhpcy5ycGNJRCArPSAxXG4gICAgICBpZiAodHlwZW9mIHJlc3AuZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXNwLmRhdGEgPSBKU09OLnBhcnNlKHJlc3AuZGF0YSlcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHJlc3AuZGF0YSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAocmVzcC5kYXRhID09PSBudWxsIHx8IFwiZXJyb3JcIiBpbiByZXNwLmRhdGEpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3AuZGF0YS5lcnJvci5tZXNzYWdlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJwY2lkLCBhIHN0cmljdGx5LWluY3JlYXNpbmcgbnVtYmVyLCBzdGFydGluZyBmcm9tIDEsIGluZGljYXRpbmcgdGhlIG5leHRcbiAgICogcmVxdWVzdCBJRCB0aGF0IHdpbGwgYmUgc2VudC5cbiAgICovXG4gIGdldFJQQ0lEID0gKCk6IG51bWJlciA9PiB0aGlzLnJwY0lEXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBjb3JlIFJlZmVyZW5jZSB0byB0aGUgQXZhbGFuY2hlIGluc3RhbmNlIHVzaW5nIHRoaXMgZW5kcG9pbnRcbiAgICogQHBhcmFtIGJhc2VVUkwgUGF0aCBvZiB0aGUgQVBJcyBiYXNlVVJMIC0gZXg6IFwiL2V4dC9iYy9hdm1cIlxuICAgKiBAcGFyYW0ganJwY1ZlcnNpb24gVGhlIGpycGMgdmVyc2lvbiB0byB1c2UsIGRlZmF1bHQgXCIyLjBcIi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvcmU6IEF2YWxhbmNoZUNvcmUsXG4gICAgYmFzZVVSTDogc3RyaW5nLFxuICAgIGpycGNWZXJzaW9uOiBzdHJpbmcgPSBcIjIuMFwiXG4gICkge1xuICAgIHN1cGVyKGNvcmUsIGJhc2VVUkwpXG4gICAgdGhpcy5qcnBjVmVyc2lvbiA9IGpycGNWZXJzaW9uXG4gICAgdGhpcy5ycGNJRCA9IDFcbiAgfVxufVxuIl19